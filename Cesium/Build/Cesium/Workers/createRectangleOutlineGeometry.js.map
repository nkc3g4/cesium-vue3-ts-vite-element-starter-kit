{"version":3,"file":"createRectangleOutlineGeometry.js","sources":["../../../../Source/Core/RectangleOutlineGeometry.js","../../../../Source/WorkersES6/createRectangleOutlineGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\n\nconst bottomBoundingSphere = new BoundingSphere();\nconst topBoundingSphere = new BoundingSphere();\nconst positionScratch = new Cartesian3();\nconst rectangleScratch = new Rectangle();\n\nfunction constructRectangle(geometry, computedOptions) {\n  const ellipsoid = geometry._ellipsoid;\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n  const northCap = computedOptions.northCap;\n  const southCap = computedOptions.southCap;\n\n  let rowHeight = height;\n  let widthMultiplier = 2;\n  let size = 0;\n  let corners = 4;\n  if (northCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    size += 1;\n    corners -= 2;\n  }\n  if (southCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    size += 1;\n    corners -= 2;\n  }\n  size += widthMultiplier * width + 2 * rowHeight - corners;\n\n  const positions = new Float64Array(size * 3);\n\n  let posIndex = 0;\n  let row = 0;\n  let col;\n  const position = positionScratch;\n  if (northCap) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      0,\n      position\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  } else {\n    for (col = 0; col < width; col++) {\n      RectangleGeometryLibrary.computePosition(\n        computedOptions,\n        ellipsoid,\n        false,\n        row,\n        col,\n        position\n      );\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n    }\n  }\n\n  col = width - 1;\n  for (row = 1; row < height; row++) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      col,\n      position\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  }\n\n  row = height - 1;\n  if (!southCap) {\n    // if southCap is true, we dont need to add any more points because the south pole point was added by the iteration above\n    for (col = width - 2; col >= 0; col--) {\n      RectangleGeometryLibrary.computePosition(\n        computedOptions,\n        ellipsoid,\n        false,\n        row,\n        col,\n        position\n      );\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n    }\n  }\n\n  col = 0;\n  for (row = height - 2; row > 0; row--) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      col,\n      position\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  }\n\n  const indicesSize = (positions.length / 3) * 2;\n  const indices = IndexDatatype.createTypedArray(\n    positions.length / 3,\n    indicesSize\n  );\n\n  let index = 0;\n  for (let i = 0; i < positions.length / 3 - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n  indices[index++] = positions.length / 3 - 1;\n  indices[index++] = 0;\n\n  const geo = new Geometry({\n    attributes: new GeometryAttributes(),\n    primitiveType: PrimitiveType.LINES,\n  });\n\n  geo.attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n  geo.indices = indices;\n\n  return geo;\n}\n\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n  const surfaceHeight = rectangleGeometry._surfaceHeight;\n  const extrudedHeight = rectangleGeometry._extrudedHeight;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const minHeight = extrudedHeight;\n  const maxHeight = surfaceHeight;\n  const geo = constructRectangle(rectangleGeometry, computedOptions);\n\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n\n  const topPositions = PolygonPipeline.scaleToGeodeticHeight(\n    geo.attributes.position.values,\n    maxHeight,\n    ellipsoid,\n    false\n  );\n  let length = topPositions.length;\n  const positions = new Float64Array(length * 2);\n  positions.set(topPositions);\n  const bottomPositions = PolygonPipeline.scaleToGeodeticHeight(\n    geo.attributes.position.values,\n    minHeight,\n    ellipsoid\n  );\n  positions.set(bottomPositions, length);\n  geo.attributes.position.values = positions;\n\n  const northCap = computedOptions.northCap;\n  const southCap = computedOptions.southCap;\n  let corners = 4;\n  if (northCap) {\n    corners -= 1;\n  }\n  if (southCap) {\n    corners -= 1;\n  }\n\n  const indicesSize = (positions.length / 3 + corners) * 2;\n  const indices = IndexDatatype.createTypedArray(\n    positions.length / 3,\n    indicesSize\n  );\n  length = positions.length / 6;\n  let index = 0;\n  for (let i = 0; i < length - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n    indices[index++] = i + length;\n    indices[index++] = i + length + 1;\n  }\n  indices[index++] = length - 1;\n  indices[index++] = 0;\n  indices[index++] = length + length - 1;\n  indices[index++] = length;\n\n  indices[index++] = 0;\n  indices[index++] = length;\n\n  let bottomCorner;\n  if (northCap) {\n    bottomCorner = height - 1;\n  } else {\n    const topRightCorner = width - 1;\n    indices[index++] = topRightCorner;\n    indices[index++] = topRightCorner + length;\n    bottomCorner = width + height - 2;\n  }\n\n  indices[index++] = bottomCorner;\n  indices[index++] = bottomCorner + length;\n\n  if (!southCap) {\n    const bottomLeftCorner = width + bottomCorner - 1;\n    indices[index++] = bottomLeftCorner;\n    indices[index] = bottomLeftCorner + length;\n  }\n\n  geo.indices = indices;\n\n  return geo;\n}\n\n/**\n * A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.\n *\n * @alias RectangleOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n *\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>rectangle.south</code>.\n *\n * @see RectangleOutlineGeometry#createGeometry\n *\n * @example\n * const rectangle = new Cesium.RectangleOutlineGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * const geometry = Cesium.RectangleOutlineGeometry.createGeometry(rectangle);\n */\nfunction RectangleOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const rectangle = options.rectangle;\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  const rotation = defaultValue(options.rotation, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required.\");\n  }\n  Rectangle.validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\n      \"options.rectangle.north must be greater than options.rectangle.south\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._rectangle = Rectangle.clone(rectangle);\n  this._granularity = granularity;\n  this._ellipsoid = ellipsoid;\n  this._surfaceHeight = Math.max(height, extrudedHeight);\n  this._rotation = rotation;\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createRectangleOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nRectangleOutlineGeometry.packedLength =\n  Rectangle.packedLength + Ellipsoid.packedLength + 5;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {RectangleOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nRectangleOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Rectangle.pack(value._rectangle, array, startingIndex);\n  startingIndex += Rectangle.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._surfaceHeight;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchRectangle = new Rectangle();\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  rectangle: scratchRectangle,\n  ellipsoid: scratchEllipsoid,\n  granularity: undefined,\n  height: undefined,\n  rotation: undefined,\n  extrudedHeight: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {RectangleOutlineGeometry} [result] The object into which to store the result.\n * @returns {RectangleOutlineGeometry} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nRectangleOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n  startingIndex += Rectangle.packedLength;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const granularity = array[startingIndex++];\n  const height = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.granularity = granularity;\n    scratchOptions.height = height;\n    scratchOptions.rotation = rotation;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new RectangleOutlineGeometry(scratchOptions);\n  }\n\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._surfaceHeight = height;\n  result._rotation = rotation;\n  result._extrudedHeight = extrudedHeight;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\nconst nwScratch = new Cartographic();\n/**\n * Computes the geometric representation of an outline of a rectangle, including its vertices, indices, and a bounding sphere.\n *\n * @param {RectangleOutlineGeometry} rectangleGeometry A description of the rectangle outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n *\n * @exception {DeveloperError} Rotated rectangle is invalid.\n */\nRectangleOutlineGeometry.createGeometry = function (rectangleGeometry) {\n  const rectangle = rectangleGeometry._rectangle;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const computedOptions = RectangleGeometryLibrary.computeOptions(\n    rectangle,\n    rectangleGeometry._granularity,\n    rectangleGeometry._rotation,\n    0,\n    rectangleScratch,\n    nwScratch\n  );\n\n  let geometry;\n  let boundingSphere;\n\n  if (\n    CesiumMath.equalsEpsilon(\n      rectangle.north,\n      rectangle.south,\n      CesiumMath.EPSILON10\n    ) ||\n    CesiumMath.equalsEpsilon(\n      rectangle.east,\n      rectangle.west,\n      CesiumMath.EPSILON10\n    )\n  ) {\n    return undefined;\n  }\n\n  const surfaceHeight = rectangleGeometry._surfaceHeight;\n  const extrudedHeight = rectangleGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    surfaceHeight,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n  let offsetValue;\n  if (extrude) {\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      const size = geometry.attributes.position.values.length / 3;\n      let offsetAttribute = new Uint8Array(size);\n      if (rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n      } else {\n        offsetValue =\n          rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n      }\n\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: offsetAttribute,\n      });\n    }\n    const topBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight,\n      topBoundingSphere\n    );\n    const bottomBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      extrudedHeight,\n      bottomBoundingSphere\n    );\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\n  } else {\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      geometry.attributes.position.values,\n      surfaceHeight,\n      ellipsoid,\n      false\n    );\n\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      const applyOffset = new Uint8Array(length / 3);\n      offsetValue =\n        rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      arrayFill(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n\n    boundingSphere = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight\n    );\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: rectangleGeometry._offsetAttribute,\n  });\n};\nexport default RectangleOutlineGeometry;\n","import defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RectangleOutlineGeometry from \"../Core/RectangleOutlineGeometry.js\";\n\nfunction createRectangleOutlineGeometry(rectangleGeometry, offset) {\n  if (defined(offset)) {\n    rectangleGeometry = RectangleOutlineGeometry.unpack(\n      rectangleGeometry,\n      offset\n    );\n  }\n  rectangleGeometry._ellipsoid = Ellipsoid.clone(rectangleGeometry._ellipsoid);\n  rectangleGeometry._rectangle = Rectangle.clone(rectangleGeometry._rectangle);\n  return RectangleOutlineGeometry.createGeometry(rectangleGeometry);\n}\nexport default createRectangleOutlineGeometry;\n"],"names":["bottomBoundingSphere","BoundingSphere","topBoundingSphere","positionScratch","Cartesian3","rectangleScratch","Rectangle","constructRectangle","geometry","computedOptions","ellipsoid","_ellipsoid","height","width","northCap","southCap","rowHeight","widthMultiplier","size","corners","positions","Float64Array","col","posIndex","row","position","RectangleGeometryLibrary","computePosition","x","y","z","indicesSize","length","indices","IndexDatatype","createTypedArray","index","i","geo","Geometry","attributes","GeometryAttributes","primitiveType","PrimitiveType","LINES","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","RectangleOutlineGeometry","options","rectangle","defaultValue","EMPTY_OBJECT","granularity","CesiumMath","RADIANS_PER_DEGREE","Ellipsoid","WGS84","rotation","defined","DeveloperError","validate","north","south","extrudedHeight","this","_rectangle","clone","_granularity","_surfaceHeight","Math","max","_rotation","_extrudedHeight","min","_offsetAttribute","offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchRectangle","scratchEllipsoid","UNIT_SPHERE","scratchOptions","undefined","unpack","result","nwScratch","Cartographic","createGeometry","rectangleGeometry","computeOptions","boundingSphere","equalsEpsilon","EPSILON10","east","west","surfaceHeight","offsetValue","EPSILON2","minHeight","maxHeight","topPositions","PolygonPipeline","scaleToGeodeticHeight","set","bottomPositions","bottomCorner","topRightCorner","bottomLeftCorner","constructExtrudedRectangle","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","NONE","applyOffset","UNSIGNED_BYTE","topBS","fromRectangle3D","bottomBS","union","offset"],"mappings":"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"}