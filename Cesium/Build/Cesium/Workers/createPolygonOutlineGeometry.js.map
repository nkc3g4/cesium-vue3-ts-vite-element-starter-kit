{"version":3,"file":"createPolygonOutlineGeometry.js","sources":["../../../../Source/Core/PolygonOutlineGeometry.js","../../../../Source/WorkersES6/createPolygonOutlineGeometry.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\nimport arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\nconst createGeometryFromPositionsPositions = [];\nconst createGeometryFromPositionsSubdivided = [];\n\nfunction createGeometryFromPositions(\n  ellipsoid,\n  positions,\n  minDistance,\n  perPositionHeight,\n  arcType\n) {\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  const positions2D = tangentPlane.projectPointsOntoPlane(\n    positions,\n    createGeometryFromPositionsPositions\n  );\n\n  const originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\n    positions2D\n  );\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n    positions2D.reverse();\n    positions = positions.slice().reverse();\n  }\n\n  let subdividedPositions;\n  let i;\n\n  let length = positions.length;\n  let index = 0;\n\n  if (!perPositionHeight) {\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    }\n    subdividedPositions = new Float64Array(numVertices * 3);\n    for (i = 0; i < length; i++) {\n      let tempPositions;\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided\n        );\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided\n        );\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j) {\n        subdividedPositions[index++] = tempPositions[j];\n      }\n    }\n  } else {\n    subdividedPositions = new Float64Array(length * 2 * 3);\n    for (i = 0; i < length; i++) {\n      const p0 = positions[i];\n      const p1 = positions[(i + 1) % length];\n      subdividedPositions[index++] = p0.x;\n      subdividedPositions[index++] = p0.y;\n      subdividedPositions[index++] = p0.z;\n      subdividedPositions[index++] = p1.x;\n      subdividedPositions[index++] = p1.y;\n      subdividedPositions[index++] = p1.z;\n    }\n  }\n\n  length = subdividedPositions.length / 3;\n  const indicesSize = length * 2;\n  const indices = IndexDatatype.createTypedArray(length, indicesSize);\n  index = 0;\n  for (i = 0; i < length - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n  indices[index++] = length - 1;\n  indices[index++] = 0;\n\n  return new GeometryInstance({\n    geometry: new Geometry({\n      attributes: new GeometryAttributes({\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: subdividedPositions,\n        }),\n      }),\n      indices: indices,\n      primitiveType: PrimitiveType.LINES,\n    }),\n  });\n}\n\nfunction createGeometryFromPositionsExtruded(\n  ellipsoid,\n  positions,\n  minDistance,\n  perPositionHeight,\n  arcType\n) {\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  const positions2D = tangentPlane.projectPointsOntoPlane(\n    positions,\n    createGeometryFromPositionsPositions\n  );\n\n  const originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\n    positions2D\n  );\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n    positions2D.reverse();\n    positions = positions.slice().reverse();\n  }\n\n  let subdividedPositions;\n  let i;\n\n  let length = positions.length;\n  const corners = new Array(length);\n  let index = 0;\n\n  if (!perPositionHeight) {\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    }\n\n    subdividedPositions = new Float64Array(numVertices * 3 * 2);\n    for (i = 0; i < length; ++i) {\n      corners[i] = index / 3;\n      let tempPositions;\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided\n        );\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided\n        );\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j) {\n        subdividedPositions[index++] = tempPositions[j];\n      }\n    }\n  } else {\n    subdividedPositions = new Float64Array(length * 2 * 3 * 2);\n    for (i = 0; i < length; ++i) {\n      corners[i] = index / 3;\n      const p0 = positions[i];\n      const p1 = positions[(i + 1) % length];\n\n      subdividedPositions[index++] = p0.x;\n      subdividedPositions[index++] = p0.y;\n      subdividedPositions[index++] = p0.z;\n      subdividedPositions[index++] = p1.x;\n      subdividedPositions[index++] = p1.y;\n      subdividedPositions[index++] = p1.z;\n    }\n  }\n\n  length = subdividedPositions.length / (3 * 2);\n  const cornersLength = corners.length;\n\n  const indicesSize = (length * 2 + cornersLength) * 2;\n  const indices = IndexDatatype.createTypedArray(\n    length + cornersLength,\n    indicesSize\n  );\n\n  index = 0;\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = ((i + 1) % length) + length;\n  }\n\n  for (i = 0; i < cornersLength; i++) {\n    const corner = corners[i];\n    indices[index++] = corner;\n    indices[index++] = corner + length;\n  }\n\n  return new GeometryInstance({\n    geometry: new Geometry({\n      attributes: new GeometryAttributes({\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: subdividedPositions,\n        }),\n      }),\n      indices: indices,\n      primitiveType: PrimitiveType.LINES,\n    }),\n  });\n}\n\n/**\n * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.\n *\n * @alias PolygonOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @see PolygonOutlineGeometry#createGeometry\n * @see PolygonOutlineGeometry#fromPositions\n *\n * @example\n * // 1. create a polygon outline from points\n * const polygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes outline\n * const polygonWithHole = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon outline\n * const extrudedPolygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);\n */\nfunction PolygonOutlineGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n\n  if (options.perPositionHeight && defined(options.height)) {\n    throw new DeveloperError(\n      \"Cannot use both options.perPositionHeight and options.height\"\n    );\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const polygonHierarchy = options.polygonHierarchy;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  const perPositionHeight = defaultValue(options.perPositionHeight, false);\n  const perPositionHeightExtrude =\n    perPositionHeight && defined(options.extrudedHeight);\n  const arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n  let height = defaultValue(options.height, 0.0);\n  let extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  if (!perPositionHeightExtrude) {\n    const h = Math.max(height, extrudedHeight);\n    extrudedHeight = Math.min(height, extrudedHeight);\n    height = h;\n  }\n\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._granularity = granularity;\n  this._height = height;\n  this._extrudedHeight = extrudedHeight;\n  this._arcType = arcType;\n  this._polygonHierarchy = polygonHierarchy;\n  this._perPositionHeight = perPositionHeight;\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createPolygonOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) +\n    Ellipsoid.packedLength +\n    8;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPolygonOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n    value._polygonHierarchy,\n    array,\n    startingIndex\n  );\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n  array[startingIndex] = value.packedLength;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst dummyOptions = {\n  polygonHierarchy: {},\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonOutlineGeometry} [result] The object into which to store the result.\n * @returns {PolygonOutlineGeometry} The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.\n */\nPolygonOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\n    array,\n    startingIndex\n  );\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const perPositionHeightExtrude = array[startingIndex++] === 1.0;\n  const perPositionHeight = array[startingIndex++] === 1.0;\n  const arcType = array[startingIndex++];\n  const offsetAttribute = array[startingIndex++];\n  const packedLength = array[startingIndex];\n\n  if (!defined(result)) {\n    result = new PolygonOutlineGeometry(dummyOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._granularity = granularity;\n  result._perPositionHeight = perPositionHeight;\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\n  result._arcType = arcType;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n  result.packedLength = packedLength;\n\n  return result;\n};\n\n/**\n * A description of a polygon outline from an array of positions.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {Number} [options.height=0.0] The height of the polygon.\n * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.\n * @returns {PolygonOutlineGeometry}\n *\n *\n * @example\n * // create a polygon from points\n * const polygon = Cesium.PolygonOutlineGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * @see PolygonOutlineGeometry#createGeometry\n */\nPolygonOutlineGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  const newOptions = {\n    polygonHierarchy: {\n      positions: options.positions,\n    },\n    height: options.height,\n    extrudedHeight: options.extrudedHeight,\n    ellipsoid: options.ellipsoid,\n    granularity: options.granularity,\n    perPositionHeight: options.perPositionHeight,\n    arcType: options.arcType,\n    offsetAttribute: options.offsetAttribute,\n  };\n  return new PolygonOutlineGeometry(newOptions);\n};\n\n/**\n * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolygonOutlineGeometry} polygonGeometry A description of the polygon outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolygonOutlineGeometry.createGeometry = function (polygonGeometry) {\n  const ellipsoid = polygonGeometry._ellipsoid;\n  const granularity = polygonGeometry._granularity;\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\n  const perPositionHeight = polygonGeometry._perPositionHeight;\n  const arcType = polygonGeometry._arcType;\n\n  const polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(\n    polygonHierarchy,\n    !perPositionHeight,\n    ellipsoid\n  );\n\n  if (polygons.length === 0) {\n    return undefined;\n  }\n\n  let geometryInstance;\n  const geometries = [];\n  const minDistance = CesiumMath.chordLength(\n    granularity,\n    ellipsoid.maximumRadius\n  );\n\n  const height = polygonGeometry._height;\n  const extrudedHeight = polygonGeometry._extrudedHeight;\n  const extrude =\n    polygonGeometry._perPositionHeightExtrude ||\n    !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  let offsetValue;\n  let i;\n  if (extrude) {\n    for (i = 0; i < polygons.length; i++) {\n      geometryInstance = createGeometryFromPositionsExtruded(\n        ellipsoid,\n        polygons[i],\n        minDistance,\n        perPositionHeight,\n        arcType\n      );\n      geometryInstance.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n        geometryInstance.geometry,\n        height,\n        extrudedHeight,\n        ellipsoid,\n        perPositionHeight\n      );\n      if (defined(polygonGeometry._offsetAttribute)) {\n        const size =\n          geometryInstance.geometry.attributes.position.values.length / 3;\n        let offsetAttribute = new Uint8Array(size);\n        if (polygonGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n          offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n        } else {\n          offsetValue =\n            polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n              ? 0\n              : 1;\n          offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n        }\n\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute(\n          {\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: offsetAttribute,\n          }\n        );\n      }\n      geometries.push(geometryInstance);\n    }\n  } else {\n    for (i = 0; i < polygons.length; i++) {\n      geometryInstance = createGeometryFromPositions(\n        ellipsoid,\n        polygons[i],\n        minDistance,\n        perPositionHeight,\n        arcType\n      );\n      geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n        geometryInstance.geometry.attributes.position.values,\n        height,\n        ellipsoid,\n        !perPositionHeight\n      );\n\n      if (defined(polygonGeometry._offsetAttribute)) {\n        const length =\n          geometryInstance.geometry.attributes.position.values.length;\n        const applyOffset = new Uint8Array(length / 3);\n        offsetValue =\n          polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        arrayFill(applyOffset, offsetValue);\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute(\n          {\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: applyOffset,\n          }\n        );\n      }\n\n      geometries.push(geometryInstance);\n    }\n  }\n\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\n  const boundingSphere = BoundingSphere.fromVertices(\n    geometry.attributes.position.values\n  );\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: polygonGeometry._offsetAttribute,\n  });\n};\nexport default PolygonOutlineGeometry;\n","import defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport PolygonOutlineGeometry from \"../Core/PolygonOutlineGeometry.js\";\n\nfunction createPolygonOutlineGeometry(polygonGeometry, offset) {\n  if (defined(offset)) {\n    polygonGeometry = PolygonOutlineGeometry.unpack(polygonGeometry, offset);\n  }\n  polygonGeometry._ellipsoid = Ellipsoid.clone(polygonGeometry._ellipsoid);\n  return PolygonOutlineGeometry.createGeometry(polygonGeometry);\n}\nexport default createPolygonOutlineGeometry;\n"],"names":["createGeometryFromPositionsPositions","createGeometryFromPositionsSubdivided","createGeometryFromPositions","ellipsoid","positions","minDistance","perPositionHeight","arcType","positions2D","EllipsoidTangentPlane","fromPoints","projectPointsOntoPlane","subdividedPositions","i","PolygonPipeline","computeWindingOrder2D","WindingOrder","CLOCKWISE","reverse","slice","length","index","Float64Array","p0","p1","x","y","z","numVertices","ArcType","GEODESIC","PolygonGeometryLibrary","subdivideLineCount","RHUMB","subdivideRhumbLineCount","tempPositions","subdivideLine","subdivideRhumbLine","tempPositionsLength","j","indicesSize","indices","IndexDatatype","createTypedArray","GeometryInstance","geometry","Geometry","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","primitiveType","PrimitiveType","LINES","createGeometryFromPositionsExtruded","corners","Array","cornersLength","corner","PolygonOutlineGeometry","options","Check","typeOf","object","polygonHierarchy","defined","height","DeveloperError","defaultValue","Ellipsoid","WGS84","granularity","CesiumMath","RADIANS_PER_DEGREE","perPositionHeightExtrude","extrudedHeight","h","Math","max","min","this","_ellipsoid","clone","_granularity","_height","_extrudedHeight","_arcType","_polygonHierarchy","_perPositionHeight","_perPositionHeightExtrude","_offsetAttribute","offsetAttribute","_workerName","packedLength","computeHierarchyPackedLength","pack","value","array","startingIndex","packPolygonHierarchy","scratchEllipsoid","UNIT_SPHERE","dummyOptions","unpack","result","unpackPolygonHierarchy","undefined","fromPositions","EMPTY_OBJECT","createGeometry","polygonGeometry","polygons","polygonOutlinesFromHierarchy","geometryInstance","geometries","chordLength","maximumRadius","offsetValue","equalsEpsilon","EPSILON2","scaleToGeodeticHeightExtruded","size","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","NONE","applyOffset","UNSIGNED_BYTE","push","scaleToGeodeticHeight","GeometryPipeline","combineInstances","boundingSphere","BoundingSphere","fromVertices","offset"],"mappings":"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"}