define(["./when-4bbc8319","./Matrix2-265d9610","./Transforms-8b90e17c","./ComponentDatatype-aad54330","./RuntimeError-5b082e8f","./GeometryAttribute-4bcb785f","./GeometryAttributes-7827a6c2","./IndexDatatype-6739e544","./WallGeometryLibrary-a5c492d8","./combine-e9466e32","./WebGLConstants-508b9636","./arrayRemoveDuplicates-65de6756","./PolylinePipeline-b9913663","./EllipsoidGeodesic-ed024f16","./EllipsoidRhumbLine-d09d563f","./IntersectionTests-596e31ec","./Plane-616c9c0a"],(function(e,i,t,n,o,r,s,a,l,d,m,u,p,c,f,h,g){"use strict";const y=new i.Cartesian3,E=new i.Cartesian3;function w(t){const r=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions,s=t.maximumHeights,a=t.minimumHeights;if(!e.defined(r))throw new o.DeveloperError("options.positions is required.");if(e.defined(s)&&s.length!==r.length)throw new o.DeveloperError("options.positions and options.maximumHeights must have the same length.");if(e.defined(a)&&a.length!==r.length)throw new o.DeveloperError("options.positions and options.minimumHeights must have the same length.");const l=e.defaultValue(t.granularity,n.CesiumMath.RADIANS_PER_DEGREE),d=e.defaultValue(t.ellipsoid,i.Ellipsoid.WGS84);this._positions=r,this._minimumHeights=a,this._maximumHeights=s,this._granularity=l,this._ellipsoid=i.Ellipsoid.clone(d),this._workerName="createWallOutlineGeometry";let m=1+r.length*i.Cartesian3.packedLength+2;e.defined(a)&&(m+=a.length),e.defined(s)&&(m+=s.length),this.packedLength=m+i.Ellipsoid.packedLength+1}w.pack=function(t,n,r){if(!e.defined(t))throw new o.DeveloperError("value is required");if(!e.defined(n))throw new o.DeveloperError("array is required");let s;r=e.defaultValue(r,0);const a=t._positions;let l=a.length;for(n[r++]=l,s=0;s<l;++s,r+=i.Cartesian3.packedLength)i.Cartesian3.pack(a[s],n,r);const d=t._minimumHeights;if(l=e.defined(d)?d.length:0,n[r++]=l,e.defined(d))for(s=0;s<l;++s)n[r++]=d[s];const m=t._maximumHeights;if(l=e.defined(m)?m.length:0,n[r++]=l,e.defined(m))for(s=0;s<l;++s)n[r++]=m[s];return i.Ellipsoid.pack(t._ellipsoid,n,r),n[r+=i.Ellipsoid.packedLength]=t._granularity,n};const _=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),H={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:_,granularity:void 0};return w.unpack=function(t,n,r){if(!e.defined(t))throw new o.DeveloperError("array is required");let s;n=e.defaultValue(n,0);let a=t[n++];const l=new Array(a);for(s=0;s<a;++s,n+=i.Cartesian3.packedLength)l[s]=i.Cartesian3.unpack(t,n);let d,m;if(a=t[n++],a>0)for(d=new Array(a),s=0;s<a;++s)d[s]=t[n++];if(a=t[n++],a>0)for(m=new Array(a),s=0;s<a;++s)m[s]=t[n++];const u=i.Ellipsoid.unpack(t,n,_),p=t[n+=i.Ellipsoid.packedLength];return e.defined(r)?(r._positions=l,r._minimumHeights=d,r._maximumHeights=m,r._ellipsoid=i.Ellipsoid.clone(u,r._ellipsoid),r._granularity=p,r):(H.positions=l,H.minimumHeights=d,H.maximumHeights=m,H.granularity=p,new w(H))},w.fromConstantHeights=function(i){const t=(i=e.defaultValue(i,e.defaultValue.EMPTY_OBJECT)).positions;if(!e.defined(t))throw new o.DeveloperError("options.positions is required.");let n,r;const s=i.minimumHeight,a=i.maximumHeight,l=e.defined(s),d=e.defined(a);if(l||d){const e=t.length;n=l?new Array(e):void 0,r=d?new Array(e):void 0;for(let i=0;i<e;++i)l&&(n[i]=s),d&&(r[i]=a)}return new w({positions:t,maximumHeights:r,minimumHeights:n,ellipsoid:i.ellipsoid})},w.createGeometry=function(o){const d=o._positions,m=o._minimumHeights,u=o._maximumHeights,p=o._granularity,c=o._ellipsoid,f=l.WallGeometryLibrary.computePositions(c,d,u,m,p,!1);if(!e.defined(f))return;const h=f.bottomPositions,g=f.topPositions;let w=g.length,_=2*w;const H=new Float64Array(_);let b,v=0;for(w/=3,b=0;b<w;++b){const e=3*b,t=i.Cartesian3.fromArray(g,e,y),n=i.Cartesian3.fromArray(h,e,E);H[v++]=n.x,H[v++]=n.y,H[v++]=n.z,H[v++]=t.x,H[v++]=t.y,H[v++]=t.z}const C=new s.GeometryAttributes({position:new r.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:H})}),A=_/3;_=2*A-4+A;const D=a.IndexDatatype.createTypedArray(A,_);let k=0;for(b=0;b<A-2;b+=2){const e=b,t=b+2,o=i.Cartesian3.fromArray(H,3*e,y),r=i.Cartesian3.fromArray(H,3*t,E);if(i.Cartesian3.equalsEpsilon(o,r,n.CesiumMath.EPSILON10))continue;const s=b+1,a=b+3;D[k++]=s,D[k++]=e,D[k++]=s,D[k++]=a,D[k++]=e,D[k++]=t}return D[k++]=A-2,D[k++]=A-1,new r.Geometry({attributes:C,indices:D,primitiveType:r.PrimitiveType.LINES,boundingSphere:new t.BoundingSphere.fromVertices(H)})},function(t,n){return e.defined(n)&&(t=w.unpack(t,n)),t._ellipsoid=i.Ellipsoid.clone(t._ellipsoid),w.createGeometry(t)}}));
//# sourceMappingURL=createWallOutlineGeometry.js.map
