define(["exports","./Matrix2-265d9610","./RuntimeError-5b082e8f","./when-4bbc8319","./WebGLConstants-508b9636","./Transforms-8b90e17c"],(function(t,e,r,n,i,o){"use strict";var a=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3});const s={POINTS:i.WebGLConstants.POINTS,LINES:i.WebGLConstants.LINES,LINE_LOOP:i.WebGLConstants.LINE_LOOP,LINE_STRIP:i.WebGLConstants.LINE_STRIP,TRIANGLES:i.WebGLConstants.TRIANGLES,TRIANGLE_STRIP:i.WebGLConstants.TRIANGLE_STRIP,TRIANGLE_FAN:i.WebGLConstants.TRIANGLE_FAN,validate:function(t){return t===s.POINTS||t===s.LINES||t===s.LINE_LOOP||t===s.LINE_STRIP||t===s.TRIANGLES||t===s.TRIANGLE_STRIP||t===s.TRIANGLE_FAN}};var u=Object.freeze(s);function p(t){t=n.defaultValue(t,n.defaultValue.EMPTY_OBJECT),r.Check.typeOf.object("options.attributes",t.attributes),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=n.defaultValue(t.primitiveType,u.TRIANGLES),this.boundingSphere=t.boundingSphere,this.geometryType=n.defaultValue(t.geometryType,a.NONE),this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}p.computeNumberOfVertices=function(t){r.Check.typeOf.object("geometry",t);let e=-1;for(const i in t.attributes)if(t.attributes.hasOwnProperty(i)&&n.defined(t.attributes[i])&&n.defined(t.attributes[i].values)){const n=t.attributes[i],o=n.values.length/n.componentsPerAttribute;if(e!==o&&-1!==e)throw new r.DeveloperError("All attribute lists must have the same number of attributes.");e=o}return e};const c=new e.Cartographic,l=new e.Cartesian3,b=new e.Matrix4,I=[new e.Cartographic,new e.Cartographic,new e.Cartographic],N=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],m=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],f=new e.Cartesian3,h=new o.Quaternion,T=new e.Matrix4,y=new e.Matrix2;p._textureCoordinateRotationPoints=function(t,r,n,i){let a;const s=e.Rectangle.center(i,c),u=e.Cartographic.toCartesian(s,n,l),p=o.Transforms.eastNorthUpToFixedFrame(u,n,b),E=e.Matrix4.inverse(p,b),d=N,C=I;C[0].longitude=i.west,C[0].latitude=i.south,C[1].longitude=i.west,C[1].latitude=i.north,C[2].longitude=i.east,C[2].latitude=i.south;let L=f;for(a=0;a<3;a++)e.Cartographic.toCartesian(C[a],n,L),L=e.Matrix4.multiplyByPointAsVector(E,L,L),d[a].x=L.x,d[a].y=L.y;const A=o.Quaternion.fromAxisAngle(e.Cartesian3.UNIT_Z,-r,h),w=e.Matrix3.fromQuaternion(A,T),P=t.length;let x=Number.POSITIVE_INFINITY,S=Number.POSITIVE_INFINITY,G=Number.NEGATIVE_INFINITY,O=Number.NEGATIVE_INFINITY;for(a=0;a<P;a++)L=e.Matrix4.multiplyByPointAsVector(E,t[a],L),L=e.Matrix3.multiplyByVector(w,L,L),x=Math.min(x,L.x),S=Math.min(S,L.y),G=Math.max(G,L.x),O=Math.max(O,L.y);const R=e.Matrix2.fromRotation(r,y),g=m;g[0].x=x,g[0].y=S,g[1].x=x,g[1].y=O,g[2].x=G,g[2].y=S;const _=d[0],v=d[2].x-_.x,V=d[1].y-_.y;for(a=0;a<3;a++){const t=g[a];e.Matrix2.multiplyByVector(R,t,t),t.x=(t.x-_.x)/v,t.y=(t.y-_.y)/V}const M=g[0],D=g[1],F=g[2],W=new Array(6);return e.Cartesian2.pack(M,W),e.Cartesian2.pack(D,W,2),e.Cartesian2.pack(F,W,4),W},t.Geometry=p,t.GeometryAttribute=function(t){if(t=n.defaultValue(t,n.defaultValue.EMPTY_OBJECT),!n.defined(t.componentDatatype))throw new r.DeveloperError("options.componentDatatype is required.");if(!n.defined(t.componentsPerAttribute))throw new r.DeveloperError("options.componentsPerAttribute is required.");if(t.componentsPerAttribute<1||t.componentsPerAttribute>4)throw new r.DeveloperError("options.componentsPerAttribute must be between 1 and 4.");if(!n.defined(t.values))throw new r.DeveloperError("options.values is required.");this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=n.defaultValue(t.normalize,!1),this.values=t.values},t.GeometryType=a,t.PrimitiveType=u}));
//# sourceMappingURL=GeometryAttribute-4bcb785f.js.map
