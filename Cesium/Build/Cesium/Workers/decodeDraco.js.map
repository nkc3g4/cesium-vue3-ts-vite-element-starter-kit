{"version":3,"file":"decodeDraco.js","sources":["../../../../Source/WorkersES6/decodeDraco.js"],"sourcesContent":["/* global require */\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\n\nlet draco;\n\nfunction decodeIndexArray(dracoGeometry, dracoDecoder) {\n  const numPoints = dracoGeometry.num_points();\n  const numFaces = dracoGeometry.num_faces();\n  const faceIndices = new draco.DracoInt32Array();\n  const numIndices = numFaces * 3;\n  const indexArray = IndexDatatype.createTypedArray(numPoints, numIndices);\n\n  let offset = 0;\n  for (let i = 0; i < numFaces; ++i) {\n    dracoDecoder.GetFaceFromMesh(dracoGeometry, i, faceIndices);\n\n    indexArray[offset + 0] = faceIndices.GetValue(0);\n    indexArray[offset + 1] = faceIndices.GetValue(1);\n    indexArray[offset + 2] = faceIndices.GetValue(2);\n    offset += 3;\n  }\n\n  draco.destroy(faceIndices);\n\n  return {\n    typedArray: indexArray,\n    numberOfIndices: numIndices,\n  };\n}\n\nfunction decodeQuantizedDracoTypedArray(\n  dracoGeometry,\n  dracoDecoder,\n  dracoAttribute,\n  quantization,\n  vertexArrayLength\n) {\n  let vertexArray;\n  let attributeData;\n  if (quantization.quantizationBits <= 8) {\n    attributeData = new draco.DracoUInt8Array();\n    vertexArray = new Uint8Array(vertexArrayLength);\n    dracoDecoder.GetAttributeUInt8ForAllPoints(\n      dracoGeometry,\n      dracoAttribute,\n      attributeData\n    );\n  } else {\n    attributeData = new draco.DracoUInt16Array();\n    vertexArray = new Uint16Array(vertexArrayLength);\n    dracoDecoder.GetAttributeUInt16ForAllPoints(\n      dracoGeometry,\n      dracoAttribute,\n      attributeData\n    );\n  }\n\n  for (let i = 0; i < vertexArrayLength; ++i) {\n    vertexArray[i] = attributeData.GetValue(i);\n  }\n\n  draco.destroy(attributeData);\n  return vertexArray;\n}\n\nfunction decodeDracoTypedArray(\n  dracoGeometry,\n  dracoDecoder,\n  dracoAttribute,\n  vertexArrayLength\n) {\n  let vertexArray;\n  let attributeData;\n\n  // Some attribute types are casted down to 32 bit since Draco only returns 32 bit values\n  switch (dracoAttribute.data_type()) {\n    case 1:\n    case 11: // DT_INT8 or DT_BOOL\n      attributeData = new draco.DracoInt8Array();\n      vertexArray = new Int8Array(vertexArrayLength);\n      dracoDecoder.GetAttributeInt8ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 2: // DT_UINT8\n      attributeData = new draco.DracoUInt8Array();\n      vertexArray = new Uint8Array(vertexArrayLength);\n      dracoDecoder.GetAttributeUInt8ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 3: // DT_INT16\n      attributeData = new draco.DracoInt16Array();\n      vertexArray = new Int16Array(vertexArrayLength);\n      dracoDecoder.GetAttributeInt16ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 4: // DT_UINT16\n      attributeData = new draco.DracoUInt16Array();\n      vertexArray = new Uint16Array(vertexArrayLength);\n      dracoDecoder.GetAttributeUInt16ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 5:\n    case 7: // DT_INT32 or DT_INT64\n      attributeData = new draco.DracoInt32Array();\n      vertexArray = new Int32Array(vertexArrayLength);\n      dracoDecoder.GetAttributeInt32ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 6:\n    case 8: // DT_UINT32 or DT_UINT64\n      attributeData = new draco.DracoUInt32Array();\n      vertexArray = new Uint32Array(vertexArrayLength);\n      dracoDecoder.GetAttributeUInt32ForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n    case 9:\n    case 10: // DT_FLOAT32 or DT_FLOAT64\n      attributeData = new draco.DracoFloat32Array();\n      vertexArray = new Float32Array(vertexArrayLength);\n      dracoDecoder.GetAttributeFloatForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        attributeData\n      );\n      break;\n  }\n\n  for (let i = 0; i < vertexArrayLength; ++i) {\n    vertexArray[i] = attributeData.GetValue(i);\n  }\n\n  draco.destroy(attributeData);\n  return vertexArray;\n}\n\nfunction decodeAttribute(dracoGeometry, dracoDecoder, dracoAttribute) {\n  const numPoints = dracoGeometry.num_points();\n  const numComponents = dracoAttribute.num_components();\n\n  let quantization;\n  let transform = new draco.AttributeQuantizationTransform();\n  if (transform.InitFromAttribute(dracoAttribute)) {\n    const minValues = new Array(numComponents);\n    for (let i = 0; i < numComponents; ++i) {\n      minValues[i] = transform.min_value(i);\n    }\n    quantization = {\n      quantizationBits: transform.quantization_bits(),\n      minValues: minValues,\n      range: transform.range(),\n      octEncoded: false,\n    };\n  }\n  draco.destroy(transform);\n\n  transform = new draco.AttributeOctahedronTransform();\n  if (transform.InitFromAttribute(dracoAttribute)) {\n    quantization = {\n      quantizationBits: transform.quantization_bits(),\n      octEncoded: true,\n    };\n  }\n  draco.destroy(transform);\n\n  const vertexArrayLength = numPoints * numComponents;\n  let vertexArray;\n  if (defined(quantization)) {\n    vertexArray = decodeQuantizedDracoTypedArray(\n      dracoGeometry,\n      dracoDecoder,\n      dracoAttribute,\n      quantization,\n      vertexArrayLength\n    );\n  } else {\n    vertexArray = decodeDracoTypedArray(\n      dracoGeometry,\n      dracoDecoder,\n      dracoAttribute,\n      vertexArrayLength\n    );\n  }\n\n  const componentDatatype = ComponentDatatype.fromTypedArray(vertexArray);\n\n  return {\n    array: vertexArray,\n    data: {\n      componentsPerAttribute: numComponents,\n      componentDatatype: componentDatatype,\n      byteOffset: dracoAttribute.byte_offset(),\n      byteStride:\n        ComponentDatatype.getSizeInBytes(componentDatatype) * numComponents,\n      normalized: dracoAttribute.normalized(),\n      quantization: quantization,\n    },\n  };\n}\n\nfunction decodePointCloud(parameters) {\n  const dracoDecoder = new draco.Decoder();\n\n  if (parameters.dequantizeInShader) {\n    dracoDecoder.SkipAttributeTransform(draco.POSITION);\n    dracoDecoder.SkipAttributeTransform(draco.NORMAL);\n  }\n\n  const buffer = new draco.DecoderBuffer();\n  buffer.Init(parameters.buffer, parameters.buffer.length);\n\n  const geometryType = dracoDecoder.GetEncodedGeometryType(buffer);\n  if (geometryType !== draco.POINT_CLOUD) {\n    throw new RuntimeError(\"Draco geometry type must be POINT_CLOUD.\");\n  }\n\n  const dracoPointCloud = new draco.PointCloud();\n  const decodingStatus = dracoDecoder.DecodeBufferToPointCloud(\n    buffer,\n    dracoPointCloud\n  );\n  if (!decodingStatus.ok() || dracoPointCloud.ptr === 0) {\n    throw new RuntimeError(\n      `Error decoding draco point cloud: ${decodingStatus.error_msg()}`\n    );\n  }\n\n  draco.destroy(buffer);\n\n  const result = {};\n\n  const properties = parameters.properties;\n  for (const propertyName in properties) {\n    if (properties.hasOwnProperty(propertyName)) {\n      let dracoAttribute;\n      if (propertyName === \"POSITION\" || propertyName === \"NORMAL\") {\n        const dracoAttributeId = dracoDecoder.GetAttributeId(\n          dracoPointCloud,\n          draco[propertyName]\n        );\n        dracoAttribute = dracoDecoder.GetAttribute(\n          dracoPointCloud,\n          dracoAttributeId\n        );\n      } else {\n        const attributeId = properties[propertyName];\n        dracoAttribute = dracoDecoder.GetAttributeByUniqueId(\n          dracoPointCloud,\n          attributeId\n        );\n      }\n      result[propertyName] = decodeAttribute(\n        dracoPointCloud,\n        dracoDecoder,\n        dracoAttribute\n      );\n    }\n  }\n\n  draco.destroy(dracoPointCloud);\n  draco.destroy(dracoDecoder);\n\n  return result;\n}\n\nfunction decodePrimitive(parameters) {\n  const dracoDecoder = new draco.Decoder();\n\n  // Skip all parameter types except generic\n  const attributesToSkip = [\"POSITION\", \"NORMAL\", \"COLOR\", \"TEX_COORD\"];\n  if (parameters.dequantizeInShader) {\n    for (let i = 0; i < attributesToSkip.length; ++i) {\n      dracoDecoder.SkipAttributeTransform(draco[attributesToSkip[i]]);\n    }\n  }\n\n  const bufferView = parameters.bufferView;\n  const buffer = new draco.DecoderBuffer();\n  buffer.Init(parameters.array, bufferView.byteLength);\n\n  const geometryType = dracoDecoder.GetEncodedGeometryType(buffer);\n  if (geometryType !== draco.TRIANGULAR_MESH) {\n    throw new RuntimeError(\"Unsupported draco mesh geometry type.\");\n  }\n\n  const dracoGeometry = new draco.Mesh();\n  const decodingStatus = dracoDecoder.DecodeBufferToMesh(buffer, dracoGeometry);\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new RuntimeError(\n      `Error decoding draco mesh geometry: ${decodingStatus.error_msg()}`\n    );\n  }\n\n  draco.destroy(buffer);\n\n  const attributeData = {};\n\n  const compressedAttributes = parameters.compressedAttributes;\n  for (const attributeName in compressedAttributes) {\n    if (compressedAttributes.hasOwnProperty(attributeName)) {\n      const compressedAttribute = compressedAttributes[attributeName];\n      const dracoAttribute = dracoDecoder.GetAttributeByUniqueId(\n        dracoGeometry,\n        compressedAttribute\n      );\n      attributeData[attributeName] = decodeAttribute(\n        dracoGeometry,\n        dracoDecoder,\n        dracoAttribute\n      );\n    }\n  }\n\n  const result = {\n    indexArray: decodeIndexArray(dracoGeometry, dracoDecoder),\n    attributeData: attributeData,\n  };\n\n  draco.destroy(dracoGeometry);\n  draco.destroy(dracoDecoder);\n\n  return result;\n}\n\nfunction decode(parameters) {\n  if (defined(parameters.bufferView)) {\n    return decodePrimitive(parameters);\n  }\n  return decodePointCloud(parameters);\n}\n\nfunction initWorker(dracoModule) {\n  draco = dracoModule;\n  self.onmessage = createTaskProcessorWorker(decode);\n  self.postMessage(true);\n}\n\nfunction decodeDraco(event) {\n  const data = event.data;\n\n  // Expect the first message to be to load a web assembly module\n  const wasmConfig = data.webAssemblyConfig;\n  if (defined(wasmConfig)) {\n    // Require and compile WebAssembly module, or use fallback if not supported\n    return require([wasmConfig.modulePath], function (dracoModule) {\n      if (defined(wasmConfig.wasmBinaryFile)) {\n        if (!defined(dracoModule)) {\n          dracoModule = self.DracoDecoderModule;\n        }\n\n        dracoModule(wasmConfig).then(function (compiledModule) {\n          initWorker(compiledModule);\n        });\n      } else {\n        initWorker(dracoModule());\n      }\n    });\n  }\n}\nexport default decodeDraco;\n"],"names":["draco","decodeIndexArray","dracoGeometry","dracoDecoder","numPoints","num_points","numFaces","num_faces","faceIndices","DracoInt32Array","numIndices","indexArray","IndexDatatype","createTypedArray","offset","i","GetFaceFromMesh","GetValue","destroy","typedArray","numberOfIndices","decodeAttribute","dracoAttribute","numComponents","num_components","quantization","transform","AttributeQuantizationTransform","InitFromAttribute","minValues","Array","min_value","quantizationBits","quantization_bits","range","octEncoded","AttributeOctahedronTransform","vertexArrayLength","vertexArray","defined","attributeData","DracoUInt8Array","Uint8Array","GetAttributeUInt8ForAllPoints","DracoUInt16Array","Uint16Array","GetAttributeUInt16ForAllPoints","decodeQuantizedDracoTypedArray","data_type","DracoInt8Array","Int8Array","GetAttributeInt8ForAllPoints","DracoInt16Array","Int16Array","GetAttributeInt16ForAllPoints","Int32Array","GetAttributeInt32ForAllPoints","DracoUInt32Array","Uint32Array","GetAttributeUInt32ForAllPoints","DracoFloat32Array","Float32Array","GetAttributeFloatForAllPoints","decodeDracoTypedArray","componentDatatype","ComponentDatatype","fromTypedArray","array","data","componentsPerAttribute","byteOffset","byte_offset","byteStride","getSizeInBytes","normalized","decode","parameters","bufferView","Decoder","attributesToSkip","dequantizeInShader","length","SkipAttributeTransform","buffer","DecoderBuffer","Init","byteLength","GetEncodedGeometryType","TRIANGULAR_MESH","RuntimeError","Mesh","decodingStatus","DecodeBufferToMesh","ok","ptr","error_msg","compressedAttributes","attributeName","hasOwnProperty","compressedAttribute","GetAttributeByUniqueId","result","decodePrimitive","POSITION","NORMAL","POINT_CLOUD","dracoPointCloud","PointCloud","DecodeBufferToPointCloud","properties","propertyName","dracoAttributeId","GetAttributeId","GetAttribute","attributeId","decodePointCloud","initWorker","dracoModule","self","onmessage","createTaskProcessorWorker","postMessage","event","wasmConfig","webAssemblyConfig","require","modulePath","wasmBinaryFile","DracoDecoderModule","then","compiledModule"],"mappings":"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"}