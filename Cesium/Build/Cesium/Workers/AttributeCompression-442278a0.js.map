{"version":3,"file":"AttributeCompression-442278a0.js","sources":["../../../../Source/Scene/AttributeType.js","../../../../Source/Core/AttributeCompression.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix2 from \"../Core/Matrix2.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\n\n/**\n * An enum describing the attribute type for glTF and 3D Tiles.\n *\n * @enum {String}\n *\n * @private\n */\nconst AttributeType = {\n  /**\n   * The attribute is a single component.\n   *\n   * @type {String}\n   * @constant\n   */\n  SCALAR: \"SCALAR\",\n\n  /**\n   * The attribute is a two-component vector.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC2: \"VEC2\",\n\n  /**\n   * The attribute is a three-component vector.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC3: \"VEC3\",\n\n  /**\n   * The attribute is a four-component vector.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC4: \"VEC4\",\n\n  /**\n   * The attribute is a 2x2 matrix.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT2: \"MAT2\",\n\n  /**\n   * The attribute is a 3x3 matrix.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT3: \"MAT3\",\n\n  /**\n   * The attribute is a 4x4 matrix.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT4: \"MAT4\",\n};\n\n/**\n * Gets the scalar, vector, or matrix type for the attribute type.\n *\n * @param {AttributeType} attributeType The attribute type.\n * @returns {*} The math type.\n *\n * @private\n */\nAttributeType.getMathType = function (attributeType) {\n  switch (attributeType) {\n    case AttributeType.SCALAR:\n      return Number;\n    case AttributeType.VEC2:\n      return Cartesian2;\n    case AttributeType.VEC3:\n      return Cartesian3;\n    case AttributeType.VEC4:\n      return Cartesian4;\n    case AttributeType.MAT2:\n      return Matrix2;\n    case AttributeType.MAT3:\n      return Matrix3;\n    case AttributeType.MAT4:\n      return Matrix4;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"attributeType is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Gets the number of components per attribute.\n *\n * @param {AttributeType} attributeType The attribute type.\n * @returns {Number} The number of components.\n *\n * @private\n */\nAttributeType.getNumberOfComponents = function (attributeType) {\n  switch (attributeType) {\n    case AttributeType.SCALAR:\n      return 1;\n    case AttributeType.VEC2:\n      return 2;\n    case AttributeType.VEC3:\n      return 3;\n    case AttributeType.VEC4:\n    case AttributeType.MAT2:\n      return 4;\n    case AttributeType.MAT3:\n      return 9;\n    case AttributeType.MAT4:\n      return 16;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"attributeType is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Gets the GLSL type for the attribute type.\n *\n * @param {AttributeType} attributeType The attribute type.\n * @returns {String} The GLSL type for the attribute type.\n *\n * @private\n */\nAttributeType.getGlslType = function (attributeType) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"attributeType\", attributeType);\n  //>>includeEnd('debug');\n\n  switch (attributeType) {\n    case AttributeType.SCALAR:\n      return \"float\";\n    case AttributeType.VEC2:\n      return \"vec2\";\n    case AttributeType.VEC3:\n      return \"vec3\";\n    case AttributeType.VEC4:\n      return \"vec4\";\n    case AttributeType.MAT2:\n      return \"mat2\";\n    case AttributeType.MAT3:\n      return \"mat3\";\n    case AttributeType.MAT4:\n      return \"mat4\";\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"attributeType is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\nexport default Object.freeze(AttributeType);\n","import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport AttributeType from \"../Scene/AttributeType.js\";\n\nconst RIGHT_SHIFT = 1.0 / 256.0;\nconst LEFT_SHIFT = 256.0;\n\n/**\n * Attribute compression and decompression functions.\n *\n * @namespace AttributeCompression\n *\n * @private\n */\nconst AttributeCompression = {};\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the 'oct' encoding.\n *\n * Oct encoding is a compact representation of unit length vectors.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 component 'oct' encoding.\n * @param {Cartesian2} result The 2 component oct-encoded unit length vector.\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @returns {Cartesian2} The 2 component oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octDecodeInRange\n */\nAttributeCompression.octEncodeInRange = function (vector, rangeMax, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"vector\", vector);\n  Check.defined(\"result\", result);\n  const magSquared = Cartesian3.magnitudeSquared(vector);\n  if (Math.abs(magSquared - 1.0) > CesiumMath.EPSILON6) {\n    throw new DeveloperError(\"vector must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  result.x =\n    vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  result.y =\n    vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  if (vector.z < 0) {\n    const x = result.x;\n    const y = result.y;\n    result.x = (1.0 - Math.abs(y)) * CesiumMath.signNotZero(x);\n    result.y = (1.0 - Math.abs(x)) * CesiumMath.signNotZero(y);\n  }\n\n  result.x = CesiumMath.toSNorm(result.x, rangeMax);\n  result.y = CesiumMath.toSNorm(result.y, rangeMax);\n\n  return result;\n};\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @param {Cartesian2} result The 2 byte oct-encoded unit length vector.\n * @returns {Cartesian2} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecode\n */\nAttributeCompression.octEncode = function (vector, result) {\n  return AttributeCompression.octEncodeInRange(vector, 255, result);\n};\n\nconst octEncodeScratch = new Cartesian2();\nconst uint8ForceArray = new Uint8Array(1);\nfunction forceUint8(value) {\n  uint8ForceArray[0] = value;\n  return uint8ForceArray[0];\n}\n/**\n * @param {Cartesian3} vector The normalized vector to be compressed into 4 byte 'oct' encoding.\n * @param {Cartesian4} result The 4 byte oct-encoded unit length vector.\n * @returns {Cartesian4} The 4 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecodeFromCartesian4\n */\nAttributeCompression.octEncodeToCartesian4 = function (vector, result) {\n  AttributeCompression.octEncodeInRange(vector, 65535, octEncodeScratch);\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n  result.y = forceUint8(octEncodeScratch.x);\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n  result.w = forceUint8(octEncodeScratch.y);\n  return result;\n};\n\n/**\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Number} x The x component of the oct-encoded unit length vector.\n * @param {Number} y The y component of the oct-encoded unit length vector.\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be unsigned normalized integers between 0 and rangeMax.\n *\n * @see AttributeCompression.octEncodeInRange\n */\nAttributeCompression.octDecodeInRange = function (x, y, rangeMax, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"result\", result);\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new DeveloperError(\n      `x and y must be unsigned normalized integers between 0 and ${rangeMax}`\n    );\n  }\n  //>>includeEnd('debug');\n\n  result.x = CesiumMath.fromSNorm(x, rangeMax);\n  result.y = CesiumMath.fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n\n  if (result.z < 0.0) {\n    const oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * CesiumMath.signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * CesiumMath.signNotZero(result.y);\n  }\n\n  return Cartesian3.normalize(result, result);\n};\n\n/**\n * Decodes a unit-length vector in 2 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Number} x The x component of the oct-encoded unit length vector.\n * @param {Number} y The y component of the oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be an unsigned normalized integer between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n */\nAttributeCompression.octDecode = function (x, y, result) {\n  return AttributeCompression.octDecodeInRange(x, y, 255, result);\n};\n\n/**\n * Decodes a unit-length vector in 4 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Cartesian4} encoded The oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x, y, z, and w must be unsigned normalized integers between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n * @see AttributeCompression.octEncodeToCartesian4\n */\nAttributeCompression.octDecodeFromCartesian4 = function (encoded, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"encoded\", encoded);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n  const x = encoded.x;\n  const y = encoded.y;\n  const z = encoded.z;\n  const w = encoded.w;\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    x < 0 ||\n    x > 255 ||\n    y < 0 ||\n    y > 255 ||\n    z < 0 ||\n    z > 255 ||\n    w < 0 ||\n    w > 255\n  ) {\n    throw new DeveloperError(\n      \"x, y, z, and w must be unsigned normalized integers between 0 and 255\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const xOct16 = x * LEFT_SHIFT + y;\n  const yOct16 = z * LEFT_SHIFT + w;\n  return AttributeCompression.octDecodeInRange(xOct16, yOct16, 65535, result);\n};\n\n/**\n * Packs an oct encoded vector into a single floating-point number.\n *\n * @param {Cartesian2} encoded The oct encoded vector.\n * @returns {Number} The oct encoded vector packed into a single float.\n *\n */\nAttributeCompression.octPackFloat = function (encoded) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"encoded\", encoded);\n  //>>includeEnd('debug');\n  return 256.0 * encoded.x + encoded.y;\n};\n\nconst scratchEncodeCart2 = new Cartesian2();\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and\n * stores those values in a single float-point number.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @returns {Number} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n */\nAttributeCompression.octEncodeFloat = function (vector) {\n  AttributeCompression.octEncode(vector, scratchEncodeCart2);\n  return AttributeCompression.octPackFloat(scratchEncodeCart2);\n};\n\n/**\n * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.\n *\n * @param {Number} value The oct-encoded unit length vector stored as a single floating-point number.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n */\nAttributeCompression.octDecodeFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  //>>includeEnd('debug');\n\n  const temp = value / 256.0;\n  const x = Math.floor(temp);\n  const y = (temp - x) * 256.0;\n\n  return AttributeCompression.octDecode(x, y, result);\n};\n\n/**\n * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and\n * packs those into two floating-point numbers.\n *\n * @param {Cartesian3} v1 A normalized vector to be compressed.\n * @param {Cartesian3} v2 A normalized vector to be compressed.\n * @param {Cartesian3} v3 A normalized vector to be compressed.\n * @param {Cartesian2} result The 'oct' encoded vectors packed into two floating-point numbers.\n * @returns {Cartesian2} The 'oct' encoded vectors packed into two floating-point numbers.\n *\n */\nAttributeCompression.octPack = function (v1, v2, v3, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"v1\", v1);\n  Check.defined(\"v2\", v2);\n  Check.defined(\"v3\", v3);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const encoded1 = AttributeCompression.octEncodeFloat(v1);\n  const encoded2 = AttributeCompression.octEncodeFloat(v2);\n\n  const encoded3 = AttributeCompression.octEncode(v3, scratchEncodeCart2);\n  result.x = 65536.0 * encoded3.x + encoded1;\n  result.y = 65536.0 * encoded3.y + encoded2;\n  return result;\n};\n\n/**\n * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.\n *\n * @param {Cartesian2} packed The three oct-encoded unit length vectors stored as two floating-point number.\n * @param {Cartesian3} v1 One decoded and normalized vector.\n * @param {Cartesian3} v2 One decoded and normalized vector.\n * @param {Cartesian3} v3 One decoded and normalized vector.\n */\nAttributeCompression.octUnpack = function (packed, v1, v2, v3) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"packed\", packed);\n  Check.defined(\"v1\", v1);\n  Check.defined(\"v2\", v2);\n  Check.defined(\"v3\", v3);\n  //>>includeEnd('debug');\n\n  let temp = packed.x / 65536.0;\n  const x = Math.floor(temp);\n  const encodedFloat1 = (temp - x) * 65536.0;\n\n  temp = packed.y / 65536.0;\n  const y = Math.floor(temp);\n  const encodedFloat2 = (temp - y) * 65536.0;\n\n  AttributeCompression.octDecodeFloat(encodedFloat1, v1);\n  AttributeCompression.octDecodeFloat(encodedFloat2, v2);\n  AttributeCompression.octDecode(x, y, v3);\n};\n\n/**\n * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\n *\n * @param {Cartesian2} textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.\n * @returns {Number} The packed texture coordinates.\n *\n */\nAttributeCompression.compressTextureCoordinates = function (\n  textureCoordinates\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"textureCoordinates\", textureCoordinates);\n  //>>includeEnd('debug');\n\n  // Move x and y to the range 0-4095;\n  const x = (textureCoordinates.x * 4095.0) | 0;\n  const y = (textureCoordinates.y * 4095.0) | 0;\n  return 4096.0 * x + y;\n};\n\n/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @param {Number} compressed The compressed texture coordinates.\n * @param {Cartesian2} result The decompressed texture coordinates.\n * @returns {Cartesian2} The modified result parameter.\n *\n */\nAttributeCompression.decompressTextureCoordinates = function (\n  compressed,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"compressed\", compressed);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const temp = compressed / 4096.0;\n  const xZeroTo4095 = Math.floor(temp);\n  result.x = xZeroTo4095 / 4095.0;\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n  return result;\n};\n\nfunction zigZagDecode(value) {\n  return (value >> 1) ^ -(value & 1);\n}\n\n/**\n * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\n *\n * @param {Uint16Array} uBuffer The buffer view of u values.\n * @param {Uint16Array} vBuffer The buffer view of v values.\n * @param {Uint16Array} [heightBuffer] The buffer view of height values.\n *\n * @see {@link https://github.com/CesiumGS/quantized-mesh|quantized-mesh-1.0 terrain format}\n */\nAttributeCompression.zigZagDeltaDecode = function (\n  uBuffer,\n  vBuffer,\n  heightBuffer\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"uBuffer\", uBuffer);\n  Check.defined(\"vBuffer\", vBuffer);\n  Check.typeOf.number.equals(\n    \"uBuffer.length\",\n    \"vBuffer.length\",\n    uBuffer.length,\n    vBuffer.length\n  );\n  if (defined(heightBuffer)) {\n    Check.typeOf.number.equals(\n      \"uBuffer.length\",\n      \"heightBuffer.length\",\n      uBuffer.length,\n      heightBuffer.length\n    );\n  }\n  //>>includeEnd('debug');\n\n  const count = uBuffer.length;\n\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < count; ++i) {\n    u += zigZagDecode(uBuffer[i]);\n    v += zigZagDecode(vBuffer[i]);\n\n    uBuffer[i] = u;\n    vBuffer[i] = v;\n\n    if (defined(heightBuffer)) {\n      height += zigZagDecode(heightBuffer[i]);\n      heightBuffer[i] = height;\n    }\n  }\n};\n\n/**\n * Dequantizes a quantized typed array into a floating point typed array.\n *\n * @see {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data}\n *\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array} typedArray The typed array for the quantized data.\n * @param {ComponentDatatype} componentDatatype The component datatype of the quantized data.\n * @param {AttributeType} type The attribute type of the quantized data.\n * @param {Number} count The number of attributes referenced in the dequantized array.\n *\n * @returns {Float32Array} The dequantized array.\n */\nAttributeCompression.dequantize = function (\n  typedArray,\n  componentDatatype,\n  type,\n  count\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"typedArray\", typedArray);\n  Check.defined(\"componentDatatype\", componentDatatype);\n  Check.defined(\"type\", type);\n  Check.defined(\"count\", count);\n  //>>includeEnd('debug');\n\n  const componentsPerAttribute = AttributeType.getNumberOfComponents(type);\n\n  let divisor;\n  switch (componentDatatype) {\n    case ComponentDatatype.BYTE:\n      divisor = 127.0;\n      break;\n    case ComponentDatatype.UNSIGNED_BYTE:\n      divisor = 255.0;\n      break;\n    case ComponentDatatype.SHORT:\n      divisor = 32767.0;\n      break;\n    case ComponentDatatype.UNSIGNED_SHORT:\n      divisor = 65535.0;\n      break;\n    case ComponentDatatype.INT:\n      divisor = 2147483647.0;\n      break;\n    case ComponentDatatype.UNSIGNED_INT:\n      divisor = 4294967295.0;\n      break;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\n        `Cannot dequantize component datatype: ${componentDatatype}`\n      );\n    //>>includeEnd('debug');\n  }\n\n  const dequantizedTypedArray = new Float32Array(\n    count * componentsPerAttribute\n  );\n\n  for (let i = 0; i < count; i++) {\n    for (let j = 0; j < componentsPerAttribute; j++) {\n      const index = i * componentsPerAttribute + j;\n      dequantizedTypedArray[index] = Math.max(\n        typedArray[index] / divisor,\n        -1.0\n      );\n    }\n  }\n\n  return dequantizedTypedArray;\n};\n\n/**\n * Decode RGB565-encoded colors into a floating point typed array containing\n * normalized RGB values.\n *\n * @param {Uint16Array} typedArray Array of RGB565 values\n * @param {Float32Array} [result] Array to store the normalized VEC3 result\n */\nAttributeCompression.decodeRGB565 = function (typedArray, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"typedArray\", typedArray);\n\n  const expectedLength = typedArray.length * 3;\n  if (defined(result)) {\n    Check.typeOf.number.equals(\n      \"result.length\",\n      \"typedArray.length * 3\",\n      result.length,\n      expectedLength\n    );\n  }\n  //>>includeEnd('debug');\n\n  const count = typedArray.length;\n  if (!defined(result)) {\n    result = new Float32Array(count * 3);\n  }\n\n  const mask5 = (1 << 5) - 1;\n  const mask6 = (1 << 6) - 1;\n  const normalize5 = 1.0 / 31.0;\n  const normalize6 = 1.0 / 63.0;\n  for (let i = 0; i < count; i++) {\n    const value = typedArray[i];\n    const red = value >> 11;\n    const green = (value >> 5) & mask6;\n    const blue = value & mask5;\n\n    const offset = 3 * i;\n    result[offset] = red * normalize5;\n    result[offset + 1] = green * normalize6;\n    result[offset + 2] = blue * normalize5;\n  }\n\n  return result;\n};\n\nexport default AttributeCompression;\n"],"names":["AttributeType","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","attributeType","Number","Cartesian2","Cartesian3","Cartesian4","Matrix2","Matrix3","Matrix4","DeveloperError","Check","typeOf","string","Object","freeze","RIGHT_SHIFT","AttributeCompression","vector","rangeMax","result","defined","magSquared","magnitudeSquared","Math","abs","CesiumMath","EPSILON6","x","y","z","signNotZero","toSNorm","octEncodeInRange","octEncodeScratch","uint8ForceArray","Uint8Array","forceUint8","value","octEncodeToCartesian4","w","octDecodeInRange","fromSNorm","oldVX","normalize","octDecode","octDecodeFromCartesian4","encoded","object","xOct16","yOct16","octPackFloat","scratchEncodeCart2","zigZagDecode","octEncodeFloat","octEncode","octDecodeFloat","temp","floor","octPack","v1","v2","v3","encoded1","encoded2","encoded3","octUnpack","packed","encodedFloat1","encodedFloat2","compressTextureCoordinates","textureCoordinates","decompressTextureCoordinates","compressed","xZeroTo4095","zigZagDeltaDecode","uBuffer","vBuffer","heightBuffer","number","equals","length","count","u","v","height","i","dequantize","typedArray","componentDatatype","type","componentsPerAttribute","getNumberOfComponents","divisor","ComponentDatatype","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","dequantizedTypedArray","Float32Array","j","index","max","decodeRGB565","expectedLength","normalize5","red","green","blue","offset"],"mappings":"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"}