{"version":3,"file":"EllipseOutlineGeometry-7293c691.js","sources":["../../../../Source/Core/EllipseOutlineGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EllipseGeometryLibrary from \"./EllipseGeometryLibrary.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst scratchCartesian1 = new Cartesian3();\nlet boundingSphereCenter = new Cartesian3();\n\nfunction computeEllipse(options) {\n  const center = options.center;\n  boundingSphereCenter = Cartesian3.multiplyByScalar(\n    options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter),\n    options.height,\n    boundingSphereCenter\n  );\n  boundingSphereCenter = Cartesian3.add(\n    center,\n    boundingSphereCenter,\n    boundingSphereCenter\n  );\n  const boundingSphere = new BoundingSphere(\n    boundingSphereCenter,\n    options.semiMajorAxis\n  );\n  const positions = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    false,\n    true\n  ).outerPositions;\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: EllipseGeometryLibrary.raisePositionsToHeight(\n        positions,\n        options,\n        false\n      ),\n    }),\n  });\n\n  const length = positions.length / 3;\n  const indices = IndexDatatype.createTypedArray(length, length * 2);\n  let index = 0;\n  for (let i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n  }\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nconst topBoundingSphere = new BoundingSphere();\nconst bottomBoundingSphere = new BoundingSphere();\nfunction computeExtrudedEllipse(options) {\n  const center = options.center;\n  const ellipsoid = options.ellipsoid;\n  const semiMajorAxis = options.semiMajorAxis;\n  let scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1),\n    options.height,\n    scratchCartesian1\n  );\n  topBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    topBoundingSphere.center\n  );\n  topBoundingSphere.radius = semiMajorAxis;\n\n  scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scaledNormal),\n    options.extrudedHeight,\n    scaledNormal\n  );\n  bottomBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    bottomBoundingSphere.center\n  );\n  bottomBoundingSphere.radius = semiMajorAxis;\n\n  let positions = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    false,\n    true\n  ).outerPositions;\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: EllipseGeometryLibrary.raisePositionsToHeight(\n        positions,\n        options,\n        true\n      ),\n    }),\n  });\n\n  positions = attributes.position.values;\n  const boundingSphere = BoundingSphere.union(\n    topBoundingSphere,\n    bottomBoundingSphere\n  );\n  let length = positions.length / 3;\n\n  if (defined(options.offsetAttribute)) {\n    let applyOffset = new Uint8Array(length);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = arrayFill(applyOffset, 1, 0, length / 2);\n    } else {\n      const offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = arrayFill(applyOffset, offsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  let numberOfVerticalLines = defaultValue(options.numberOfVerticalLines, 16);\n  numberOfVerticalLines = CesiumMath.clamp(\n    numberOfVerticalLines,\n    0,\n    length / 2\n  );\n\n  const indices = IndexDatatype.createTypedArray(\n    length,\n    length * 2 + numberOfVerticalLines * 2\n  );\n\n  length /= 2;\n  let index = 0;\n  let i;\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = ((i + 1) % length) + length;\n  }\n\n  let numSide;\n  if (numberOfVerticalLines > 0) {\n    const numSideLines = Math.min(numberOfVerticalLines, length);\n    numSide = Math.round(length / numSideLines);\n\n    const maxI = Math.min(numSide * numberOfVerticalLines, length);\n    for (i = 0; i < maxI; i += numSide) {\n      indices[index++] = i;\n      indices[index++] = i + length;\n    }\n  }\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\n/**\n * A description of the outline of an ellipse on an ellipsoid.\n *\n * @alias EllipseOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.\n * @param {Number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.\n * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n * @see EllipseOutlineGeometry.createGeometry\n *\n * @example\n * const ellipse = new Cesium.EllipseOutlineGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * const geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);\n */\nfunction EllipseOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const center = options.center;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(center)) {\n    throw new DeveloperError(\"center is required.\");\n  }\n  if (!defined(semiMajorAxis)) {\n    throw new DeveloperError(\"semiMajorAxis is required.\");\n  }\n  if (!defined(semiMinorAxis)) {\n    throw new DeveloperError(\"semiMinorAxis is required.\");\n  }\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\n      \"semiMajorAxis must be greater than or equal to the semiMinorAxis.\"\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._center = Cartesian3.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._numberOfVerticalLines = Math.max(\n    defaultValue(options.numberOfVerticalLines, 16),\n    0\n  );\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipseOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipseOutlineGeometry.packedLength =\n  Cartesian3.packedLength + Ellipsoid.packedLength + 8;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipseOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._center, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._numberOfVerticalLines;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchCenter = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  numberOfVerticalLines: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.\n */\nEllipseOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n  startingIndex += Cartesian3.packedLength;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const semiMajorAxis = array[startingIndex++];\n  const semiMinorAxis = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const height = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const numberOfVerticalLines = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new EllipseOutlineGeometry(scratchOptions);\n  }\n\n  result._center = Cartesian3.clone(center, result._center);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._numberOfVerticalLines = numberOfVerticalLines;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipseOutlineGeometry.createGeometry = function (ellipseGeometry) {\n  if (\n    ellipseGeometry._semiMajorAxis <= 0.0 ||\n    ellipseGeometry._semiMinorAxis <= 0.0\n  ) {\n    return;\n  }\n\n  const height = ellipseGeometry._height;\n  const extrudedHeight = ellipseGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(\n    ellipseGeometry._center,\n    ellipseGeometry._center\n  );\n  const options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    numberOfVerticalLines: ellipseGeometry._numberOfVerticalLines,\n  };\n  let geometry;\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n\n    if (defined(ellipseGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      const applyOffset = new Uint8Array(length / 3);\n      const offsetValue =\n        ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      arrayFill(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute,\n  });\n};\nexport default EllipseOutlineGeometry;\n"],"names":["scratchCartesian1","Cartesian3","boundingSphereCenter","topBoundingSphere","BoundingSphere","bottomBoundingSphere","EllipseOutlineGeometry","options","center","defaultValue","EMPTY_OBJECT","ellipsoid","Ellipsoid","WGS84","semiMajorAxis","semiMinorAxis","granularity","CesiumMath","RADIANS_PER_DEGREE","defined","DeveloperError","height","extrudedHeight","this","_center","clone","_semiMajorAxis","_semiMinorAxis","_ellipsoid","_rotation","rotation","_height","Math","max","_granularity","_extrudedHeight","min","_numberOfVerticalLines","numberOfVerticalLines","_offsetAttribute","offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchCenter","scratchEllipsoid","scratchOptions","undefined","unpack","result","createGeometry","ellipseGeometry","extrude","equalsEpsilon","EPSILON2","scaleToGeodeticSurface","geometry","scaledNormal","multiplyByScalar","geodeticSurfaceNormal","add","radius","positions","EllipseGeometryLibrary","computeEllipsePositions","outerPositions","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","raisePositionsToHeight","boundingSphere","union","length","applyOffset","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","offsetValue","NONE","UNSIGNED_BYTE","clamp","indices","IndexDatatype","createTypedArray","i","numSide","index","numSideLines","round","maxI","computeExtrudedEllipse","computeEllipse","Geometry","primitiveType","PrimitiveType","LINES"],"mappings":"4VAiBA,MAAMA,EAAoB,IAAIC,aAC9B,IAAIC,EAAuB,IAAID,aAmD/B,MAAME,EAAoB,IAAIC,iBACxBC,EAAuB,IAAID,iBA+IjC,SAASE,EAAuBC,GAG9B,MAAMC,GAFND,EAAUE,eAAaF,EAASE,eAAaC,eAEtBF,OACjBG,EAAYF,eAAaF,EAAQI,UAAWC,YAAUC,OACtDC,EAAgBP,EAAQO,cACxBC,EAAgBR,EAAQQ,cACxBC,EAAcP,eAClBF,EAAQS,YACRC,aAAWC,oBAIb,IAAKC,UAAQX,GACX,MAAM,IAAIY,iBAAe,uBAE3B,IAAKD,UAAQL,GACX,MAAM,IAAIM,iBAAe,8BAE3B,IAAKD,UAAQJ,GACX,MAAM,IAAIK,iBAAe,8BAE3B,GAAIN,EAAgBC,EAClB,MAAM,IAAIK,iBACR,qEAGJ,GAAIJ,GAAe,EACjB,MAAM,IAAII,iBAAe,0CAI3B,MAAMC,EAASZ,eAAaF,EAAQc,OAAQ,GACtCC,EAAiBb,eAAaF,EAAQe,eAAgBD,GAE5DE,KAAKC,QAAUvB,aAAWwB,MAAMjB,GAChCe,KAAKG,eAAiBZ,EACtBS,KAAKI,eAAiBZ,EACtBQ,KAAKK,WAAahB,YAAUa,MAAMd,GAClCY,KAAKM,UAAYpB,eAAaF,EAAQuB,SAAU,GAChDP,KAAKQ,QAAUC,KAAKC,IAAIX,EAAgBD,GACxCE,KAAKW,aAAelB,EACpBO,KAAKY,gBAAkBH,KAAKI,IAAId,EAAgBD,GAChDE,KAAKc,uBAAyBL,KAAKC,IACjCxB,eAAaF,EAAQ+B,sBAAuB,IAC5C,GAEFf,KAAKgB,iBAAmBhC,EAAQiC,gBAChCjB,KAAKkB,YAAc,+BAOrBnC,EAAuBoC,aACrBzC,aAAWyC,aAAe9B,YAAU8B,aAAe,EAWrDpC,EAAuBqC,KAAO,SAAUC,EAAOC,EAAOC,GAEpD,IAAK3B,UAAQyB,GACX,MAAM,IAAIxB,iBAAe,qBAE3B,IAAKD,UAAQ0B,GACX,MAAM,IAAIzB,iBAAe,qBAqB3B,OAjBA0B,EAAgBrC,eAAaqC,EAAe,GAE5C7C,aAAW0C,KAAKC,EAAMpB,QAASqB,EAAOC,GACtCA,GAAiB7C,aAAWyC,aAE5B9B,YAAU+B,KAAKC,EAAMhB,WAAYiB,EAAOC,GACxCA,GAAiBlC,YAAU8B,aAE3BG,EAAMC,KAAmBF,EAAMlB,eAC/BmB,EAAMC,KAAmBF,EAAMjB,eAC/BkB,EAAMC,KAAmBF,EAAMf,UAC/BgB,EAAMC,KAAmBF,EAAMb,QAC/Bc,EAAMC,KAAmBF,EAAMV,aAC/BW,EAAMC,KAAmBF,EAAMT,gBAC/BU,EAAMC,KAAmBF,EAAMP,uBAC/BQ,EAAMC,GAAiBrC,eAAamC,EAAML,kBAAmB,GAEtDM,GAGT,MAAME,EAAgB,IAAI9C,aACpB+C,EAAmB,IAAIpC,YACvBqC,EAAiB,CACrBzC,OAAQuC,EACRpC,UAAWqC,EACXlC,mBAAeoC,EACfnC,mBAAemC,EACfpB,cAAUoB,EACV7B,YAAQ6B,EACRlC,iBAAakC,EACb5B,oBAAgB4B,EAChBZ,2BAAuBY,EACvBV,qBAAiBU,GAWnB5C,EAAuB6C,OAAS,SAAUN,EAAOC,EAAeM,GAE9D,IAAKjC,UAAQ0B,GACX,MAAM,IAAIzB,iBAAe,qBAI3B0B,EAAgBrC,eAAaqC,EAAe,GAE5C,MAAMtC,EAASP,aAAWkD,OAAON,EAAOC,EAAeC,GACvDD,GAAiB7C,aAAWyC,aAE5B,MAAM/B,EAAYC,YAAUuC,OAAON,EAAOC,EAAeE,GACzDF,GAAiBlC,YAAU8B,aAE3B,MAAM5B,EAAgB+B,EAAMC,KACtB/B,EAAgB8B,EAAMC,KACtBhB,EAAWe,EAAMC,KACjBzB,EAASwB,EAAMC,KACf9B,EAAc6B,EAAMC,KACpBxB,EAAiBuB,EAAMC,KACvBR,EAAwBO,EAAMC,KAC9BN,EAAkBK,EAAMC,GAE9B,OAAK3B,UAAQiC,IAcbA,EAAO5B,QAAUvB,aAAWwB,MAAMjB,EAAQ4C,EAAO5B,SACjD4B,EAAOxB,WAAahB,YAAUa,MAAMd,EAAWyC,EAAOxB,YACtDwB,EAAO1B,eAAiBZ,EACxBsC,EAAOzB,eAAiBZ,EACxBqC,EAAOvB,UAAYC,EACnBsB,EAAOrB,QAAUV,EACjB+B,EAAOlB,aAAelB,EACtBoC,EAAOjB,gBAAkBb,EACzB8B,EAAOf,uBAAyBC,EAChCc,EAAOb,kBACgB,IAArBC,OAAyBU,EAAYV,EAEhCY,IAzBLH,EAAe5B,OAASA,EACxB4B,EAAe3B,eAAiBA,EAChC2B,EAAejC,YAAcA,EAC7BiC,EAAenB,SAAWA,EAC1BmB,EAAenC,cAAgBA,EAC/BmC,EAAelC,cAAgBA,EAC/BkC,EAAeX,sBAAwBA,EACvCW,EAAeT,iBACQ,IAArBA,OAAyBU,EAAYV,EAEhC,IAAIlC,EAAuB2C,KAwBtC3C,EAAuB+C,eAAiB,SAAUC,GAChD,GACEA,EAAgB5B,gBAAkB,GAClC4B,EAAgB3B,gBAAkB,EAElC,OAGF,MAAMN,EAASiC,EAAgBvB,QACzBT,EAAiBgC,EAAgBnB,gBACjCoB,GAAWtC,aAAWuC,cAC1BnC,EACAC,EACA,EACAL,aAAWwC,UAGbH,EAAgB9B,QAAU8B,EAAgB1B,WAAW8B,uBACnDJ,EAAgB9B,QAChB8B,EAAgB9B,SAElB,MAAMjB,EAAU,CACdC,OAAQ8C,EAAgB9B,QACxBV,cAAewC,EAAgB5B,eAC/BX,cAAeuC,EAAgB3B,eAC/BhB,UAAW2C,EAAgB1B,WAC3BE,SAAUwB,EAAgBzB,UAC1BR,OAAQA,EACRL,YAAasC,EAAgBpB,aAC7BI,sBAAuBgB,EAAgBjB,wBAEzC,IAAIsB,EACJ,GAAIJ,EACFhD,EAAQe,eAAiBA,EACzBf,EAAQiC,gBAAkBc,EAAgBf,iBAC1CoB,EApWJ,SAAgCpD,GAC9B,MAAMC,EAASD,EAAQC,OACjBG,EAAYJ,EAAQI,UACpBG,EAAgBP,EAAQO,cAC9B,IAAI8C,EAAe3D,aAAW4D,iBAC5BlD,EAAUmD,sBAAsBtD,EAAQR,GACxCO,EAAQc,OACRrB,GAEFG,EAAkBK,OAASP,aAAW8D,IACpCvD,EACAoD,EACAzD,EAAkBK,QAEpBL,EAAkB6D,OAASlD,EAE3B8C,EAAe3D,aAAW4D,iBACxBlD,EAAUmD,sBAAsBtD,EAAQoD,GACxCrD,EAAQe,eACRsC,GAEFvD,EAAqBG,OAASP,aAAW8D,IACvCvD,EACAoD,EACAvD,EAAqBG,QAEvBH,EAAqB2D,OAASlD,EAE9B,IAAImD,EAAYC,yBAAuBC,wBACrC5D,GACA,GACA,GACA6D,eACF,MAAMC,EAAa,IAAIC,qBAAmB,CACxCC,SAAU,IAAIC,oBAAkB,CAC9BC,kBAAmBC,oBAAkBC,OACrCC,uBAAwB,EACxBC,OAAQX,yBAAuBY,uBAC7Bb,EACA1D,GACA,OAKN0D,EAAYI,EAAWE,SAASM,OAChC,MAAME,EAAiB3E,iBAAe4E,MACpC7E,EACAE,GAEF,IAAI4E,EAAShB,EAAUgB,OAAS,EAEhC,GAAI9D,UAAQZ,EAAQiC,iBAAkB,CACpC,IAAI0C,EAAc,IAAIC,WAAWF,GACjC,GAAI1E,EAAQiC,kBAAoB4C,0BAAwBC,IACtDH,EAAcI,YAAUJ,EAAa,EAAG,EAAGD,EAAS,OAC/C,CACL,MAAMM,EACJhF,EAAQiC,kBAAoB4C,0BAAwBI,KAAO,EAAI,EACjEN,EAAcI,YAAUJ,EAAaK,GAGvClB,EAAWa,YAAc,IAAIV,oBAAkB,CAC7CC,kBAAmBC,oBAAkBe,cACrCb,uBAAwB,EACxBC,OAAQK,IAIZ,IAAI5C,EAAwB7B,eAAaF,EAAQ+B,sBAAuB,IACxEA,EAAwBrB,aAAWyE,MACjCpD,EACA,EACA2C,EAAS,GAGX,MAAMU,EAAUC,gBAAcC,iBAC5BZ,EACS,EAATA,EAAqC,EAAxB3C,GAGf2C,GAAU,EACV,IACIa,EAQAC,EATAC,EAAQ,EAEZ,IAAKF,EAAI,EAAGA,EAAIb,IAAUa,EACxBH,EAAQK,KAAWF,EACnBH,EAAQK,MAAYF,EAAI,GAAKb,EAC7BU,EAAQK,KAAWF,EAAIb,EACvBU,EAAQK,MAAaF,EAAI,GAAKb,EAAUA,EAI1C,GAAI3C,EAAwB,EAAG,CAC7B,MAAM2D,EAAejE,KAAKI,IAAIE,EAAuB2C,GACrDc,EAAU/D,KAAKkE,MAAMjB,EAASgB,GAE9B,MAAME,EAAOnE,KAAKI,IAAI2D,EAAUzD,EAAuB2C,GACvD,IAAKa,EAAI,EAAGA,EAAIK,EAAML,GAAKC,EACzBJ,EAAQK,KAAWF,EACnBH,EAAQK,KAAWF,EAAIb,EAI3B,MAAO,CACLF,eAAgBA,EAChBV,WAAYA,EACZsB,QAASA,GA0PES,CAAuB7F,QAIlC,GAFAoD,EAzZJ,SAAwBpD,GACtB,MAAMC,EAASD,EAAQC,OACvBN,EAAuBD,aAAW4D,iBAChCtD,EAAQI,UAAUmD,sBAAsBtD,EAAQN,GAChDK,EAAQc,OACRnB,GAEFA,EAAuBD,aAAW8D,IAChCvD,EACAN,EACAA,GAEF,MAAM6E,EAAiB,IAAI3E,iBACzBF,EACAK,EAAQO,eAEJmD,EAAYC,yBAAuBC,wBACvC5D,GACA,GACA,GACA6D,eAEIC,EAAa,IAAIC,qBAAmB,CACxCC,SAAU,IAAIC,oBAAkB,CAC9BC,kBAAmBC,oBAAkBC,OACrCC,uBAAwB,EACxBC,OAAQX,yBAAuBY,uBAC7Bb,EACA1D,GACA,OAKA0E,EAAShB,EAAUgB,OAAS,EAC5BU,EAAUC,gBAAcC,iBAAiBZ,EAAiB,EAATA,GACvD,IAAIe,EAAQ,EACZ,IAAK,IAAIF,EAAI,EAAGA,EAAIb,IAAUa,EAC5BH,EAAQK,KAAWF,EACnBH,EAAQK,MAAYF,EAAI,GAAKb,EAG/B,MAAO,CACLF,eAAgBA,EAChBV,WAAYA,EACZsB,QAASA,GA4WEU,CAAe9F,GAEtBY,UAAQmC,EAAgBf,kBAAmB,CAC7C,MAAM0C,EAAStB,EAASU,WAAWE,SAASM,OAAOI,OAC7CC,EAAc,IAAIC,WAAWF,EAAS,GACtCM,EACJjC,EAAgBf,mBAAqB6C,0BAAwBI,KACzD,EACA,EACNF,YAAUJ,EAAaK,GACvB5B,EAASU,WAAWa,YAAc,IAAIV,oBAAkB,CACtDC,kBAAmBC,oBAAkBe,cACrCb,uBAAwB,EACxBC,OAAQK,IAKd,OAAO,IAAIoB,WAAS,CAClBjC,WAAYV,EAASU,WACrBsB,QAAShC,EAASgC,QAClBY,cAAeC,gBAAcC,MAC7B1B,eAAgBpB,EAASoB,eACzBvC,gBAAiBc,EAAgBf"}