define(["./Transforms-8b90e17c","./Matrix2-265d9610","./RuntimeError-5b082e8f","./when-4bbc8319","./ComponentDatatype-aad54330","./ArcType-fc72c06c","./arrayRemoveDuplicates-65de6756","./EllipsoidGeodesic-ed024f16","./EllipsoidRhumbLine-d09d563f","./EncodedCartesian3-da8f96bc","./GeometryAttribute-4bcb785f","./IntersectionTests-596e31ec","./Plane-616c9c0a","./WebMercatorProjection-d67afe4b","./combine-e9466e32","./WebGLConstants-508b9636"],(function(e,t,a,n,i,r,s,o,l,c,u,C,p,d,h,g){"use strict";function f(a){a=n.defaultValue(a,n.defaultValue.EMPTY_OBJECT),this._ellipsoid=n.defaultValue(a.ellipsoid,t.Ellipsoid.WGS84),this._rectangle=n.defaultValue(a.rectangle,t.Rectangle.MAX_VALUE),this._projection=new e.GeographicProjection(this._ellipsoid),this._numberOfLevelZeroTilesX=n.defaultValue(a.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=n.defaultValue(a.numberOfLevelZeroTilesY,1)}Object.defineProperties(f.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}}),f.prototype.getNumberOfXTilesAtLevel=function(e){return this._numberOfLevelZeroTilesX<<e},f.prototype.getNumberOfYTilesAtLevel=function(e){return this._numberOfLevelZeroTilesY<<e},f.prototype.rectangleToNativeRectangle=function(e,r){a.Check.defined("rectangle",e);const s=i.CesiumMath.toDegrees(e.west),o=i.CesiumMath.toDegrees(e.south),l=i.CesiumMath.toDegrees(e.east),c=i.CesiumMath.toDegrees(e.north);return n.defined(r)?(r.west=s,r.south=o,r.east=l,r.north=c,r):new t.Rectangle(s,o,l,c)},f.prototype.tileXYToNativeRectangle=function(e,t,a,n){const r=this.tileXYToRectangle(e,t,a,n);return r.west=i.CesiumMath.toDegrees(r.west),r.south=i.CesiumMath.toDegrees(r.south),r.east=i.CesiumMath.toDegrees(r.east),r.north=i.CesiumMath.toDegrees(r.north),r},f.prototype.tileXYToRectangle=function(e,a,i,r){const s=this._rectangle,o=this.getNumberOfXTilesAtLevel(i),l=this.getNumberOfYTilesAtLevel(i),c=s.width/o,u=e*c+s.west,C=(e+1)*c+s.west,p=s.height/l,d=s.north-a*p,h=s.north-(a+1)*p;return n.defined(r)||(r=new t.Rectangle(u,h,C,d)),r.west=u,r.south=h,r.east=C,r.north=d,r},f.prototype.positionToTileXY=function(e,a,r){const s=this._rectangle;if(!t.Rectangle.contains(s,e))return;const o=this.getNumberOfXTilesAtLevel(a),l=this.getNumberOfYTilesAtLevel(a),c=s.width/o,u=s.height/l;let C=e.longitude;s.east<s.west&&(C+=i.CesiumMath.TWO_PI);let p=(C-s.west)/c|0;p>=o&&(p=o-1);let d=(s.north-e.latitude)/u|0;return d>=l&&(d=l-1),n.defined(r)?(r.x=p,r.y=d,r):new t.Cartesian2(p,d)};const m=new t.Cartesian3,w=new t.Cartesian3,y=new t.Cartographic,T=new t.Cartesian3,E=new t.Cartesian3,M=new e.BoundingSphere,_=new f,O=[new t.Cartographic,new t.Cartographic,new t.Cartographic,new t.Cartographic],b=new t.Cartesian2,A={};function k(e){t.Cartographic.fromRadians(e.east,e.north,0,O[0]),t.Cartographic.fromRadians(e.west,e.north,0,O[1]),t.Cartographic.fromRadians(e.east,e.south,0,O[2]),t.Cartographic.fromRadians(e.west,e.south,0,O[3]);let a=0,n=0,i=0,r=0;const s=A._terrainHeightsMaxLevel;let o;for(o=0;o<=s;++o){let e=!1;for(let t=0;t<4;++t){const a=O[t];if(_.positionToTileXY(a,o,b),0===t)i=b.x,r=b.y;else if(i!==b.x||r!==b.y){e=!0;break}}if(e)break;a=i,n=r}if(0!==o)return{x:a,y:n,level:o>s?s:o-1}}A.initialize=function(){let t=A._initPromise;return n.defined(t)||(t=e.Resource.fetchJson(e.buildModuleUrl("Assets/approximateTerrainHeights.json")).then((function(e){A._terrainHeights=e})),A._initPromise=t),t},A.getMinimumMaximumHeights=function(e,i){if(a.Check.defined("rectangle",e),!n.defined(A._terrainHeights))throw new a.DeveloperError("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");i=n.defaultValue(i,t.Ellipsoid.WGS84);const r=k(e);let s=A._defaultMinTerrainHeight,o=A._defaultMaxTerrainHeight;if(n.defined(r)){const a=`${r.level}-${r.x}-${r.y}`,l=A._terrainHeights[a];n.defined(l)&&(s=l[0],o=l[1]),i.cartographicToCartesian(t.Rectangle.northeast(e,y),m),i.cartographicToCartesian(t.Rectangle.southwest(e,y),w),t.Cartesian3.midpoint(w,m,T);const c=i.scaleToGeodeticSurface(T,E);if(n.defined(c)){const e=t.Cartesian3.distance(T,c);s=Math.min(s,-e)}else s=A._defaultMinTerrainHeight}return s=Math.max(A._defaultMinTerrainHeight,s),{minimumTerrainHeight:s,maximumTerrainHeight:o}},A.getBoundingSphere=function(i,r){if(a.Check.defined("rectangle",i),!n.defined(A._terrainHeights))throw new a.DeveloperError("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");r=n.defaultValue(r,t.Ellipsoid.WGS84);const s=k(i);let o=A._defaultMaxTerrainHeight;if(n.defined(s)){const e=`${s.level}-${s.x}-${s.y}`,t=A._terrainHeights[e];n.defined(t)&&(o=t[1])}const l=e.BoundingSphere.fromRectangle3D(i,r,0);return e.BoundingSphere.fromRectangle3D(i,r,o,M),e.BoundingSphere.union(l,M,l)},A._terrainHeightsMaxLevel=6,A._defaultMaxTerrainHeight=9e3,A._defaultMinTerrainHeight=-1e5,A._terrainHeights=void 0,A._initPromise=void 0,Object.defineProperties(A,{initialized:{get:function(){return n.defined(A._terrainHeights)}}});const P=[e.GeographicProjection,d.WebMercatorProjection],S=P.length,L=Math.cos(i.CesiumMath.toRadians(30)),x=Math.cos(i.CesiumMath.toRadians(150));function I(e){const i=(e=n.defaultValue(e,n.defaultValue.EMPTY_OBJECT)).positions;if(!n.defined(i)||i.length<2)throw new a.DeveloperError("At least two positions are required.");if(n.defined(e.arcType)&&e.arcType!==r.ArcType.GEODESIC&&e.arcType!==r.ArcType.RHUMB)throw new a.DeveloperError("Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.");this.width=n.defaultValue(e.width,1),this._positions=i,this.granularity=n.defaultValue(e.granularity,9999),this.loop=n.defaultValue(e.loop,!1),this.arcType=n.defaultValue(e.arcType,r.ArcType.GEODESIC),this._ellipsoid=t.Ellipsoid.WGS84,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(I.prototype,{packedLength:{get:function(){return 1+3*this._positions.length+1+1+1+t.Ellipsoid.packedLength+1+1}}}),I.setProjectionAndEllipsoid=function(e,t){let a=0;for(let e=0;e<S;e++)if(t instanceof P[e]){a=e;break}e._projectionIndex=a,e._ellipsoid=t.ellipsoid};const D=new t.Cartesian3,N=new t.Cartesian3,R=new t.Cartesian3;function v(e,a,n,i,r){const s=Y(i,e,0,D),o=Y(i,e,n,N),l=Y(i,a,0,R),c=q(o,s,N),u=q(l,s,R);return t.Cartesian3.cross(u,c,r),t.Cartesian3.normalize(r,r)}const H=new t.Cartographic,z=new t.Cartesian3,B=new t.Cartesian3,G=new t.Cartesian3;function j(e,a,n,i,s,c,u,C,p,d,h){if(0===s)return;let g;c===r.ArcType.GEODESIC?g=new o.EllipsoidGeodesic(e,a,u):c===r.ArcType.RHUMB&&(g=new l.EllipsoidRhumbLine(e,a,u));const f=g.surfaceDistance;if(f<s)return;const m=v(e,a,i,u,G),w=Math.ceil(f/s),y=f/w;let T=y;const E=w-1;let M=C.length;for(let e=0;e<E;e++){const e=g.interpolateUsingSurfaceDistance(T,H),a=Y(u,e,n,z),r=Y(u,e,i,B);t.Cartesian3.pack(m,C,M),t.Cartesian3.pack(a,p,M),t.Cartesian3.pack(r,d,M),h.push(e.latitude),h.push(e.longitude),M+=3,T+=y}}const V=new t.Cartographic;function Y(e,a,n,i){return t.Cartographic.clone(a,V),V.height=n,t.Cartographic.toCartesian(V,e,i)}function q(e,a,n){return t.Cartesian3.subtract(e,a,n),t.Cartesian3.normalize(n,n),n}function F(e,a,n,i){return i=q(e,a,i),i=t.Cartesian3.cross(i,n,i),i=t.Cartesian3.normalize(i,i),i=t.Cartesian3.cross(n,i,i)}I.pack=function(e,i,r){a.Check.typeOf.object("value",e),a.Check.defined("array",i);let s=n.defaultValue(r,0);const o=e._positions,l=o.length;i[s++]=l;for(let e=0;e<l;++e){const a=o[e];t.Cartesian3.pack(a,i,s),s+=3}return i[s++]=e.granularity,i[s++]=e.loop?1:0,i[s++]=e.arcType,t.Ellipsoid.pack(e._ellipsoid,i,s),s+=t.Ellipsoid.packedLength,i[s++]=e._projectionIndex,i[s++]=e._scene3DOnly?1:0,i},I.unpack=function(e,i,r){a.Check.defined("array",e);let s=n.defaultValue(i,0);const o=e[s++],l=new Array(o);for(let a=0;a<o;a++)l[a]=t.Cartesian3.unpack(e,s),s+=3;const c=e[s++],u=1===e[s++],C=e[s++],p=t.Ellipsoid.unpack(e,s);s+=t.Ellipsoid.packedLength;const d=e[s++],h=1===e[s++];return n.defined(r)||(r=new I({positions:l})),r._positions=l,r.granularity=c,r.loop=u,r.arcType=C,r._ellipsoid=p,r._projectionIndex=d,r._scene3DOnly=h,r};const X=new t.Cartesian3,U=new t.Cartesian3,W=new t.Cartesian3,Z=new t.Cartesian3;function $(e,a,n,r,s){const o=q(n,a,Z),l=F(e,a,o,X),c=F(r,a,o,U);if(i.CesiumMath.equalsEpsilon(t.Cartesian3.dot(l,c),-1,i.CesiumMath.EPSILON5))return s=t.Cartesian3.cross(o,l,s),s=t.Cartesian3.normalize(s,s);s=t.Cartesian3.add(c,l,s),s=t.Cartesian3.normalize(s,s);const u=t.Cartesian3.cross(o,s,W);return t.Cartesian3.dot(c,u)<0&&(s=t.Cartesian3.negate(s,s)),s}const J=p.Plane.fromPointNormal(t.Cartesian3.ZERO,t.Cartesian3.UNIT_Y),Q=new t.Cartesian3,K=new t.Cartesian3,ee=new t.Cartesian3,te=new t.Cartesian3,ae=new t.Cartesian3,ne=new t.Cartesian3,ie=new t.Cartographic,re=new t.Cartographic,se=new t.Cartographic;I.createGeometry=function(a){const o=!a._scene3DOnly;let p=a.loop;const d=a._ellipsoid,h=a.granularity,g=a.arcType,f=new P[a._projectionIndex](d),m=1e3;let w,y;const T=a._positions,E=T.length;let M,_,O,b;2===E&&(p=!1);const k=new l.EllipsoidRhumbLine(void 0,void 0,d);let S,x,I;const D=[T[0]];for(y=0;y<E-1;y++)M=T[y],_=T[y+1],S=C.IntersectionTests.lineSegmentPlane(M,_,J,ne),!n.defined(S)||t.Cartesian3.equalsEpsilon(S,M,i.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(S,_,i.CesiumMath.EPSILON7)||(a.arcType===r.ArcType.GEODESIC?D.push(t.Cartesian3.clone(S)):a.arcType===r.ArcType.RHUMB&&(I=d.cartesianToCartographic(S,ie).longitude,O=d.cartesianToCartographic(M,ie),b=d.cartesianToCartographic(_,re),k.setEndPoints(O,b),x=k.findIntersectionWithLongitude(I,se),S=d.cartographicToCartesian(x,ne),!n.defined(S)||t.Cartesian3.equalsEpsilon(S,M,i.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(S,_,i.CesiumMath.EPSILON7)||D.push(t.Cartesian3.clone(S)))),D.push(_);p&&(M=T[E-1],_=T[0],S=C.IntersectionTests.lineSegmentPlane(M,_,J,ne),!n.defined(S)||t.Cartesian3.equalsEpsilon(S,M,i.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(S,_,i.CesiumMath.EPSILON7)||(a.arcType===r.ArcType.GEODESIC?D.push(t.Cartesian3.clone(S)):a.arcType===r.ArcType.RHUMB&&(I=d.cartesianToCartographic(S,ie).longitude,O=d.cartesianToCartographic(M,ie),b=d.cartesianToCartographic(_,re),k.setEndPoints(O,b),x=k.findIntersectionWithLongitude(I,se),S=d.cartographicToCartesian(x,ne),!n.defined(S)||t.Cartesian3.equalsEpsilon(S,M,i.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(S,_,i.CesiumMath.EPSILON7)||D.push(t.Cartesian3.clone(S)))));let N=D.length,R=new Array(N);for(y=0;y<N;y++){const e=t.Cartographic.fromCartesian(D[y],d);e.height=0,R[y]=e}if(R=s.arrayRemoveDuplicates(R,t.Cartographic.equalsEpsilon),N=R.length,N<2)return;const H=[],z=[],B=[],G=[];let V=Q,F=K,X=ee,U=te,W=ae;const Z=R[0],oe=R[1];for(V=Y(d,R[N-1],0,V),U=Y(d,oe,0,U),F=Y(d,Z,0,F),X=Y(d,Z,m,X),W=p?$(V,F,X,U,W):v(Z,oe,m,d,W),t.Cartesian3.pack(W,z,0),t.Cartesian3.pack(F,B,0),t.Cartesian3.pack(X,G,0),H.push(Z.latitude),H.push(Z.longitude),j(Z,oe,0,m,h,g,d,z,B,G,H),y=1;y<N-1;++y){V=t.Cartesian3.clone(F,V),F=t.Cartesian3.clone(U,F);const e=R[y];Y(d,e,m,X),Y(d,R[y+1],0,U),$(V,F,X,U,W),w=z.length,t.Cartesian3.pack(W,z,w),t.Cartesian3.pack(F,B,w),t.Cartesian3.pack(X,G,w),H.push(e.latitude),H.push(e.longitude),j(R[y],R[y+1],0,m,h,g,d,z,B,G,H)}const le=R[N-1],ce=R[N-2];if(F=Y(d,le,0,F),X=Y(d,le,m,X),p){const e=R[0];V=Y(d,ce,0,V),U=Y(d,e,0,U),W=$(V,F,X,U,W)}else W=v(ce,le,m,d,W);if(w=z.length,t.Cartesian3.pack(W,z,w),t.Cartesian3.pack(F,B,w),t.Cartesian3.pack(X,G,w),H.push(le.latitude),H.push(le.longitude),p){for(j(le,Z,0,m,h,g,d,z,B,G,H),w=z.length,y=0;y<3;++y)z[w+y]=z[y],B[w+y]=B[y],G[w+y]=G[y];H.push(Z.latitude),H.push(Z.longitude)}return function(a,n,r,s,o,l,C){let p,d;const h=n._ellipsoid,g=r.length/3-1,f=8*g,m=4*f,w=36*g,y=f>65535?new Uint32Array(w):new Uint16Array(w),T=new Float64Array(3*f),E=new Float32Array(m),M=new Float32Array(m),_=new Float32Array(m),O=new Float32Array(m),b=new Float32Array(m);let k,P,S,x;C&&(k=new Float32Array(m),P=new Float32Array(m),S=new Float32Array(m),x=new Float32Array(2*f));const I=l.length/2;let D=0;const N=Ee;N.height=0;const R=Me;R.height=0;let v=_e,H=Oe;if(C)for(d=0,p=1;p<I;p++)N.latitude=l[d],N.longitude=l[d+1],R.latitude=l[d+2],R.longitude=l[d+3],v=n.project(N,v),H=n.project(R,H),D+=t.Cartesian3.distance(v,H),d+=2;const z=s.length/3;H=t.Cartesian3.unpack(s,0,H);let B,G=0;for(d=3,p=1;p<z;p++)v=t.Cartesian3.clone(H,v),H=t.Cartesian3.unpack(s,d,H),G+=t.Cartesian3.distance(v,H),d+=3;d=3;let j=0,V=0,Y=0,F=0,X=!1,U=t.Cartesian3.unpack(r,0,Ae),W=t.Cartesian3.unpack(s,0,Oe),Z=t.Cartesian3.unpack(o,0,Pe);if(a){ue(Z,t.Cartesian3.unpack(r,r.length-6,be),U,W)&&(Z=t.Cartesian3.negate(Z,Z))}let $=0,J=0,Q=0;for(p=0;p<g;p++){const e=t.Cartesian3.clone(U,be),a=t.Cartesian3.clone(W,_e);let u,p,g,f,m=t.Cartesian3.clone(Z,ke);if(X&&(m=t.Cartesian3.negate(m,m)),U=t.Cartesian3.unpack(r,d,Ae),W=t.Cartesian3.unpack(s,d,Oe),Z=t.Cartesian3.unpack(o,d,Pe),X=ue(Z,e,U,W),N.latitude=l[j],N.longitude=l[j+1],R.latitude=l[j+2],R.longitude=l[j+3],C){const e=Te(N,R);u=n.project(N,Re),p=n.project(R,ve);const a=q(p,u,Ue);a.y=Math.abs(a.y),g=He,f=ze,0===e||t.Cartesian3.dot(a,t.Cartesian3.UNIT_Y)>L?(g=he(n,N,m,u,He),f=he(n,R,Z,p,ze)):1===e?(f=he(n,R,Z,p,ze),g.x=0,g.y=i.CesiumMath.sign(N.longitude-Math.abs(R.longitude)),g.z=0):(g=he(n,N,m,u,He),f.x=0,f.y=i.CesiumMath.sign(N.longitude-R.longitude),f.z=0)}const w=t.Cartesian3.distance(a,W),y=c.EncodedCartesian3.fromCartesian(e,Fe),I=t.Cartesian3.subtract(U,e,Be),v=t.Cartesian3.normalize(I,Ve);let H=t.Cartesian3.subtract(a,e,Ge);H=t.Cartesian3.normalize(H,H);let z=t.Cartesian3.cross(v,H,Ve);z=t.Cartesian3.normalize(z,z);let K=t.Cartesian3.cross(H,m,Ye);K=t.Cartesian3.normalize(K,K);let ee=t.Cartesian3.subtract(W,U,je);ee=t.Cartesian3.normalize(ee,ee);let te=t.Cartesian3.cross(Z,ee,qe);te=t.Cartesian3.normalize(te,te);const ae=w/G,ne=$/G;let ie,re,se,oe=0,le=0,ce=0;if(C){oe=t.Cartesian3.distance(u,p),ie=c.EncodedCartesian3.fromCartesian(u,Xe),re=t.Cartesian3.subtract(p,u,Ue),se=t.Cartesian3.normalize(re,We);const e=se.x;se.x=se.y,se.y=-e,le=oe/D,ce=J/D}for(B=0;B<8;B++){const e=F+4*B,a=V+2*B,n=e+3,i=B<4?1:-1,r=2===B||3===B||6===B||7===B?1:-1;t.Cartesian3.pack(y.high,E,e),E[n]=I.x,t.Cartesian3.pack(y.low,M,e),M[n]=I.y,t.Cartesian3.pack(K,_,e),_[n]=I.z,t.Cartesian3.pack(te,O,e),O[n]=ae*i,t.Cartesian3.pack(z,b,e);let s=ne*r;0===s&&r<0&&(s=9),b[n]=s,C&&(k[e]=ie.high.x,k[e+1]=ie.high.y,k[e+2]=ie.low.x,k[e+3]=ie.low.y,S[e]=-g.y,S[e+1]=g.x,S[e+2]=f.y,S[e+3]=-f.x,P[e]=re.x,P[e+1]=re.y,P[e+2]=se.x,P[e+3]=se.y,x[a]=le*i,s=ce*r,0===s&&r<0&&(s=9),x[a+1]=s)}const Ce=De,pe=Ne,de=xe,ge=Ie,fe=t.Rectangle.fromCartographicArray(Se,Le),we=A.getMinimumMaximumHeights(fe,h),Ee=we.minimumTerrainHeight,Me=we.maximumTerrainHeight;Q+=Ee,Q+=Me,me(e,a,Ee,Me,Ce,de),me(U,W,Ee,Me,pe,ge);let $e=t.Cartesian3.multiplyByScalar(z,i.CesiumMath.EPSILON5,Ze);t.Cartesian3.add(Ce,$e,Ce),t.Cartesian3.add(pe,$e,pe),t.Cartesian3.add(de,$e,de),t.Cartesian3.add(ge,$e,ge),ye(Ce,pe),ye(de,ge),t.Cartesian3.pack(Ce,T,Y),t.Cartesian3.pack(pe,T,Y+3),t.Cartesian3.pack(ge,T,Y+6),t.Cartesian3.pack(de,T,Y+9),$e=t.Cartesian3.multiplyByScalar(z,-2*i.CesiumMath.EPSILON5,Ze),t.Cartesian3.add(Ce,$e,Ce),t.Cartesian3.add(pe,$e,pe),t.Cartesian3.add(de,$e,de),t.Cartesian3.add(ge,$e,ge),ye(Ce,pe),ye(de,ge),t.Cartesian3.pack(Ce,T,Y+12),t.Cartesian3.pack(pe,T,Y+15),t.Cartesian3.pack(ge,T,Y+18),t.Cartesian3.pack(de,T,Y+21),j+=2,d+=3,V+=16,Y+=24,F+=32,$+=w,J+=oe}d=0;let K=0;for(p=0;p<g;p++){for(B=0;B<Qe;B++)y[d+B]=Je[B]+K;K+=8,d+=Qe}const ee=$e;e.BoundingSphere.fromVertices(r,t.Cartesian3.ZERO,3,ee[0]),e.BoundingSphere.fromVertices(s,t.Cartesian3.ZERO,3,ee[1]);const te=e.BoundingSphere.fromBoundingSpheres(ee);te.radius+=Q/(2*g);const ae={position:new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,normalize:!1,values:T}),startHiAndForwardOffsetX:Ke(E),startLoAndForwardOffsetY:Ke(M),startNormalAndForwardOffsetZ:Ke(_),endNormalAndTextureCoordinateNormalizationX:Ke(O),rightNormalAndTextureCoordinateNormalizationY:Ke(b)};C&&(ae.startHiLo2D=Ke(k),ae.offsetAndRight2D=Ke(P),ae.startEndNormals2D=Ke(S),ae.texcoordNormalization2D=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,normalize:!1,values:x}));return new u.Geometry({attributes:ae,indices:y,boundingSphere:te})}(p,f,B,G,z,H,o)};const oe=new t.Cartesian3,le=new t.Matrix3,ce=new e.Quaternion;function ue(a,n,r,s){const o=q(r,n,oe),l=t.Cartesian3.dot(o,a);if(l>L||l<x){const n=q(s,r,Z),o=l<x?i.CesiumMath.PI_OVER_TWO:-i.CesiumMath.PI_OVER_TWO,c=e.Quaternion.fromAxisAngle(n,o,ce),u=t.Matrix3.fromQuaternion(c,le);return t.Matrix3.multiplyByVector(u,a,a),!0}return!1}const Ce=new t.Cartographic,pe=new t.Cartesian3,de=new t.Cartesian3;function he(e,a,n,r,s){const o=t.Cartographic.toCartesian(a,e._ellipsoid,pe);let l=t.Cartesian3.add(o,n,de),c=!1;const u=e._ellipsoid;let C=u.cartesianToCartographic(l,Ce);Math.abs(a.longitude-C.longitude)>i.CesiumMath.PI_OVER_TWO&&(c=!0,l=t.Cartesian3.subtract(o,n,de),C=u.cartesianToCartographic(l,Ce)),C.height=0;const p=e.project(C,s);return(s=t.Cartesian3.subtract(p,r,s)).z=0,s=t.Cartesian3.normalize(s,s),c&&t.Cartesian3.negate(s,s),s}const ge=new t.Cartesian3,fe=new t.Cartesian3;function me(e,a,n,i,r,s){const o=t.Cartesian3.subtract(a,e,ge);t.Cartesian3.normalize(o,o);const l=n-0;let c=t.Cartesian3.multiplyByScalar(o,l,fe);t.Cartesian3.add(e,c,r);const u=i-1e3;c=t.Cartesian3.multiplyByScalar(o,u,fe),t.Cartesian3.add(a,c,s)}const we=new t.Cartesian3;function ye(e,a){const n=p.Plane.getPointDistance(J,e),r=p.Plane.getPointDistance(J,a);let s=we;i.CesiumMath.equalsEpsilon(n,0,i.CesiumMath.EPSILON2)?(s=q(a,e,s),t.Cartesian3.multiplyByScalar(s,i.CesiumMath.EPSILON2,s),t.Cartesian3.add(e,s,e)):i.CesiumMath.equalsEpsilon(r,0,i.CesiumMath.EPSILON2)&&(s=q(e,a,s),t.Cartesian3.multiplyByScalar(s,i.CesiumMath.EPSILON2,s),t.Cartesian3.add(a,s,a))}function Te(e,t){const a=Math.abs(e.longitude),n=Math.abs(t.longitude);if(i.CesiumMath.equalsEpsilon(a,i.CesiumMath.PI,i.CesiumMath.EPSILON11)){const n=i.CesiumMath.sign(t.longitude);return e.longitude=n*(a-i.CesiumMath.EPSILON11),1}if(i.CesiumMath.equalsEpsilon(n,i.CesiumMath.PI,i.CesiumMath.EPSILON11)){const a=i.CesiumMath.sign(e.longitude);return t.longitude=a*(n-i.CesiumMath.EPSILON11),2}return 0}const Ee=new t.Cartographic,Me=new t.Cartographic,_e=new t.Cartesian3,Oe=new t.Cartesian3,be=new t.Cartesian3,Ae=new t.Cartesian3,ke=new t.Cartesian3,Pe=new t.Cartesian3,Se=[Ee,Me],Le=new t.Rectangle,xe=new t.Cartesian3,Ie=new t.Cartesian3,De=new t.Cartesian3,Ne=new t.Cartesian3,Re=new t.Cartesian3,ve=new t.Cartesian3,He=new t.Cartesian3,ze=new t.Cartesian3,Be=new t.Cartesian3,Ge=new t.Cartesian3,je=new t.Cartesian3,Ve=new t.Cartesian3,Ye=new t.Cartesian3,qe=new t.Cartesian3,Fe=new c.EncodedCartesian3,Xe=new c.EncodedCartesian3,Ue=new t.Cartesian3,We=new t.Cartesian3,Ze=new t.Cartesian3,$e=[new e.BoundingSphere,new e.BoundingSphere],Je=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],Qe=Je.length;function Ke(e){return new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}return I._projectNormal=he,function(e,t){return A.initialize().then((function(){return n.defined(t)&&(e=I.unpack(e,t)),I.createGeometry(e)}))}}));
//# sourceMappingURL=createGroundPolylineGeometry.js.map
