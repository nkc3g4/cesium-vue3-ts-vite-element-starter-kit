{"version":3,"file":"EllipsoidRhumbLine-d09d563f.js","sources":["../../../../Source/Core/EllipsoidRhumbLine.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\n\nfunction calculateM(ellipticity, major, latitude) {\n  if (ellipticity === 0.0) {\n    // sphere\n    return major * latitude;\n  }\n\n  const e2 = ellipticity * ellipticity;\n  const e4 = e2 * e2;\n  const e6 = e4 * e2;\n  const e8 = e6 * e2;\n  const e10 = e8 * e2;\n  const e12 = e10 * e2;\n  const phi = latitude;\n  const sin2Phi = Math.sin(2 * phi);\n  const sin4Phi = Math.sin(4 * phi);\n  const sin6Phi = Math.sin(6 * phi);\n  const sin8Phi = Math.sin(8 * phi);\n  const sin10Phi = Math.sin(10 * phi);\n  const sin12Phi = Math.sin(12 * phi);\n\n  return (\n    major *\n    ((1 -\n      e2 / 4 -\n      (3 * e4) / 64 -\n      (5 * e6) / 256 -\n      (175 * e8) / 16384 -\n      (441 * e10) / 65536 -\n      (4851 * e12) / 1048576) *\n      phi -\n      ((3 * e2) / 8 +\n        (3 * e4) / 32 +\n        (45 * e6) / 1024 +\n        (105 * e8) / 4096 +\n        (2205 * e10) / 131072 +\n        (6237 * e12) / 524288) *\n        sin2Phi +\n      ((15 * e4) / 256 +\n        (45 * e6) / 1024 +\n        (525 * e8) / 16384 +\n        (1575 * e10) / 65536 +\n        (155925 * e12) / 8388608) *\n        sin4Phi -\n      ((35 * e6) / 3072 +\n        (175 * e8) / 12288 +\n        (3675 * e10) / 262144 +\n        (13475 * e12) / 1048576) *\n        sin6Phi +\n      ((315 * e8) / 131072 + (2205 * e10) / 524288 + (43659 * e12) / 8388608) *\n        sin8Phi -\n      ((693 * e10) / 1310720 + (6237 * e12) / 5242880) * sin10Phi +\n      ((1001 * e12) / 8388608) * sin12Phi)\n  );\n}\n\nfunction calculateInverseM(M, ellipticity, major) {\n  const d = M / major;\n\n  if (ellipticity === 0.0) {\n    // sphere\n    return d;\n  }\n\n  const d2 = d * d;\n  const d3 = d2 * d;\n  const d4 = d3 * d;\n  const e = ellipticity;\n  const e2 = e * e;\n  const e4 = e2 * e2;\n  const e6 = e4 * e2;\n  const e8 = e6 * e2;\n  const e10 = e8 * e2;\n  const e12 = e10 * e2;\n  const sin2D = Math.sin(2 * d);\n  const cos2D = Math.cos(2 * d);\n  const sin4D = Math.sin(4 * d);\n  const cos4D = Math.cos(4 * d);\n  const sin6D = Math.sin(6 * d);\n  const cos6D = Math.cos(6 * d);\n  const sin8D = Math.sin(8 * d);\n  const cos8D = Math.cos(8 * d);\n  const sin10D = Math.sin(10 * d);\n  const cos10D = Math.cos(10 * d);\n  const sin12D = Math.sin(12 * d);\n\n  return (\n    d +\n    (d * e2) / 4 +\n    (7 * d * e4) / 64 +\n    (15 * d * e6) / 256 +\n    (579 * d * e8) / 16384 +\n    (1515 * d * e10) / 65536 +\n    (16837 * d * e12) / 1048576 +\n    ((3 * d * e4) / 16 +\n      (45 * d * e6) / 256 -\n      (d * (32 * d2 - 561) * e8) / 4096 -\n      (d * (232 * d2 - 1677) * e10) / 16384 +\n      (d * (399985 - 90560 * d2 + 512 * d4) * e12) / 5242880) *\n      cos2D +\n    ((21 * d * e6) / 256 +\n      (483 * d * e8) / 4096 -\n      (d * (224 * d2 - 1969) * e10) / 16384 -\n      (d * (33152 * d2 - 112599) * e12) / 1048576) *\n      cos4D +\n    ((151 * d * e8) / 4096 +\n      (4681 * d * e10) / 65536 +\n      (1479 * d * e12) / 16384 -\n      (453 * d3 * e12) / 32768) *\n      cos6D +\n    ((1097 * d * e10) / 65536 + (42783 * d * e12) / 1048576) * cos8D +\n    ((8011 * d * e12) / 1048576) * cos10D +\n    ((3 * e2) / 8 +\n      (3 * e4) / 16 +\n      (213 * e6) / 2048 -\n      (3 * d2 * e6) / 64 +\n      (255 * e8) / 4096 -\n      (33 * d2 * e8) / 512 +\n      (20861 * e10) / 524288 -\n      (33 * d2 * e10) / 512 +\n      (d4 * e10) / 1024 +\n      (28273 * e12) / 1048576 -\n      (471 * d2 * e12) / 8192 +\n      (9 * d4 * e12) / 4096) *\n      sin2D +\n    ((21 * e4) / 256 +\n      (21 * e6) / 256 +\n      (533 * e8) / 8192 -\n      (21 * d2 * e8) / 512 +\n      (197 * e10) / 4096 -\n      (315 * d2 * e10) / 4096 +\n      (584039 * e12) / 16777216 -\n      (12517 * d2 * e12) / 131072 +\n      (7 * d4 * e12) / 2048) *\n      sin4D +\n    ((151 * e6) / 6144 +\n      (151 * e8) / 4096 +\n      (5019 * e10) / 131072 -\n      (453 * d2 * e10) / 16384 +\n      (26965 * e12) / 786432 -\n      (8607 * d2 * e12) / 131072) *\n      sin6D +\n    ((1097 * e8) / 131072 +\n      (1097 * e10) / 65536 +\n      (225797 * e12) / 10485760 -\n      (1097 * d2 * e12) / 65536) *\n      sin8D +\n    ((8011 * e10) / 2621440 + (8011 * e12) / 1048576) * sin10D +\n    ((293393 * e12) / 251658240) * sin12D\n  );\n}\n\nfunction calculateSigma(ellipticity, latitude) {\n  if (ellipticity === 0.0) {\n    // sphere\n    return Math.log(Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + latitude)));\n  }\n\n  const eSinL = ellipticity * Math.sin(latitude);\n  return (\n    Math.log(Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + latitude))) -\n    (ellipticity / 2.0) * Math.log((1 + eSinL) / (1 - eSinL))\n  );\n}\n\nfunction calculateHeading(\n  ellipsoidRhumbLine,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude\n) {\n  const sigma1 = calculateSigma(ellipsoidRhumbLine._ellipticity, firstLatitude);\n  const sigma2 = calculateSigma(\n    ellipsoidRhumbLine._ellipticity,\n    secondLatitude\n  );\n  return Math.atan2(\n    CesiumMath.negativePiToPi(secondLongitude - firstLongitude),\n    sigma2 - sigma1\n  );\n}\n\nfunction calculateArcLength(\n  ellipsoidRhumbLine,\n  major,\n  minor,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude\n) {\n  const heading = ellipsoidRhumbLine._heading;\n  const deltaLongitude = secondLongitude - firstLongitude;\n\n  let distance = 0.0;\n\n  //Check to see if the rhumb line has constant latitude\n  //This equation will diverge if heading gets close to 90 degrees\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(heading),\n      CesiumMath.PI_OVER_TWO,\n      CesiumMath.EPSILON8\n    )\n  ) {\n    //If heading is close to 90 degrees\n    if (major === minor) {\n      distance =\n        major *\n        Math.cos(firstLatitude) *\n        CesiumMath.negativePiToPi(deltaLongitude);\n    } else {\n      const sinPhi = Math.sin(firstLatitude);\n      distance =\n        (major *\n          Math.cos(firstLatitude) *\n          CesiumMath.negativePiToPi(deltaLongitude)) /\n        Math.sqrt(1 - ellipsoidRhumbLine._ellipticitySquared * sinPhi * sinPhi);\n    }\n  } else {\n    const M1 = calculateM(\n      ellipsoidRhumbLine._ellipticity,\n      major,\n      firstLatitude\n    );\n    const M2 = calculateM(\n      ellipsoidRhumbLine._ellipticity,\n      major,\n      secondLatitude\n    );\n\n    distance = (M2 - M1) / Math.cos(heading);\n  }\n  return Math.abs(distance);\n}\n\nconst scratchCart1 = new Cartesian3();\nconst scratchCart2 = new Cartesian3();\n\nfunction computeProperties(ellipsoidRhumbLine, start, end, ellipsoid) {\n  const firstCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(start, scratchCart2),\n    scratchCart1\n  );\n  const lastCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(end, scratchCart2),\n    scratchCart2\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"value\",\n    Math.abs(\n      Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) - Math.PI\n    ),\n    0.0125\n  );\n  //>>includeEnd('debug');\n\n  const major = ellipsoid.maximumRadius;\n  const minor = ellipsoid.minimumRadius;\n  const majorSquared = major * major;\n  const minorSquared = minor * minor;\n  ellipsoidRhumbLine._ellipticitySquared =\n    (majorSquared - minorSquared) / majorSquared;\n  ellipsoidRhumbLine._ellipticity = Math.sqrt(\n    ellipsoidRhumbLine._ellipticitySquared\n  );\n\n  ellipsoidRhumbLine._start = Cartographic.clone(\n    start,\n    ellipsoidRhumbLine._start\n  );\n  ellipsoidRhumbLine._start.height = 0;\n\n  ellipsoidRhumbLine._end = Cartographic.clone(end, ellipsoidRhumbLine._end);\n  ellipsoidRhumbLine._end.height = 0;\n\n  ellipsoidRhumbLine._heading = calculateHeading(\n    ellipsoidRhumbLine,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude\n  );\n  ellipsoidRhumbLine._distance = calculateArcLength(\n    ellipsoidRhumbLine,\n    ellipsoid.maximumRadius,\n    ellipsoid.minimumRadius,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude\n  );\n}\n\nfunction interpolateUsingSurfaceDistance(\n  start,\n  heading,\n  distance,\n  major,\n  ellipticity,\n  result\n) {\n  if (distance === 0.0) {\n    return Cartographic.clone(start, result);\n  }\n\n  const ellipticitySquared = ellipticity * ellipticity;\n\n  let longitude;\n  let latitude;\n  let deltaLongitude;\n\n  //Check to see if the rhumb line has constant latitude\n  //This won't converge if heading is close to 90 degrees\n  if (\n    Math.abs(CesiumMath.PI_OVER_TWO - Math.abs(heading)) > CesiumMath.EPSILON8\n  ) {\n    //Calculate latitude of the second point\n    const M1 = calculateM(ellipticity, major, start.latitude);\n    const deltaM = distance * Math.cos(heading);\n    const M2 = M1 + deltaM;\n    latitude = calculateInverseM(M2, ellipticity, major);\n\n    //Now find the longitude of the second point\n    const sigma1 = calculateSigma(ellipticity, start.latitude);\n    const sigma2 = calculateSigma(ellipticity, latitude);\n    deltaLongitude = Math.tan(heading) * (sigma2 - sigma1);\n    longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);\n  } else {\n    //If heading is close to 90 degrees\n    latitude = start.latitude;\n    let localRad;\n\n    if (ellipticity === 0.0) {\n      // sphere\n      localRad = major * Math.cos(start.latitude);\n    } else {\n      const sinPhi = Math.sin(start.latitude);\n      localRad =\n        (major * Math.cos(start.latitude)) /\n        Math.sqrt(1 - ellipticitySquared * sinPhi * sinPhi);\n    }\n\n    deltaLongitude = distance / localRad;\n    if (heading > 0.0) {\n      longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);\n    } else {\n      longitude = CesiumMath.negativePiToPi(start.longitude - deltaLongitude);\n    }\n  }\n\n  if (defined(result)) {\n    result.longitude = longitude;\n    result.latitude = latitude;\n    result.height = 0;\n\n    return result;\n  }\n\n  return new Cartographic(longitude, latitude, 0);\n}\n\n/**\n * Initializes a rhumb line on the ellipsoid connecting the two provided planetodetic points.\n *\n * @alias EllipsoidRhumbLine\n * @constructor\n *\n * @param {Cartographic} [start] The initial planetodetic point on the path.\n * @param {Cartographic} [end] The final planetodetic point on the path.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rhumb line lies.\n *\n * @exception {DeveloperError} angle between start and end must be at least 0.0125 radians.\n */\nfunction EllipsoidRhumbLine(start, end, ellipsoid) {\n  const e = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  this._ellipsoid = e;\n  this._start = new Cartographic();\n  this._end = new Cartographic();\n\n  this._heading = undefined;\n  this._distance = undefined;\n  this._ellipticity = undefined;\n  this._ellipticitySquared = undefined;\n\n  if (defined(start) && defined(end)) {\n    computeProperties(this, start, end, e);\n  }\n}\n\nObject.defineProperties(EllipsoidRhumbLine.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the surface distance between the start and end point\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Number}\n   * @readonly\n   */\n  surfaceDistance: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._distance;\n    },\n  },\n\n  /**\n   * Gets the initial planetodetic point on the path.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      return this._start;\n    },\n  },\n\n  /**\n   * Gets the final planetodetic point on the path.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  end: {\n    get: function () {\n      return this._end;\n    },\n  },\n\n  /**\n   * Gets the heading from the start point to the end point.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Number}\n   * @readonly\n   */\n  heading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._heading;\n    },\n  },\n});\n\n/**\n * Create a rhumb line using an initial position with a heading and distance.\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Number} heading The heading in radians.\n * @param {Number} distance The rhumb line distance between the start and end point.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rhumb line lies.\n * @param {EllipsoidRhumbLine} [result] The object in which to store the result.\n * @returns {EllipsoidRhumbLine} The EllipsoidRhumbLine object.\n */\nEllipsoidRhumbLine.fromStartHeadingDistance = function (\n  start,\n  heading,\n  distance,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"start\", start);\n  Check.defined(\"heading\", heading);\n  Check.defined(\"distance\", distance);\n  Check.typeOf.number.greaterThan(\"distance\", distance, 0.0);\n  //>>includeEnd('debug');\n\n  const e = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  const major = e.maximumRadius;\n  const minor = e.minimumRadius;\n  const majorSquared = major * major;\n  const minorSquared = minor * minor;\n  const ellipticity = Math.sqrt((majorSquared - minorSquared) / majorSquared);\n\n  heading = CesiumMath.negativePiToPi(heading);\n  const end = interpolateUsingSurfaceDistance(\n    start,\n    heading,\n    distance,\n    e.maximumRadius,\n    ellipticity\n  );\n\n  if (\n    !defined(result) ||\n    (defined(ellipsoid) && !ellipsoid.equals(result.ellipsoid))\n  ) {\n    return new EllipsoidRhumbLine(start, end, e);\n  }\n\n  result.setEndPoints(start, end);\n  return result;\n};\n\n/**\n * Sets the start and end points of the rhumb line.\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Cartographic} end The final planetodetic point on the path.\n */\nEllipsoidRhumbLine.prototype.setEndPoints = function (start, end) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"start\", start);\n  Check.defined(\"end\", end);\n  //>>includeEnd('debug');\n\n  computeProperties(this, start, end, this._ellipsoid);\n};\n\n/**\n * Provides the location of a point at the indicated portion along the rhumb line.\n *\n * @param {Number} fraction The portion of the distance between the initial and final points.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the rhumb line.\n */\nEllipsoidRhumbLine.prototype.interpolateUsingFraction = function (\n  fraction,\n  result\n) {\n  return this.interpolateUsingSurfaceDistance(\n    fraction * this._distance,\n    result\n  );\n};\n\n/**\n * Provides the location of a point at the indicated distance along the rhumb line.\n *\n * @param {Number} distance The distance from the inital point to the point of interest along the rhumbLine.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the rhumb line.\n *\n * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance\n */\nEllipsoidRhumbLine.prototype.interpolateUsingSurfaceDistance = function (\n  distance,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"distance\", distance);\n  if (!defined(this._distance) || this._distance === 0.0) {\n    throw new DeveloperError(\n      \"EllipsoidRhumbLine must have distinct start and end set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return interpolateUsingSurfaceDistance(\n    this._start,\n    this._heading,\n    distance,\n    this._ellipsoid.maximumRadius,\n    this._ellipticity,\n    result\n  );\n};\n\n/**\n * Provides the location of a point at the indicated longitude along the rhumb line.\n * If the longitude is outside the range of start and end points, the first intersection with the longitude from the start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.\n *\n * @param {Number} intersectionLongitude The longitude, in radians, at which to find the intersection point from the starting point using the heading.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.\n *\n * @exception {DeveloperError} start and end must be set before calling function findIntersectionWithLongitude.\n */\nEllipsoidRhumbLine.prototype.findIntersectionWithLongitude = function (\n  intersectionLongitude,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"intersectionLongitude\", intersectionLongitude);\n  if (!defined(this._distance) || this._distance === 0.0) {\n    throw new DeveloperError(\n      \"EllipsoidRhumbLine must have distinct start and end set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const ellipticity = this._ellipticity;\n  const heading = this._heading;\n  const absHeading = Math.abs(heading);\n  const start = this._start;\n\n  intersectionLongitude = CesiumMath.negativePiToPi(intersectionLongitude);\n\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(intersectionLongitude),\n      Math.PI,\n      CesiumMath.EPSILON14\n    )\n  ) {\n    intersectionLongitude = CesiumMath.sign(start.longitude) * Math.PI;\n  }\n\n  if (!defined(result)) {\n    result = new Cartographic();\n  }\n\n  // If heading is -PI/2 or PI/2, this is an E-W rhumb line\n  // If heading is 0 or PI, this is an N-S rhumb line\n  if (Math.abs(CesiumMath.PI_OVER_TWO - absHeading) <= CesiumMath.EPSILON8) {\n    result.longitude = intersectionLongitude;\n    result.latitude = start.latitude;\n    result.height = 0;\n    return result;\n  } else if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(CesiumMath.PI_OVER_TWO - absHeading),\n      CesiumMath.PI_OVER_TWO,\n      CesiumMath.EPSILON8\n    )\n  ) {\n    if (\n      CesiumMath.equalsEpsilon(\n        intersectionLongitude,\n        start.longitude,\n        CesiumMath.EPSILON12\n      )\n    ) {\n      return undefined;\n    }\n\n    result.longitude = intersectionLongitude;\n    result.latitude =\n      CesiumMath.PI_OVER_TWO *\n      CesiumMath.sign(CesiumMath.PI_OVER_TWO - heading);\n    result.height = 0;\n    return result;\n  }\n\n  // Use iterative solver from Equation 9 from http://edwilliams.org/ellipsoid/ellipsoid.pdf\n  const phi1 = start.latitude;\n  const eSinPhi1 = ellipticity * Math.sin(phi1);\n  const leftComponent =\n    Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + phi1)) *\n    Math.exp((intersectionLongitude - start.longitude) / Math.tan(heading));\n  const denominator = (1 + eSinPhi1) / (1 - eSinPhi1);\n\n  let newPhi = start.latitude;\n  let phi;\n  do {\n    phi = newPhi;\n    const eSinPhi = ellipticity * Math.sin(phi);\n    const numerator = (1 + eSinPhi) / (1 - eSinPhi);\n    newPhi =\n      2 *\n        Math.atan(\n          leftComponent * Math.pow(numerator / denominator, ellipticity / 2)\n        ) -\n      CesiumMath.PI_OVER_TWO;\n  } while (!CesiumMath.equalsEpsilon(newPhi, phi, CesiumMath.EPSILON12));\n\n  result.longitude = intersectionLongitude;\n  result.latitude = newPhi;\n  result.height = 0;\n  return result;\n};\n\n/**\n * Provides the location of a point at the indicated latitude along the rhumb line.\n * If the latitude is outside the range of start and end points, the first intersection with the latitude from that start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.\n *\n * @param {Number} intersectionLatitude The latitude, in radians, at which to find the intersection point from the starting point using the heading.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.\n *\n * @exception {DeveloperError} start and end must be set before calling function findIntersectionWithLongitude.\n */\nEllipsoidRhumbLine.prototype.findIntersectionWithLatitude = function (\n  intersectionLatitude,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"intersectionLatitude\", intersectionLatitude);\n  if (!defined(this._distance) || this._distance === 0.0) {\n    throw new DeveloperError(\n      \"EllipsoidRhumbLine must have distinct start and end set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const ellipticity = this._ellipticity;\n  const heading = this._heading;\n  const start = this._start;\n\n  // If start and end have same latitude, return undefined since it's either no intersection or infinite intersections\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(heading),\n      CesiumMath.PI_OVER_TWO,\n      CesiumMath.EPSILON8\n    )\n  ) {\n    return;\n  }\n\n  // Can be solved using the same equations from interpolateUsingSurfaceDistance\n  const sigma1 = calculateSigma(ellipticity, start.latitude);\n  const sigma2 = calculateSigma(ellipticity, intersectionLatitude);\n  const deltaLongitude = Math.tan(heading) * (sigma2 - sigma1);\n  const longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);\n\n  if (defined(result)) {\n    result.longitude = longitude;\n    result.latitude = intersectionLatitude;\n    result.height = 0;\n\n    return result;\n  }\n\n  return new Cartographic(longitude, intersectionLatitude, 0);\n};\nexport default EllipsoidRhumbLine;\n"],"names":["calculateM","ellipticity","major","latitude","e2","e4","e6","e8","e10","e12","phi","Math","sin","calculateSigma","log","tan","CesiumMath","PI_OVER_TWO","eSinL","scratchCart1","Cartesian3","scratchCart2","computeProperties","ellipsoidRhumbLine","start","end","ellipsoid","firstCartesian","normalize","cartographicToCartesian","lastCartesian","Check","typeOf","number","greaterThanOrEquals","abs","angleBetween","PI","maximumRadius","minor","minimumRadius","majorSquared","minorSquared","_ellipticitySquared","_ellipticity","sqrt","_start","Cartographic","clone","height","_end","_heading","firstLongitude","firstLatitude","secondLongitude","secondLatitude","sigma1","sigma2","atan2","negativePiToPi","calculateHeading","longitude","_distance","heading","deltaLongitude","distance","equalsEpsilon","EPSILON8","cos","sinPhi","M1","calculateArcLength","interpolateUsingSurfaceDistance","result","ellipticitySquared","M","d","d2","d3","d4","sin2D","cos2D","sin4D","cos4D","sin6D","cos6D","sin8D","cos8D","sin10D","calculateInverseM","localRad","defined","EllipsoidRhumbLine","e","defaultValue","Ellipsoid","WGS84","this","_ellipsoid","undefined","Object","defineProperties","prototype","get","surfaceDistance","fromStartHeadingDistance","greaterThan","equals","setEndPoints","interpolateUsingFraction","fraction","DeveloperError","findIntersectionWithLongitude","intersectionLongitude","absHeading","EPSILON14","sign","EPSILON12","phi1","eSinPhi1","leftComponent","exp","denominator","newPhi","eSinPhi","numerator","atan","pow","findIntersectionWithLatitude","intersectionLatitude"],"mappings":"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"}