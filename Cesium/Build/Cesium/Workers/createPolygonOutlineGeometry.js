define(["./when-4bbc8319","./Matrix2-265d9610","./ArcType-fc72c06c","./GeometryOffsetAttribute-7e016332","./Transforms-8b90e17c","./RuntimeError-5b082e8f","./ComponentDatatype-aad54330","./EllipsoidTangentPlane-f1a69a20","./GeometryAttribute-4bcb785f","./GeometryAttributes-7827a6c2","./GeometryInstance-d57564f8","./GeometryPipeline-e93f6439","./IndexDatatype-6739e544","./PolygonGeometryLibrary-e329b948","./PolygonPipeline-5fd67ae2","./combine-e9466e32","./WebGLConstants-508b9636","./AxisAlignedBoundingBox-2a0ca7ef","./IntersectionTests-596e31ec","./Plane-616c9c0a","./AttributeCompression-442278a0","./EncodedCartesian3-da8f96bc","./arrayRemoveDuplicates-65de6756","./EllipsoidRhumbLine-d09d563f"],(function(e,t,i,o,r,n,a,s,l,y,p,u,c,d,f,g,h,m,b,P,E,A,G,_){"use strict";const T=[],H=[];function L(e,t,o,r,n){const u=s.EllipsoidTangentPlane.fromPoints(t,e).projectPointsOntoPlane(t,T);let g,h;f.PolygonPipeline.computeWindingOrder2D(u)===f.WindingOrder.CLOCKWISE&&(u.reverse(),t=t.slice().reverse());let m=t.length,b=0;if(r)for(g=new Float64Array(2*m*3),h=0;h<m;h++){const e=t[h],i=t[(h+1)%m];g[b++]=e.x,g[b++]=e.y,g[b++]=e.z,g[b++]=i.x,g[b++]=i.y,g[b++]=i.z}else{let r=0;if(n===i.ArcType.GEODESIC)for(h=0;h<m;h++)r+=d.PolygonGeometryLibrary.subdivideLineCount(t[h],t[(h+1)%m],o);else if(n===i.ArcType.RHUMB)for(h=0;h<m;h++)r+=d.PolygonGeometryLibrary.subdivideRhumbLineCount(e,t[h],t[(h+1)%m],o);for(g=new Float64Array(3*r),h=0;h<m;h++){let r;n===i.ArcType.GEODESIC?r=d.PolygonGeometryLibrary.subdivideLine(t[h],t[(h+1)%m],o,H):n===i.ArcType.RHUMB&&(r=d.PolygonGeometryLibrary.subdivideRhumbLine(e,t[h],t[(h+1)%m],o,H));const a=r.length;for(let e=0;e<a;++e)g[b++]=r[e]}}m=g.length/3;const P=2*m,E=c.IndexDatatype.createTypedArray(m,P);for(b=0,h=0;h<m-1;h++)E[b++]=h,E[b++]=h+1;return E[b++]=m-1,E[b++]=0,new p.GeometryInstance({geometry:new l.Geometry({attributes:new y.GeometryAttributes({position:new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:g})}),indices:E,primitiveType:l.PrimitiveType.LINES})})}function C(e,t,o,r,n){const u=s.EllipsoidTangentPlane.fromPoints(t,e).projectPointsOntoPlane(t,T);let g,h;f.PolygonPipeline.computeWindingOrder2D(u)===f.WindingOrder.CLOCKWISE&&(u.reverse(),t=t.slice().reverse());let m=t.length;const b=new Array(m);let P=0;if(r)for(g=new Float64Array(2*m*3*2),h=0;h<m;++h){b[h]=P/3;const e=t[h],i=t[(h+1)%m];g[P++]=e.x,g[P++]=e.y,g[P++]=e.z,g[P++]=i.x,g[P++]=i.y,g[P++]=i.z}else{let r=0;if(n===i.ArcType.GEODESIC)for(h=0;h<m;h++)r+=d.PolygonGeometryLibrary.subdivideLineCount(t[h],t[(h+1)%m],o);else if(n===i.ArcType.RHUMB)for(h=0;h<m;h++)r+=d.PolygonGeometryLibrary.subdivideRhumbLineCount(e,t[h],t[(h+1)%m],o);for(g=new Float64Array(3*r*2),h=0;h<m;++h){let r;b[h]=P/3,n===i.ArcType.GEODESIC?r=d.PolygonGeometryLibrary.subdivideLine(t[h],t[(h+1)%m],o,H):n===i.ArcType.RHUMB&&(r=d.PolygonGeometryLibrary.subdivideRhumbLine(e,t[h],t[(h+1)%m],o,H));const a=r.length;for(let e=0;e<a;++e)g[P++]=r[e]}}m=g.length/6;const E=b.length,A=2*(2*m+E),G=c.IndexDatatype.createTypedArray(m+E,A);for(P=0,h=0;h<m;++h)G[P++]=h,G[P++]=(h+1)%m,G[P++]=h+m,G[P++]=(h+1)%m+m;for(h=0;h<E;h++){const e=b[h];G[P++]=e,G[P++]=e+m}return new p.GeometryInstance({geometry:new l.Geometry({attributes:new y.GeometryAttributes({position:new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:g})}),indices:G,primitiveType:l.PrimitiveType.LINES})})}function v(o){if(n.Check.typeOf.object("options",o),n.Check.typeOf.object("options.polygonHierarchy",o.polygonHierarchy),o.perPositionHeight&&e.defined(o.height))throw new n.DeveloperError("Cannot use both options.perPositionHeight and options.height");if(e.defined(o.arcType)&&o.arcType!==i.ArcType.GEODESIC&&o.arcType!==i.ArcType.RHUMB)throw new n.DeveloperError("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");const r=o.polygonHierarchy,s=e.defaultValue(o.ellipsoid,t.Ellipsoid.WGS84),l=e.defaultValue(o.granularity,a.CesiumMath.RADIANS_PER_DEGREE),y=e.defaultValue(o.perPositionHeight,!1),p=y&&e.defined(o.extrudedHeight),u=e.defaultValue(o.arcType,i.ArcType.GEODESIC);let c=e.defaultValue(o.height,0),f=e.defaultValue(o.extrudedHeight,c);if(!p){const e=Math.max(c,f);f=Math.min(c,f),c=e}this._ellipsoid=t.Ellipsoid.clone(s),this._granularity=l,this._height=c,this._extrudedHeight=f,this._arcType=u,this._polygonHierarchy=r,this._perPositionHeight=y,this._perPositionHeightExtrude=p,this._offsetAttribute=o.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this.packedLength=d.PolygonGeometryLibrary.computeHierarchyPackedLength(r)+t.Ellipsoid.packedLength+8}v.pack=function(i,o,r){return n.Check.typeOf.object("value",i),n.Check.defined("array",o),r=e.defaultValue(r,0),r=d.PolygonGeometryLibrary.packPolygonHierarchy(i._polygonHierarchy,o,r),t.Ellipsoid.pack(i._ellipsoid,o,r),r+=t.Ellipsoid.packedLength,o[r++]=i._height,o[r++]=i._extrudedHeight,o[r++]=i._granularity,o[r++]=i._perPositionHeightExtrude?1:0,o[r++]=i._perPositionHeight?1:0,o[r++]=i._arcType,o[r++]=e.defaultValue(i._offsetAttribute,-1),o[r]=i.packedLength,o};const O=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),D={polygonHierarchy:{}};return v.unpack=function(i,o,r){n.Check.defined("array",i),o=e.defaultValue(o,0);const a=d.PolygonGeometryLibrary.unpackPolygonHierarchy(i,o);o=a.startingIndex,delete a.startingIndex;const s=t.Ellipsoid.unpack(i,o,O);o+=t.Ellipsoid.packedLength;const l=i[o++],y=i[o++],p=i[o++],u=1===i[o++],c=1===i[o++],f=i[o++],g=i[o++],h=i[o];return e.defined(r)||(r=new v(D)),r._polygonHierarchy=a,r._ellipsoid=t.Ellipsoid.clone(s,r._ellipsoid),r._height=l,r._extrudedHeight=y,r._granularity=p,r._perPositionHeight=c,r._perPositionHeightExtrude=u,r._arcType=f,r._offsetAttribute=-1===g?void 0:g,r.packedLength=h,r},v.fromPositions=function(t){t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT),n.Check.defined("options.positions",t.positions);return new v({polygonHierarchy:{positions:t.positions},height:t.height,extrudedHeight:t.extrudedHeight,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,arcType:t.arcType,offsetAttribute:t.offsetAttribute})},v.createGeometry=function(t){const i=t._ellipsoid,n=t._granularity,s=t._polygonHierarchy,y=t._perPositionHeight,p=t._arcType,c=d.PolygonGeometryLibrary.polygonOutlinesFromHierarchy(s,!y,i);if(0===c.length)return;let g;const h=[],m=a.CesiumMath.chordLength(n,i.maximumRadius),b=t._height,P=t._extrudedHeight;let E,A;if(t._perPositionHeightExtrude||!a.CesiumMath.equalsEpsilon(b,P,0,a.CesiumMath.EPSILON2))for(A=0;A<c.length;A++){if(g=C(i,c[A],m,y,p),g.geometry=d.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(g.geometry,b,P,i,y),e.defined(t._offsetAttribute)){const e=g.geometry.attributes.position.values.length/3;let i=new Uint8Array(e);t._offsetAttribute===o.GeometryOffsetAttribute.TOP?i=o.arrayFill(i,1,0,e/2):(E=t._offsetAttribute===o.GeometryOffsetAttribute.NONE?0:1,i=o.arrayFill(i,E)),g.geometry.attributes.applyOffset=new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}h.push(g)}else for(A=0;A<c.length;A++){if(g=L(i,c[A],m,y,p),g.geometry.attributes.position.values=f.PolygonPipeline.scaleToGeodeticHeight(g.geometry.attributes.position.values,b,i,!y),e.defined(t._offsetAttribute)){const e=g.geometry.attributes.position.values.length,i=new Uint8Array(e/3);E=t._offsetAttribute===o.GeometryOffsetAttribute.NONE?0:1,o.arrayFill(i,E),g.geometry.attributes.applyOffset=new l.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}h.push(g)}const G=u.GeometryPipeline.combineInstances(h)[0],_=r.BoundingSphere.fromVertices(G.attributes.position.values);return new l.Geometry({attributes:G.attributes,indices:G.indices,primitiveType:G.primitiveType,boundingSphere:_,offsetAttribute:t._offsetAttribute})},function(i,o){return e.defined(o)&&(i=v.unpack(i,o)),i._ellipsoid=t.Ellipsoid.clone(i._ellipsoid),v.createGeometry(i)}}));
//# sourceMappingURL=createPolygonOutlineGeometry.js.map
