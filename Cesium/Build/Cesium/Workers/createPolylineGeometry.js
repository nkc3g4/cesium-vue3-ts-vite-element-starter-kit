define(["./when-4bbc8319","./Matrix2-265d9610","./ArcType-fc72c06c","./arrayRemoveDuplicates-65de6756","./Transforms-8b90e17c","./Color-cc989747","./ComponentDatatype-aad54330","./RuntimeError-5b082e8f","./GeometryAttribute-4bcb785f","./GeometryAttributes-7827a6c2","./IndexDatatype-6739e544","./PolylinePipeline-b9913663","./VertexFormat-07539138","./combine-e9466e32","./WebGLConstants-508b9636","./EllipsoidGeodesic-ed024f16","./EllipsoidRhumbLine-d09d563f","./IntersectionTests-596e31ec","./Plane-616c9c0a"],(function(e,t,o,r,n,i,a,l,s,c,p,d,u,y,m,f,h,C,g){"use strict";const w=[];function E(e,t,o,r,n){const a=w;let l;a.length=n;const s=o.red,c=o.green,p=o.blue,d=o.alpha,u=r.red,y=r.green,m=r.blue,f=r.alpha;if(i.Color.equals(o,r)){for(l=0;l<n;l++)a[l]=i.Color.clone(o);return a}const h=(u-s)/n,C=(y-c)/n,g=(m-p)/n,E=(f-d)/n;for(l=0;l<n;l++)a[l]=new i.Color(s+l*h,c+l*C,p+l*g,d+l*E);return a}function _(r){const n=(r=e.defaultValue(r,e.defaultValue.EMPTY_OBJECT)).positions,s=r.colors,c=e.defaultValue(r.width,1),p=e.defaultValue(r.colorsPerVertex,!1);if(!e.defined(n)||n.length<2)throw new l.DeveloperError("At least two positions are required.");if("number"!=typeof c)throw new l.DeveloperError("width must be a number");if(e.defined(s)&&(p&&s.length<n.length||!p&&s.length<n.length-1))throw new l.DeveloperError("colors has an invalid length.");this._positions=n,this._colors=s,this._width=c,this._colorsPerVertex=p,this._vertexFormat=u.VertexFormat.clone(e.defaultValue(r.vertexFormat,u.VertexFormat.DEFAULT)),this._arcType=e.defaultValue(r.arcType,o.ArcType.GEODESIC),this._granularity=e.defaultValue(r.granularity,a.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";let d=1+n.length*t.Cartesian3.packedLength;d+=e.defined(s)?1+s.length*i.Color.packedLength:1,this.packedLength=d+t.Ellipsoid.packedLength+u.VertexFormat.packedLength+4}_.pack=function(o,r,n){if(!e.defined(o))throw new l.DeveloperError("value is required");if(!e.defined(r))throw new l.DeveloperError("array is required");let a;n=e.defaultValue(n,0);const s=o._positions;let c=s.length;for(r[n++]=c,a=0;a<c;++a,n+=t.Cartesian3.packedLength)t.Cartesian3.pack(s[a],r,n);const p=o._colors;for(c=e.defined(p)?p.length:0,r[n++]=c,a=0;a<c;++a,n+=i.Color.packedLength)i.Color.pack(p[a],r,n);return t.Ellipsoid.pack(o._ellipsoid,r,n),n+=t.Ellipsoid.packedLength,u.VertexFormat.pack(o._vertexFormat,r,n),n+=u.VertexFormat.packedLength,r[n++]=o._width,r[n++]=o._colorsPerVertex?1:0,r[n++]=o._arcType,r[n]=o._granularity,r};const A=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),b=new u.VertexFormat,P={positions:void 0,colors:void 0,ellipsoid:A,vertexFormat:b,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};_.unpack=function(o,r,n){if(!e.defined(o))throw new l.DeveloperError("array is required");let a;r=e.defaultValue(r,0);let s=o[r++];const c=new Array(s);for(a=0;a<s;++a,r+=t.Cartesian3.packedLength)c[a]=t.Cartesian3.unpack(o,r);s=o[r++];const p=s>0?new Array(s):void 0;for(a=0;a<s;++a,r+=i.Color.packedLength)p[a]=i.Color.unpack(o,r);const d=t.Ellipsoid.unpack(o,r,A);r+=t.Ellipsoid.packedLength;const y=u.VertexFormat.unpack(o,r,b);r+=u.VertexFormat.packedLength;const m=o[r++],f=1===o[r++],h=o[r++],C=o[r];return e.defined(n)?(n._positions=c,n._colors=p,n._ellipsoid=t.Ellipsoid.clone(d,n._ellipsoid),n._vertexFormat=u.VertexFormat.clone(y,n._vertexFormat),n._width=m,n._colorsPerVertex=f,n._arcType=h,n._granularity=C,n):(P.positions=c,P.colors=p,P.width=m,P.colorsPerVertex=f,P.arcType=h,P.granularity=C,new _(P))};const v=new t.Cartesian3,D=new t.Cartesian3,x=new t.Cartesian3,T=new t.Cartesian3;return _.createGeometry=function(l){const u=l._width,y=l._vertexFormat;let m=l._colors;const f=l._colorsPerVertex,h=l._arcType,C=l._granularity,g=l._ellipsoid;let _,A,b;const P=[];let k=r.arrayRemoveDuplicates(l._positions,t.Cartesian3.equalsEpsilon,!1,P);if(e.defined(m)&&P.length>0){let e=0,t=P[0];m=m.filter((function(o,r){let n=!1;return n=f?r===t||0===r&&1===t:r+1===t,!n||(e++,t=P[e],!1)}))}let V=k.length;if(V<2||u<=0)return;if(h===o.ArcType.GEODESIC||h===o.ArcType.RHUMB){let t,r;h===o.ArcType.GEODESIC?(t=a.CesiumMath.chordLength(C,g.maximumRadius),r=d.PolylinePipeline.numberOfPoints):(t=C,r=d.PolylinePipeline.numberOfPointsRhumbLine);const n=d.PolylinePipeline.extractHeights(k,g);if(e.defined(m)){let e=1;for(_=0;_<V-1;++_)e+=r(k[_],k[_+1],t);const o=new Array(e);let n=0;for(_=0;_<V-1;++_){const a=k[_],l=k[_+1],s=m[_],c=r(a,l,t);if(f&&_<e){const e=E(0,0,s,m[_+1],c),t=e.length;for(A=0;A<t;++A)o[n++]=e[A]}else for(A=0;A<c;++A)o[n++]=i.Color.clone(s)}o[n]=i.Color.clone(m[m.length-1]),m=o,w.length=0}k=h===o.ArcType.GEODESIC?d.PolylinePipeline.generateCartesianArc({positions:k,minDistance:t,ellipsoid:g,height:n}):d.PolylinePipeline.generateCartesianRhumbArc({positions:k,granularity:t,ellipsoid:g,height:n})}V=k.length;const L=4*V-4,F=new Float64Array(3*L),G=new Float64Array(3*L),O=new Float64Array(3*L),R=new Float32Array(2*L),I=y.st?new Float32Array(2*L):void 0,S=e.defined(m)?new Uint8Array(4*L):void 0;let B,U=0,N=0,q=0,M=0;for(A=0;A<V;++A){let o,r;0===A?(B=v,t.Cartesian3.subtract(k[0],k[1],B),t.Cartesian3.add(k[0],B,B)):B=k[A-1],t.Cartesian3.clone(B,x),t.Cartesian3.clone(k[A],D),A===V-1?(B=v,t.Cartesian3.subtract(k[V-1],k[V-2],B),t.Cartesian3.add(k[V-1],B,B)):B=k[A+1],t.Cartesian3.clone(B,T),e.defined(S)&&(o=0===A||f?m[A]:m[A-1],A!==V-1&&(r=m[A]));const n=A===V-1?2:4;for(b=0===A?2:0;b<n;++b){t.Cartesian3.pack(D,F,U),t.Cartesian3.pack(x,G,U),t.Cartesian3.pack(T,O,U),U+=3;const n=b-2<0?-1:1;if(R[N++]=b%2*2-1,R[N++]=n*u,y.st&&(I[q++]=A/(V-1),I[q++]=Math.max(R[N-2],0)),e.defined(S)){const e=b<2?o:r;S[M++]=i.Color.floatToByte(e.red),S[M++]=i.Color.floatToByte(e.green),S[M++]=i.Color.floatToByte(e.blue),S[M++]=i.Color.floatToByte(e.alpha)}}}const H=new c.GeometryAttributes;H.position=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:F}),H.prevPosition=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G}),H.nextPosition=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:O}),H.expandAndWidth=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:R}),y.st&&(H.st=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:I})),e.defined(S)&&(H.color=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:S,normalize:!0}));const W=p.IndexDatatype.createTypedArray(L,6*V-6);let Y=0,z=0;const J=V-1;for(A=0;A<J;++A)W[z++]=Y,W[z++]=Y+2,W[z++]=Y+1,W[z++]=Y+1,W[z++]=Y+2,W[z++]=Y+3,Y+=4;return new s.Geometry({attributes:H,indices:W,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:n.BoundingSphere.fromPoints(k),geometryType:s.GeometryType.POLYLINES})},function(o,r){return e.defined(r)&&(o=_.unpack(o,r)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),_.createGeometry(o)}}));
//# sourceMappingURL=createPolylineGeometry.js.map
