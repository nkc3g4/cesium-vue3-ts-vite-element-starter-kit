{"version":3,"file":"createVectorTileClampedPolylines.js","sources":["../../../../Source/WorkersES6/createVectorTileClampedPolylines.js"],"sourcesContent":["import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport combine from \"../Core/combine.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\n\nconst MAX_SHORT = 32767;\nconst MITER_BREAK = Math.cos(CesiumMath.toRadians(150.0));\n\nconst scratchBVCartographic = new Cartographic();\nconst scratchEncodedPosition = new Cartesian3();\n\nfunction decodePositions(\n  uBuffer,\n  vBuffer,\n  heightBuffer,\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid\n) {\n  const positionsLength = uBuffer.length;\n  const decodedPositions = new Float64Array(positionsLength * 3);\n  for (let i = 0; i < positionsLength; ++i) {\n    const u = uBuffer[i];\n    const v = vBuffer[i];\n    const h = heightBuffer[i];\n\n    const lon = CesiumMath.lerp(rectangle.west, rectangle.east, u / MAX_SHORT);\n    const lat = CesiumMath.lerp(\n      rectangle.south,\n      rectangle.north,\n      v / MAX_SHORT\n    );\n    const alt = CesiumMath.lerp(minimumHeight, maximumHeight, h / MAX_SHORT);\n\n    const cartographic = Cartographic.fromRadians(\n      lon,\n      lat,\n      alt,\n      scratchBVCartographic\n    );\n    const decodedPosition = ellipsoid.cartographicToCartesian(\n      cartographic,\n      scratchEncodedPosition\n    );\n    Cartesian3.pack(decodedPosition, decodedPositions, i * 3);\n  }\n  return decodedPositions;\n}\n\nfunction getPositionOffsets(counts) {\n  const countsLength = counts.length;\n  const positionOffsets = new Uint32Array(countsLength + 1);\n  let offset = 0;\n  for (let i = 0; i < countsLength; ++i) {\n    positionOffsets[i] = offset;\n    offset += counts[i];\n  }\n  positionOffsets[countsLength] = offset;\n  return positionOffsets;\n}\n\nconst previousCompressedCartographicScratch = new Cartographic();\nconst currentCompressedCartographicScratch = new Cartographic();\nfunction removeDuplicates(uBuffer, vBuffer, heightBuffer, counts) {\n  const countsLength = counts.length;\n  const positionsLength = uBuffer.length;\n  const markRemoval = new Uint8Array(positionsLength);\n  const previous = previousCompressedCartographicScratch;\n  const current = currentCompressedCartographicScratch;\n  let offset = 0;\n  for (let i = 0; i < countsLength; i++) {\n    const count = counts[i];\n    let updatedCount = count;\n    for (let j = 1; j < count; j++) {\n      const index = offset + j;\n      const previousIndex = index - 1;\n      current.longitude = uBuffer[index];\n      current.latitude = vBuffer[index];\n      previous.longitude = uBuffer[previousIndex];\n      previous.latitude = vBuffer[previousIndex];\n\n      if (Cartographic.equals(current, previous)) {\n        updatedCount--;\n        markRemoval[previousIndex] = 1;\n      }\n    }\n    counts[i] = updatedCount;\n    offset += count;\n  }\n\n  let nextAvailableIndex = 0;\n  for (let k = 0; k < positionsLength; k++) {\n    if (markRemoval[k] !== 1) {\n      uBuffer[nextAvailableIndex] = uBuffer[k];\n      vBuffer[nextAvailableIndex] = vBuffer[k];\n      heightBuffer[nextAvailableIndex] = heightBuffer[k];\n      nextAvailableIndex++;\n    }\n  }\n}\n\nfunction VertexAttributesAndIndices(volumesCount) {\n  const vertexCount = volumesCount * 8;\n  const vec3Floats = vertexCount * 3;\n  const vec4Floats = vertexCount * 4;\n  this.startEllipsoidNormals = new Float32Array(vec3Floats);\n  this.endEllipsoidNormals = new Float32Array(vec3Floats);\n  this.startPositionAndHeights = new Float32Array(vec4Floats);\n  this.startFaceNormalAndVertexCornerIds = new Float32Array(vec4Floats);\n  this.endPositionAndHeights = new Float32Array(vec4Floats);\n  this.endFaceNormalAndHalfWidths = new Float32Array(vec4Floats);\n  this.vertexBatchIds = new Uint16Array(vertexCount);\n\n  this.indices = IndexDatatype.createTypedArray(vertexCount, 36 * volumesCount);\n\n  this.vec3Offset = 0;\n  this.vec4Offset = 0;\n  this.batchIdOffset = 0;\n  this.indexOffset = 0;\n\n  this.volumeStartIndex = 0;\n}\n\nconst towardCurrScratch = new Cartesian3();\nconst towardNextScratch = new Cartesian3();\nfunction computeMiteredNormal(\n  previousPosition,\n  position,\n  nextPosition,\n  ellipsoidSurfaceNormal,\n  result\n) {\n  const towardNext = Cartesian3.subtract(\n    nextPosition,\n    position,\n    towardNextScratch\n  );\n  let towardCurr = Cartesian3.subtract(\n    position,\n    previousPosition,\n    towardCurrScratch\n  );\n  Cartesian3.normalize(towardNext, towardNext);\n  Cartesian3.normalize(towardCurr, towardCurr);\n\n  if (Cartesian3.dot(towardNext, towardCurr) < MITER_BREAK) {\n    towardCurr = Cartesian3.multiplyByScalar(\n      towardCurr,\n      -1.0,\n      towardCurrScratch\n    );\n  }\n\n  Cartesian3.add(towardNext, towardCurr, result);\n  if (Cartesian3.equals(result, Cartesian3.ZERO)) {\n    result = Cartesian3.subtract(previousPosition, position);\n  }\n\n  // Make sure the normal is orthogonal to the ellipsoid surface normal\n  Cartesian3.cross(result, ellipsoidSurfaceNormal, result);\n  Cartesian3.cross(ellipsoidSurfaceNormal, result, result);\n  Cartesian3.normalize(result, result);\n  return result;\n}\n\n// Winding order is reversed so each segment's volume is inside-out\n//          3-----------7\n//         /|   left   /|\n//        / | 1       / |\n//       2-----------6  5  end\n//       | /         | /\n// start |/  right   |/\n//       0-----------4\n//\nconst REFERENCE_INDICES = [\n  0,\n  2,\n  6,\n  0,\n  6,\n  4, // right\n  0,\n  1,\n  3,\n  0,\n  3,\n  2, // start face\n  0,\n  4,\n  5,\n  0,\n  5,\n  1, // bottom\n  5,\n  3,\n  1,\n  5,\n  7,\n  3, // left\n  7,\n  5,\n  4,\n  7,\n  4,\n  6, // end face\n  7,\n  6,\n  2,\n  7,\n  2,\n  3, // top\n];\nconst REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\n\nconst positionScratch = new Cartesian3();\nconst scratchStartEllipsoidNormal = new Cartesian3();\nconst scratchStartFaceNormal = new Cartesian3();\nconst scratchEndEllipsoidNormal = new Cartesian3();\nconst scratchEndFaceNormal = new Cartesian3();\nVertexAttributesAndIndices.prototype.addVolume = function (\n  preStartRTC,\n  startRTC,\n  endRTC,\n  postEndRTC,\n  startHeight,\n  endHeight,\n  halfWidth,\n  batchId,\n  center,\n  ellipsoid\n) {\n  let position = Cartesian3.add(startRTC, center, positionScratch);\n  const startEllipsoidNormal = ellipsoid.geodeticSurfaceNormal(\n    position,\n    scratchStartEllipsoidNormal\n  );\n  position = Cartesian3.add(endRTC, center, positionScratch);\n  const endEllipsoidNormal = ellipsoid.geodeticSurfaceNormal(\n    position,\n    scratchEndEllipsoidNormal\n  );\n\n  const startFaceNormal = computeMiteredNormal(\n    preStartRTC,\n    startRTC,\n    endRTC,\n    startEllipsoidNormal,\n    scratchStartFaceNormal\n  );\n  const endFaceNormal = computeMiteredNormal(\n    postEndRTC,\n    endRTC,\n    startRTC,\n    endEllipsoidNormal,\n    scratchEndFaceNormal\n  );\n\n  const startEllipsoidNormals = this.startEllipsoidNormals;\n  const endEllipsoidNormals = this.endEllipsoidNormals;\n  const startPositionAndHeights = this.startPositionAndHeights;\n  const startFaceNormalAndVertexCornerIds = this\n    .startFaceNormalAndVertexCornerIds;\n  const endPositionAndHeights = this.endPositionAndHeights;\n  const endFaceNormalAndHalfWidths = this.endFaceNormalAndHalfWidths;\n  const vertexBatchIds = this.vertexBatchIds;\n\n  let batchIdOffset = this.batchIdOffset;\n  let vec3Offset = this.vec3Offset;\n  let vec4Offset = this.vec4Offset;\n\n  let i;\n  for (i = 0; i < 8; i++) {\n    Cartesian3.pack(startEllipsoidNormal, startEllipsoidNormals, vec3Offset);\n    Cartesian3.pack(endEllipsoidNormal, endEllipsoidNormals, vec3Offset);\n\n    Cartesian3.pack(startRTC, startPositionAndHeights, vec4Offset);\n    startPositionAndHeights[vec4Offset + 3] = startHeight;\n\n    Cartesian3.pack(endRTC, endPositionAndHeights, vec4Offset);\n    endPositionAndHeights[vec4Offset + 3] = endHeight;\n\n    Cartesian3.pack(\n      startFaceNormal,\n      startFaceNormalAndVertexCornerIds,\n      vec4Offset\n    );\n    startFaceNormalAndVertexCornerIds[vec4Offset + 3] = i;\n\n    Cartesian3.pack(endFaceNormal, endFaceNormalAndHalfWidths, vec4Offset);\n    endFaceNormalAndHalfWidths[vec4Offset + 3] = halfWidth;\n\n    vertexBatchIds[batchIdOffset++] = batchId;\n\n    vec3Offset += 3;\n    vec4Offset += 4;\n  }\n\n  this.batchIdOffset = batchIdOffset;\n  this.vec3Offset = vec3Offset;\n  this.vec4Offset = vec4Offset;\n  const indices = this.indices;\n  const volumeStartIndex = this.volumeStartIndex;\n\n  const indexOffset = this.indexOffset;\n  for (i = 0; i < REFERENCE_INDICES_LENGTH; i++) {\n    indices[indexOffset + i] = REFERENCE_INDICES[i] + volumeStartIndex;\n  }\n\n  this.volumeStartIndex += 8;\n  this.indexOffset += REFERENCE_INDICES_LENGTH;\n};\n\nconst scratchRectangle = new Rectangle();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchCenter = new Cartesian3();\n\nconst scratchPrev = new Cartesian3();\nconst scratchP0 = new Cartesian3();\nconst scratchP1 = new Cartesian3();\nconst scratchNext = new Cartesian3();\nfunction createVectorTileClampedPolylines(parameters, transferableObjects) {\n  const encodedPositions = new Uint16Array(parameters.positions);\n  const widths = new Uint16Array(parameters.widths);\n  const counts = new Uint32Array(parameters.counts);\n  const batchIds = new Uint16Array(parameters.batchIds);\n\n  // Unpack tile decoding parameters\n  const rectangle = scratchRectangle;\n  const ellipsoid = scratchEllipsoid;\n  const center = scratchCenter;\n  const packedBuffer = new Float64Array(parameters.packedBuffer);\n\n  let offset = 0;\n  const minimumHeight = packedBuffer[offset++];\n  const maximumHeight = packedBuffer[offset++];\n\n  Rectangle.unpack(packedBuffer, offset, rectangle);\n  offset += Rectangle.packedLength;\n\n  Ellipsoid.unpack(packedBuffer, offset, ellipsoid);\n  offset += Ellipsoid.packedLength;\n\n  Cartesian3.unpack(packedBuffer, offset, center);\n\n  let i;\n\n  // Unpack positions and generate volumes\n  let positionsLength = encodedPositions.length / 3;\n  const uBuffer = encodedPositions.subarray(0, positionsLength);\n  const vBuffer = encodedPositions.subarray(\n    positionsLength,\n    2 * positionsLength\n  );\n  const heightBuffer = encodedPositions.subarray(\n    2 * positionsLength,\n    3 * positionsLength\n  );\n  AttributeCompression.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);\n\n  removeDuplicates(uBuffer, vBuffer, heightBuffer, counts);\n\n  // Figure out how many volumes and how many vertices there will be.\n  const countsLength = counts.length;\n  let volumesCount = 0;\n  for (i = 0; i < countsLength; i++) {\n    const polylinePositionCount = counts[i];\n    volumesCount += polylinePositionCount - 1;\n  }\n\n  const attribsAndIndices = new VertexAttributesAndIndices(volumesCount);\n\n  const positions = decodePositions(\n    uBuffer,\n    vBuffer,\n    heightBuffer,\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    ellipsoid,\n    center\n  );\n\n  positionsLength = uBuffer.length;\n  const positionsRTC = new Float32Array(positionsLength * 3);\n  for (i = 0; i < positionsLength; ++i) {\n    positionsRTC[i * 3] = positions[i * 3] - center.x;\n    positionsRTC[i * 3 + 1] = positions[i * 3 + 1] - center.y;\n    positionsRTC[i * 3 + 2] = positions[i * 3 + 2] - center.z;\n  }\n\n  let currentPositionIndex = 0;\n  let currentHeightIndex = 0;\n  for (i = 0; i < countsLength; i++) {\n    const polylineVolumeCount = counts[i] - 1;\n    const halfWidth = widths[i] * 0.5;\n    const batchId = batchIds[i];\n    const volumeFirstPositionIndex = currentPositionIndex;\n    for (let j = 0; j < polylineVolumeCount; j++) {\n      const volumeStart = Cartesian3.unpack(\n        positionsRTC,\n        currentPositionIndex,\n        scratchP0\n      );\n      const volumeEnd = Cartesian3.unpack(\n        positionsRTC,\n        currentPositionIndex + 3,\n        scratchP1\n      );\n\n      let startHeight = heightBuffer[currentHeightIndex];\n      let endHeight = heightBuffer[currentHeightIndex + 1];\n      startHeight = CesiumMath.lerp(\n        minimumHeight,\n        maximumHeight,\n        startHeight / MAX_SHORT\n      );\n      endHeight = CesiumMath.lerp(\n        minimumHeight,\n        maximumHeight,\n        endHeight / MAX_SHORT\n      );\n\n      currentHeightIndex++;\n\n      let preStart = scratchPrev;\n      let postEnd = scratchNext;\n      if (j === 0) {\n        // Check if this volume is like a loop\n        const finalPositionIndex =\n          volumeFirstPositionIndex + polylineVolumeCount * 3;\n        const finalPosition = Cartesian3.unpack(\n          positionsRTC,\n          finalPositionIndex,\n          scratchPrev\n        );\n        if (Cartesian3.equals(finalPosition, volumeStart)) {\n          Cartesian3.unpack(positionsRTC, finalPositionIndex - 3, preStart);\n        } else {\n          const offsetPastStart = Cartesian3.subtract(\n            volumeStart,\n            volumeEnd,\n            scratchPrev\n          );\n          preStart = Cartesian3.add(offsetPastStart, volumeStart, scratchPrev);\n        }\n      } else {\n        Cartesian3.unpack(positionsRTC, currentPositionIndex - 3, preStart);\n      }\n\n      if (j === polylineVolumeCount - 1) {\n        // Check if this volume is like a loop\n        const firstPosition = Cartesian3.unpack(\n          positionsRTC,\n          volumeFirstPositionIndex,\n          scratchNext\n        );\n        if (Cartesian3.equals(firstPosition, volumeEnd)) {\n          Cartesian3.unpack(\n            positionsRTC,\n            volumeFirstPositionIndex + 3,\n            postEnd\n          );\n        } else {\n          const offsetPastEnd = Cartesian3.subtract(\n            volumeEnd,\n            volumeStart,\n            scratchNext\n          );\n          postEnd = Cartesian3.add(offsetPastEnd, volumeEnd, scratchNext);\n        }\n      } else {\n        Cartesian3.unpack(positionsRTC, currentPositionIndex + 6, postEnd);\n      }\n\n      attribsAndIndices.addVolume(\n        preStart,\n        volumeStart,\n        volumeEnd,\n        postEnd,\n        startHeight,\n        endHeight,\n        halfWidth,\n        batchId,\n        center,\n        ellipsoid\n      );\n\n      currentPositionIndex += 3;\n    }\n    currentPositionIndex += 3;\n    currentHeightIndex++;\n  }\n\n  const indices = attribsAndIndices.indices;\n\n  transferableObjects.push(attribsAndIndices.startEllipsoidNormals.buffer);\n  transferableObjects.push(attribsAndIndices.endEllipsoidNormals.buffer);\n  transferableObjects.push(attribsAndIndices.startPositionAndHeights.buffer);\n  transferableObjects.push(\n    attribsAndIndices.startFaceNormalAndVertexCornerIds.buffer\n  );\n  transferableObjects.push(attribsAndIndices.endPositionAndHeights.buffer);\n  transferableObjects.push(attribsAndIndices.endFaceNormalAndHalfWidths.buffer);\n  transferableObjects.push(attribsAndIndices.vertexBatchIds.buffer);\n  transferableObjects.push(indices.buffer);\n\n  let results = {\n    indexDatatype:\n      indices.BYTES_PER_ELEMENT === 2\n        ? IndexDatatype.UNSIGNED_SHORT\n        : IndexDatatype.UNSIGNED_INT,\n    startEllipsoidNormals: attribsAndIndices.startEllipsoidNormals.buffer,\n    endEllipsoidNormals: attribsAndIndices.endEllipsoidNormals.buffer,\n    startPositionAndHeights: attribsAndIndices.startPositionAndHeights.buffer,\n    startFaceNormalAndVertexCornerIds:\n      attribsAndIndices.startFaceNormalAndVertexCornerIds.buffer,\n    endPositionAndHeights: attribsAndIndices.endPositionAndHeights.buffer,\n    endFaceNormalAndHalfWidths:\n      attribsAndIndices.endFaceNormalAndHalfWidths.buffer,\n    vertexBatchIds: attribsAndIndices.vertexBatchIds.buffer,\n    indices: indices.buffer,\n  };\n\n  if (parameters.keepDecodedPositions) {\n    const positionOffsets = getPositionOffsets(counts);\n    transferableObjects.push(positions.buffer, positionOffsets.buffer);\n    results = combine(results, {\n      decodedPositions: positions.buffer,\n      decodedPositionOffsets: positionOffsets.buffer,\n    });\n  }\n\n  return results;\n}\nexport default createTaskProcessorWorker(createVectorTileClampedPolylines);\n"],"names":["MAX_SHORT","MITER_BREAK","Math","cos","CesiumMath","toRadians","scratchBVCartographic","Cartographic","scratchEncodedPosition","Cartesian3","previousCompressedCartographicScratch","currentCompressedCartographicScratch","VertexAttributesAndIndices","volumesCount","vertexCount","vec3Floats","vec4Floats","this","startEllipsoidNormals","Float32Array","endEllipsoidNormals","startPositionAndHeights","startFaceNormalAndVertexCornerIds","endPositionAndHeights","endFaceNormalAndHalfWidths","vertexBatchIds","Uint16Array","indices","IndexDatatype","createTypedArray","vec3Offset","vec4Offset","batchIdOffset","indexOffset","volumeStartIndex","towardCurrScratch","towardNextScratch","computeMiteredNormal","previousPosition","position","nextPosition","ellipsoidSurfaceNormal","result","towardNext","subtract","towardCurr","normalize","dot","multiplyByScalar","add","equals","ZERO","cross","REFERENCE_INDICES","REFERENCE_INDICES_LENGTH","length","positionScratch","scratchStartEllipsoidNormal","scratchStartFaceNormal","scratchEndEllipsoidNormal","scratchEndFaceNormal","prototype","addVolume","preStartRTC","startRTC","endRTC","postEndRTC","startHeight","endHeight","halfWidth","batchId","center","ellipsoid","startEllipsoidNormal","geodeticSurfaceNormal","endEllipsoidNormal","startFaceNormal","endFaceNormal","i","pack","scratchRectangle","Rectangle","scratchEllipsoid","Ellipsoid","scratchCenter","scratchPrev","scratchP0","scratchP1","scratchNext","createTaskProcessorWorker","parameters","transferableObjects","encodedPositions","positions","widths","counts","Uint32Array","batchIds","rectangle","packedBuffer","Float64Array","offset","minimumHeight","maximumHeight","unpack","packedLength","positionsLength","uBuffer","subarray","vBuffer","heightBuffer","AttributeCompression","zigZagDeltaDecode","countsLength","markRemoval","Uint8Array","previous","current","count","updatedCount","j","index","previousIndex","longitude","latitude","nextAvailableIndex","k","removeDuplicates","attribsAndIndices","decodedPositions","u","v","h","lon","lerp","west","east","lat","south","north","alt","cartographic","fromRadians","decodedPosition","cartographicToCartesian","decodePositions","positionsRTC","x","y","z","currentPositionIndex","currentHeightIndex","polylineVolumeCount","volumeFirstPositionIndex","volumeStart","volumeEnd","preStart","postEnd","finalPositionIndex","finalPosition","offsetPastStart","firstPosition","offsetPastEnd","push","buffer","results","indexDatatype","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","keepDecodedPositions","positionOffsets","getPositionOffsets","combine","decodedPositionOffsets"],"mappings":"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"}