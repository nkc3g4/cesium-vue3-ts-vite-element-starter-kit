{"version":3,"file":"arrayRemoveDuplicates-65de6756.js","sources":["../../../../Source/Core/arrayRemoveDuplicates.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\n\nconst removeDuplicatesEpsilon = CesiumMath.EPSILON10;\n\n/**\n * Removes adjacent duplicate values in an array of values.\n *\n * @param {Array.<*>} [values] The array of values.\n * @param {Function} equalsEpsilon Function to compare values with an epsilon. Boolean equalsEpsilon(left, right, epsilon).\n * @param {Boolean} [wrapAround=false] Compare the last value in the array against the first value. If they are equal, the last value is removed.\n * @param {Array.<Number>} [removedIndices=undefined] Store the indices that correspond to the duplicate items removed from the array, if there were any.\n * @returns {Array.<*>|undefined} A new array of values with no adjacent duplicate values or the input array if no duplicates were found.\n *\n * @example\n * // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0, 3.0, 3.0), (1.0, 1.0, 1.0)]\n * const values = [\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(3.0, 3.0, 3.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0)];\n * const nonDuplicatevalues = Cesium.PolylinePipeline.removeDuplicates(values, Cartesian3.equalsEpsilon);\n *\n * @example\n * // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0, 3.0, 3.0)]\n * const values = [\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(3.0, 3.0, 3.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0)];\n * const nonDuplicatevalues = Cesium.PolylinePipeline.removeDuplicates(values, Cartesian3.equalsEpsilon, true);\n *\n * @example\n * // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0, 3.0, 3.0)]\n * // removedIndices will be equal to [1, 3, 5]\n * const values = [\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(2.0, 2.0, 2.0),\n *     new Cesium.Cartesian3(3.0, 3.0, 3.0),\n *     new Cesium.Cartesian3(1.0, 1.0, 1.0)];\n * const nonDuplicatevalues = Cesium.PolylinePipeline.removeDuplicates(values, Cartesian3.equalsEpsilon, true);\n * @private\n */\nfunction arrayRemoveDuplicates(\n  values,\n  equalsEpsilon,\n  wrapAround,\n  removedIndices\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"equalsEpsilon\", equalsEpsilon);\n  //>>includeEnd('debug');\n\n  if (!defined(values)) {\n    return undefined;\n  }\n\n  wrapAround = defaultValue(wrapAround, false);\n  const storeRemovedIndices = defined(removedIndices);\n\n  const length = values.length;\n  if (length < 2) {\n    return values;\n  }\n\n  let i;\n  let v0 = values[0];\n  let v1;\n\n  // We only want to create a new array if there are duplicates in the array.\n  // As such, cleanedValues is undefined until it encounters the first duplicate, if it exists.\n  let cleanedValues;\n  let lastCleanIndex = 0;\n\n  // removedIndexLCI keeps track of where lastCleanIndex would be if it were sorted into the removedIndices array.\n  // In case of arrays such as [A, B, C, ..., A, A, A], removedIndices will not be sorted properly without this.\n  let removedIndexLCI = -1;\n\n  for (i = 1; i < length; ++i) {\n    v1 = values[i];\n    if (equalsEpsilon(v0, v1, removeDuplicatesEpsilon)) {\n      if (!defined(cleanedValues)) {\n        cleanedValues = values.slice(0, i);\n        lastCleanIndex = i - 1;\n        removedIndexLCI = 0;\n      }\n      if (storeRemovedIndices) {\n        removedIndices.push(i);\n      }\n    } else {\n      if (defined(cleanedValues)) {\n        cleanedValues.push(v1);\n        lastCleanIndex = i;\n        if (storeRemovedIndices) {\n          removedIndexLCI = removedIndices.length;\n        }\n      }\n      v0 = v1;\n    }\n  }\n\n  if (\n    wrapAround &&\n    equalsEpsilon(values[0], values[length - 1], removeDuplicatesEpsilon)\n  ) {\n    if (storeRemovedIndices) {\n      if (defined(cleanedValues)) {\n        removedIndices.splice(removedIndexLCI, 0, lastCleanIndex);\n      } else {\n        removedIndices.push(length - 1);\n      }\n    }\n\n    if (defined(cleanedValues)) {\n      cleanedValues.length -= 1;\n    } else {\n      cleanedValues = values.slice(0, -1);\n    }\n  }\n\n  return defined(cleanedValues) ? cleanedValues : values;\n}\n\nexport default arrayRemoveDuplicates;\n"],"names":["removeDuplicatesEpsilon","CesiumMath","EPSILON10","values","equalsEpsilon","wrapAround","removedIndices","Check","defined","defaultValue","storeRemovedIndices","length","i","v1","cleanedValues","v0","lastCleanIndex","removedIndexLCI","slice","push","splice"],"mappings":"8HAKA,MAAMA,EAA0BC,aAAWC,kCA4C3C,SACEC,EACAC,EACAC,EACAC,GAMA,GAHAC,QAAMC,QAAQ,gBAAiBJ,IAG1BI,UAAQL,GACX,OAGFE,EAAaI,eAAaJ,GAAY,GACtC,MAAMK,EAAsBF,UAAQF,GAE9BK,EAASR,EAAOQ,OACtB,GAAIA,EAAS,EACX,OAAOR,EAGT,IAAIS,EAEAC,EAIAC,EALAC,EAAKZ,EAAO,GAMZa,EAAiB,EAIjBC,GAAmB,EAEvB,IAAKL,EAAI,EAAGA,EAAID,IAAUC,EACxBC,EAAKV,EAAOS,GACRR,EAAcW,EAAIF,EAAIb,IACnBQ,UAAQM,KACXA,EAAgBX,EAAOe,MAAM,EAAGN,GAChCI,EAAiBJ,EAAI,EACrBK,EAAkB,GAEhBP,GACFJ,EAAea,KAAKP,KAGlBJ,UAAQM,KACVA,EAAcK,KAAKN,GACnBG,EAAiBJ,EACbF,IACFO,EAAkBX,EAAeK,SAGrCI,EAAKF,GAuBT,OAlBER,GACAD,EAAcD,EAAO,GAAIA,EAAOQ,EAAS,GAAIX,KAEzCU,IACEF,UAAQM,GACVR,EAAec,OAAOH,EAAiB,EAAGD,GAE1CV,EAAea,KAAKR,EAAS,IAI7BH,UAAQM,GACVA,EAAcH,QAAU,EAExBG,EAAgBX,EAAOe,MAAM,GAAI,IAI9BV,UAAQM,GAAiBA,EAAgBX"}