define(["./when-4bbc8319","./Matrix2-265d9610","./arrayRemoveDuplicates-65de6756","./BoundingRectangle-8f2409a1","./Transforms-8b90e17c","./ComponentDatatype-aad54330","./PolylineVolumeGeometryLibrary-738776c0","./RuntimeError-5b082e8f","./GeometryAttribute-4bcb785f","./GeometryAttributes-7827a6c2","./GeometryPipeline-e93f6439","./IndexDatatype-6739e544","./PolygonPipeline-5fd67ae2","./VertexFormat-07539138","./combine-e9466e32","./WebGLConstants-508b9636","./EllipsoidTangentPlane-f1a69a20","./AxisAlignedBoundingBox-2a0ca7ef","./IntersectionTests-596e31ec","./Plane-616c9c0a","./PolylinePipeline-b9913663","./EllipsoidGeodesic-ed024f16","./EllipsoidRhumbLine-d09d563f","./AttributeCompression-442278a0","./EncodedCartesian3-da8f96bc"],(function(e,t,n,o,i,r,a,l,s,p,c,d,u,y,m,g,f,h,b,E,P,v,_,k,w){"use strict";function L(n){const o=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).polylinePositions,i=n.shapePositions;if(!e.defined(o))throw new l.DeveloperError("options.polylinePositions is required.");if(!e.defined(i))throw new l.DeveloperError("options.shapePositions is required.");this._positions=o,this._shape=i,this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84)),this._cornerType=e.defaultValue(n.cornerType,a.CornerType.ROUNDED),this._vertexFormat=y.VertexFormat.clone(e.defaultValue(n.vertexFormat,y.VertexFormat.DEFAULT)),this._granularity=e.defaultValue(n.granularity,r.CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";let s=1+o.length*t.Cartesian3.packedLength;s+=1+i.length*t.Cartesian2.packedLength,this.packedLength=s+t.Ellipsoid.packedLength+y.VertexFormat.packedLength+2}L.pack=function(n,o,i){if(!e.defined(n))throw new l.DeveloperError("value is required");if(!e.defined(o))throw new l.DeveloperError("array is required");let r;i=e.defaultValue(i,0);const a=n._positions;let s=a.length;for(o[i++]=s,r=0;r<s;++r,i+=t.Cartesian3.packedLength)t.Cartesian3.pack(a[r],o,i);const p=n._shape;for(s=p.length,o[i++]=s,r=0;r<s;++r,i+=t.Cartesian2.packedLength)t.Cartesian2.pack(p[r],o,i);return t.Ellipsoid.pack(n._ellipsoid,o,i),i+=t.Ellipsoid.packedLength,y.VertexFormat.pack(n._vertexFormat,o,i),i+=y.VertexFormat.packedLength,o[i++]=n._cornerType,o[i]=n._granularity,o};const V=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),x=new y.VertexFormat,C={polylinePositions:void 0,shapePositions:void 0,ellipsoid:V,vertexFormat:x,cornerType:void 0,granularity:void 0};L.unpack=function(n,o,i){if(!e.defined(n))throw new l.DeveloperError("array is required");let r;o=e.defaultValue(o,0);let a=n[o++];const s=new Array(a);for(r=0;r<a;++r,o+=t.Cartesian3.packedLength)s[r]=t.Cartesian3.unpack(n,o);a=n[o++];const p=new Array(a);for(r=0;r<a;++r,o+=t.Cartesian2.packedLength)p[r]=t.Cartesian2.unpack(n,o);const c=t.Ellipsoid.unpack(n,o,V);o+=t.Ellipsoid.packedLength;const d=y.VertexFormat.unpack(n,o,x);o+=y.VertexFormat.packedLength;const u=n[o++],m=n[o];return e.defined(i)?(i._positions=s,i._shape=p,i._ellipsoid=t.Ellipsoid.clone(c,i._ellipsoid),i._vertexFormat=y.VertexFormat.clone(d,i._vertexFormat),i._cornerType=u,i._granularity=m,i):(C.polylinePositions=s,C.shapePositions=p,C.cornerType=u,C.granularity=m,new L(C))};const D=new o.BoundingRectangle;return L.createGeometry=function(e){const l=e._positions,y=n.arrayRemoveDuplicates(l,t.Cartesian3.equalsEpsilon);let m=e._shape;if(m=a.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(m),y.length<2||m.length<3)return;u.PolygonPipeline.computeWindingOrder2D(m)===u.WindingOrder.CLOCKWISE&&m.reverse();const g=o.BoundingRectangle.fromPoints(m,D);return function(e,t,n,o){const l=new p.GeometryAttributes;o.position&&(l.position=new s.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e}));const y=t.length,m=e.length/3,g=(m-2*y)/(2*y),f=u.PolygonPipeline.triangulate(t),h=(g-1)*y*6+2*f.length,b=d.IndexDatatype.createTypedArray(m,h);let E,P,v,_,k,w;const L=2*y;let V=0;for(E=0;E<g-1;E++){for(P=0;P<y-1;P++)v=2*P+E*y*2,w=v+L,_=v+1,k=_+L,b[V++]=_,b[V++]=v,b[V++]=k,b[V++]=k,b[V++]=v,b[V++]=w;v=2*y-2+E*y*2,_=v+1,k=_+L,w=v+L,b[V++]=_,b[V++]=v,b[V++]=k,b[V++]=k,b[V++]=v,b[V++]=w}if(o.st||o.tangent||o.bitangent){const e=new Float32Array(2*m),o=1/(g-1),i=1/n.height,a=n.height/2;let p,c,d=0;for(E=0;E<g;E++){for(p=E*o,c=i*(t[0].y+a),e[d++]=p,e[d++]=c,P=1;P<y;P++)c=i*(t[P].y+a),e[d++]=p,e[d++]=c,e[d++]=p,e[d++]=c;c=i*(t[0].y+a),e[d++]=p,e[d++]=c}for(P=0;P<y;P++)p=0,c=i*(t[P].y+a),e[d++]=p,e[d++]=c;for(P=0;P<y;P++)p=(g-1)*o,c=i*(t[P].y+a),e[d++]=p,e[d++]=c;l.st=new s.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array(e)})}const x=m-2*y;for(E=0;E<f.length;E+=3){const e=f[E]+x,t=f[E+1]+x,n=f[E+2]+x;b[V++]=e,b[V++]=t,b[V++]=n,b[V++]=n+y,b[V++]=t+y,b[V++]=e+y}let C=new s.Geometry({attributes:l,indices:b,boundingSphere:i.BoundingSphere.fromVertices(e),primitiveType:s.PrimitiveType.TRIANGLES});if(o.normal&&(C=c.GeometryPipeline.computeNormal(C)),o.tangent||o.bitangent){try{C=c.GeometryPipeline.computeTangentAndBitangent(C)}catch(e){a.oneTimeWarning("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}o.tangent||(C.attributes.tangent=void 0),o.bitangent||(C.attributes.bitangent=void 0),o.st||(C.attributes.st=void 0)}return C}(a.PolylineVolumeGeometryLibrary.computePositions(y,m,g,e,!0),m,g,e._vertexFormat)},function(n,o){return e.defined(o)&&(n=L.unpack(n,o)),n._ellipsoid=t.Ellipsoid.clone(n._ellipsoid),L.createGeometry(n)}}));
//# sourceMappingURL=createPolylineVolumeGeometry.js.map
