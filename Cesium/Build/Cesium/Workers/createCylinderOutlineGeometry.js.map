{"version":3,"file":"createCylinderOutlineGeometry.js","sources":["../../../../Source/Core/CylinderOutlineGeometry.js","../../../../Source/WorkersES6/createCylinderOutlineGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst radiusScratch = new Cartesian2();\n\n/**\n * A description of the outline of a cylinder.\n *\n * @alias CylinderOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.length The length of the cylinder.\n * @param {Number} options.topRadius The radius of the top of the cylinder.\n * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surfaces of the cylinder.\n *\n * @exception {DeveloperError} options.length must be greater than 0.\n * @exception {DeveloperError} options.topRadius must be greater than 0.\n * @exception {DeveloperError} options.bottomRadius must be greater than 0.\n * @exception {DeveloperError} bottomRadius and topRadius cannot both equal 0.\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n *\n * @see CylinderOutlineGeometry.createGeometry\n *\n * @example\n * // create cylinder geometry\n * const cylinder = new Cesium.CylinderOutlineGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * const geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);\n */\nfunction CylinderOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const length = options.length;\n  const topRadius = options.topRadius;\n  const bottomRadius = options.bottomRadius;\n  const slices = defaultValue(options.slices, 128);\n  const numberOfVerticalLines = Math.max(\n    defaultValue(options.numberOfVerticalLines, 16),\n    0\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.positions\", length);\n  Check.typeOf.number(\"options.topRadius\", topRadius);\n  Check.typeOf.number(\"options.bottomRadius\", bottomRadius);\n  Check.typeOf.number.greaterThanOrEquals(\"options.slices\", slices, 3);\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._length = length;\n  this._topRadius = topRadius;\n  this._bottomRadius = bottomRadius;\n  this._slices = slices;\n  this._numberOfVerticalLines = numberOfVerticalLines;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCylinderOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCylinderOutlineGeometry.packedLength = 6;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CylinderOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCylinderOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value._length;\n  array[startingIndex++] = value._topRadius;\n  array[startingIndex++] = value._bottomRadius;\n  array[startingIndex++] = value._slices;\n  array[startingIndex++] = value._numberOfVerticalLines;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchOptions = {\n  length: undefined,\n  topRadius: undefined,\n  bottomRadius: undefined,\n  slices: undefined,\n  numberOfVerticalLines: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CylinderOutlineGeometry} [result] The object into which to store the result.\n * @returns {CylinderOutlineGeometry} The modified result parameter or a new CylinderOutlineGeometry instance if one was not provided.\n */\nCylinderOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const length = array[startingIndex++];\n  const topRadius = array[startingIndex++];\n  const bottomRadius = array[startingIndex++];\n  const slices = array[startingIndex++];\n  const numberOfVerticalLines = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.length = length;\n    scratchOptions.topRadius = topRadius;\n    scratchOptions.bottomRadius = bottomRadius;\n    scratchOptions.slices = slices;\n    scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CylinderOutlineGeometry(scratchOptions);\n  }\n\n  result._length = length;\n  result._topRadius = topRadius;\n  result._bottomRadius = bottomRadius;\n  result._slices = slices;\n  result._numberOfVerticalLines = numberOfVerticalLines;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.\n *\n * @param {CylinderOutlineGeometry} cylinderGeometry A description of the cylinder outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCylinderOutlineGeometry.createGeometry = function (cylinderGeometry) {\n  let length = cylinderGeometry._length;\n  const topRadius = cylinderGeometry._topRadius;\n  const bottomRadius = cylinderGeometry._bottomRadius;\n  const slices = cylinderGeometry._slices;\n  const numberOfVerticalLines = cylinderGeometry._numberOfVerticalLines;\n\n  if (\n    length <= 0 ||\n    topRadius < 0 ||\n    bottomRadius < 0 ||\n    (topRadius === 0 && bottomRadius === 0)\n  ) {\n    return;\n  }\n\n  const numVertices = slices * 2;\n\n  const positions = CylinderGeometryLibrary.computePositions(\n    length,\n    topRadius,\n    bottomRadius,\n    slices,\n    false\n  );\n  let numIndices = slices * 2;\n  let numSide;\n  if (numberOfVerticalLines > 0) {\n    const numSideLines = Math.min(numberOfVerticalLines, slices);\n    numSide = Math.round(slices / numSideLines);\n    numIndices += numSideLines;\n  }\n\n  const indices = IndexDatatype.createTypedArray(numVertices, numIndices * 2);\n  let index = 0;\n  let i;\n  for (i = 0; i < slices - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n    indices[index++] = i + slices;\n    indices[index++] = i + 1 + slices;\n  }\n\n  indices[index++] = slices - 1;\n  indices[index++] = 0;\n  indices[index++] = slices + slices - 1;\n  indices[index++] = slices;\n\n  if (numberOfVerticalLines > 0) {\n    for (i = 0; i < slices; i += numSide) {\n      indices[index++] = i;\n      indices[index++] = i + slices;\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n\n  radiusScratch.x = length * 0.5;\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n  const boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    Cartesian2.magnitude(radiusScratch)\n  );\n\n  if (defined(cylinderGeometry._offsetAttribute)) {\n    length = positions.length;\n    const applyOffset = new Uint8Array(length / 3);\n    const offsetValue =\n      cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: cylinderGeometry._offsetAttribute,\n  });\n};\nexport default CylinderOutlineGeometry;\n","import CylinderOutlineGeometry from \"../Core/CylinderOutlineGeometry.js\";\nimport defined from \"../Core/defined.js\";\n\nfunction createCylinderOutlineGeometry(cylinderGeometry, offset) {\n  if (defined(offset)) {\n    cylinderGeometry = CylinderOutlineGeometry.unpack(cylinderGeometry, offset);\n  }\n  return CylinderOutlineGeometry.createGeometry(cylinderGeometry);\n}\nexport default createCylinderOutlineGeometry;\n"],"names":["radiusScratch","Cartesian2","CylinderOutlineGeometry","options","length","defaultValue","EMPTY_OBJECT","topRadius","bottomRadius","slices","numberOfVerticalLines","Math","max","Check","typeOf","number","greaterThanOrEquals","defined","offsetAttribute","GeometryOffsetAttribute","TOP","DeveloperError","this","_length","_topRadius","_bottomRadius","_slices","_numberOfVerticalLines","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","object","scratchOptions","undefined","unpack","result","createGeometry","cylinderGeometry","numVertices","positions","CylinderGeometryLibrary","computePositions","numSide","numIndices","numSideLines","min","round","indices","IndexDatatype","createTypedArray","i","index","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","x","y","boundingSphere","BoundingSphere","Cartesian3","ZERO","magnitude","applyOffset","Uint8Array","offsetValue","NONE","arrayFill","UNSIGNED_BYTE","Geometry","primitiveType","PrimitiveType","LINES","offset"],"mappings":"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"}