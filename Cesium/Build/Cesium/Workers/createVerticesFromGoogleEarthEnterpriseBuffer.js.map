{"version":3,"file":"createVerticesFromGoogleEarthEnterpriseBuffer.js","sources":["../../../../Source/WorkersES6/createVerticesFromGoogleEarthEnterpriseBuffer.js"],"sourcesContent":["import AxisAlignedBoundingBox from \"../Core/AxisAlignedBoundingBox.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidalOccluder from \"../Core/EllipsoidalOccluder.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport createTaskProcessorWorker from \"./createTaskProcessorWorker.js\";\n\nconst sizeOfUint16 = Uint16Array.BYTES_PER_ELEMENT;\nconst sizeOfInt32 = Int32Array.BYTES_PER_ELEMENT;\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\nconst sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;\nconst sizeOfDouble = Float64Array.BYTES_PER_ELEMENT;\n\nfunction indexOfEpsilon(arr, elem, elemType) {\n  elemType = defaultValue(elemType, CesiumMath);\n  const count = arr.length;\n  for (let i = 0; i < count; ++i) {\n    if (elemType.equalsEpsilon(arr[i], elem, CesiumMath.EPSILON12)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction createVerticesFromGoogleEarthEnterpriseBuffer(\n  parameters,\n  transferableObjects\n) {\n  parameters.ellipsoid = Ellipsoid.clone(parameters.ellipsoid);\n  parameters.rectangle = Rectangle.clone(parameters.rectangle);\n\n  const statistics = processBuffer(\n    parameters.buffer,\n    parameters.relativeToCenter,\n    parameters.ellipsoid,\n    parameters.rectangle,\n    parameters.nativeRectangle,\n    parameters.exaggeration,\n    parameters.exaggerationRelativeHeight,\n    parameters.skirtHeight,\n    parameters.includeWebMercatorT,\n    parameters.negativeAltitudeExponentBias,\n    parameters.negativeElevationThreshold\n  );\n  const vertices = statistics.vertices;\n  transferableObjects.push(vertices.buffer);\n  const indices = statistics.indices;\n  transferableObjects.push(indices.buffer);\n\n  return {\n    vertices: vertices.buffer,\n    indices: indices.buffer,\n    numberOfAttributes: statistics.encoding.stride,\n    minimumHeight: statistics.minimumHeight,\n    maximumHeight: statistics.maximumHeight,\n    boundingSphere3D: statistics.boundingSphere3D,\n    orientedBoundingBox: statistics.orientedBoundingBox,\n    occludeePointInScaledSpace: statistics.occludeePointInScaledSpace,\n    encoding: statistics.encoding,\n    vertexCountWithoutSkirts: statistics.vertexCountWithoutSkirts,\n    indexCountWithoutSkirts: statistics.indexCountWithoutSkirts,\n    westIndicesSouthToNorth: statistics.westIndicesSouthToNorth,\n    southIndicesEastToWest: statistics.southIndicesEastToWest,\n    eastIndicesNorthToSouth: statistics.eastIndicesNorthToSouth,\n    northIndicesWestToEast: statistics.northIndicesWestToEast,\n  };\n}\n\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian = new Cartesian3();\nconst minimumScratch = new Cartesian3();\nconst maximumScratch = new Cartesian3();\nconst matrix4Scratch = new Matrix4();\n\nfunction processBuffer(\n  buffer,\n  relativeToCenter,\n  ellipsoid,\n  rectangle,\n  nativeRectangle,\n  exaggeration,\n  exaggerationRelativeHeight,\n  skirtHeight,\n  includeWebMercatorT,\n  negativeAltitudeExponentBias,\n  negativeElevationThreshold\n) {\n  let geographicWest;\n  let geographicSouth;\n  let geographicEast;\n  let geographicNorth;\n  let rectangleWidth, rectangleHeight;\n\n  if (!defined(rectangle)) {\n    geographicWest = CesiumMath.toRadians(nativeRectangle.west);\n    geographicSouth = CesiumMath.toRadians(nativeRectangle.south);\n    geographicEast = CesiumMath.toRadians(nativeRectangle.east);\n    geographicNorth = CesiumMath.toRadians(nativeRectangle.north);\n    rectangleWidth = CesiumMath.toRadians(rectangle.width);\n    rectangleHeight = CesiumMath.toRadians(rectangle.height);\n  } else {\n    geographicWest = rectangle.west;\n    geographicSouth = rectangle.south;\n    geographicEast = rectangle.east;\n    geographicNorth = rectangle.north;\n    rectangleWidth = rectangle.width;\n    rectangleHeight = rectangle.height;\n  }\n\n  // Keep track of quad borders so we can remove duplicates around the borders\n  const quadBorderLatitudes = [geographicSouth, geographicNorth];\n  const quadBorderLongitudes = [geographicWest, geographicEast];\n\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\n    relativeToCenter,\n    ellipsoid\n  );\n  const toENU = Matrix4.inverseTransformation(fromENU, matrix4Scratch);\n\n  let southMercatorY;\n  let oneOverMercatorHeight;\n  if (includeWebMercatorT) {\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n      geographicSouth\n    );\n    oneOverMercatorHeight =\n      1.0 /\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicNorth) -\n        southMercatorY);\n  }\n\n  const hasExaggeration = exaggeration !== 1.0;\n  const includeGeodeticSurfaceNormals = hasExaggeration;\n\n  const dv = new DataView(buffer);\n\n  let minHeight = Number.POSITIVE_INFINITY;\n  let maxHeight = Number.NEGATIVE_INFINITY;\n\n  const minimum = minimumScratch;\n  minimum.x = Number.POSITIVE_INFINITY;\n  minimum.y = Number.POSITIVE_INFINITY;\n  minimum.z = Number.POSITIVE_INFINITY;\n\n  const maximum = maximumScratch;\n  maximum.x = Number.NEGATIVE_INFINITY;\n  maximum.y = Number.NEGATIVE_INFINITY;\n  maximum.z = Number.NEGATIVE_INFINITY;\n\n  // Compute sizes\n  let offset = 0;\n  let size = 0;\n  let indicesSize = 0;\n  let quadSize;\n  let quad;\n  for (quad = 0; quad < 4; ++quad) {\n    let o = offset;\n    quadSize = dv.getUint32(o, true);\n    o += sizeOfUint32;\n\n    const x = CesiumMath.toRadians(dv.getFloat64(o, true) * 180.0);\n    o += sizeOfDouble;\n    if (indexOfEpsilon(quadBorderLongitudes, x) === -1) {\n      quadBorderLongitudes.push(x);\n    }\n\n    const y = CesiumMath.toRadians(dv.getFloat64(o, true) * 180.0);\n    o += sizeOfDouble;\n    if (indexOfEpsilon(quadBorderLatitudes, y) === -1) {\n      quadBorderLatitudes.push(y);\n    }\n\n    o += 2 * sizeOfDouble; // stepX + stepY\n\n    let c = dv.getInt32(o, true); // Read point count\n    o += sizeOfInt32;\n    size += c;\n\n    c = dv.getInt32(o, true); // Read index count\n    indicesSize += c * 3;\n\n    offset += quadSize + sizeOfUint32; // Jump to next quad\n  }\n\n  // Quad Border points to remove duplicates\n  const quadBorderPoints = [];\n  const quadBorderIndices = [];\n\n  // Create arrays\n  const positions = new Array(size);\n  const uvs = new Array(size);\n  const heights = new Array(size);\n  const webMercatorTs = includeWebMercatorT ? new Array(size) : [];\n  const geodeticSurfaceNormals = includeGeodeticSurfaceNormals\n    ? new Array(size)\n    : [];\n  const indices = new Array(indicesSize);\n\n  // Points are laid out in rows starting at SW, so storing border points as we\n  //  come across them all points will be adjacent.\n  const westBorder = [];\n  const southBorder = [];\n  const eastBorder = [];\n  const northBorder = [];\n\n  // Each tile is split into 4 parts\n  let pointOffset = 0;\n  let indicesOffset = 0;\n  offset = 0;\n  for (quad = 0; quad < 4; ++quad) {\n    quadSize = dv.getUint32(offset, true);\n    offset += sizeOfUint32;\n    const startQuad = offset;\n\n    const originX = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n    offset += sizeOfDouble;\n\n    const originY = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n    offset += sizeOfDouble;\n\n    const stepX = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n    const halfStepX = stepX * 0.5;\n    offset += sizeOfDouble;\n\n    const stepY = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n    const halfStepY = stepY * 0.5;\n    offset += sizeOfDouble;\n\n    const numPoints = dv.getInt32(offset, true);\n    offset += sizeOfInt32;\n\n    const numFaces = dv.getInt32(offset, true);\n    offset += sizeOfInt32;\n\n    //const level = dv.getInt32(offset, true);\n    offset += sizeOfInt32;\n\n    // Keep track of quad indices to overall tile indices\n    const indicesMapping = new Array(numPoints);\n    for (let i = 0; i < numPoints; ++i) {\n      const longitude = originX + dv.getUint8(offset++) * stepX;\n      scratchCartographic.longitude = longitude;\n      const latitude = originY + dv.getUint8(offset++) * stepY;\n      scratchCartographic.latitude = latitude;\n\n      let height = dv.getFloat32(offset, true);\n      offset += sizeOfFloat;\n\n      // In order to support old clients, negative altitude values are stored as\n      // height/-2^32. Old clients see the value as really close to 0 but new clients multiply\n      // by -2^32 to get the real negative altitude value.\n      if (height !== 0 && height < negativeElevationThreshold) {\n        height *= -Math.pow(2, negativeAltitudeExponentBias);\n      }\n\n      // Height is stored in units of (1/EarthRadius) or (1/6371010.0)\n      height *= 6371010.0;\n\n      scratchCartographic.height = height;\n\n      // Is it along a quad border - if so check if already exists and use that index\n      if (\n        indexOfEpsilon(quadBorderLongitudes, longitude) !== -1 ||\n        indexOfEpsilon(quadBorderLatitudes, latitude) !== -1\n      ) {\n        const index = indexOfEpsilon(\n          quadBorderPoints,\n          scratchCartographic,\n          Cartographic\n        );\n        if (index === -1) {\n          quadBorderPoints.push(Cartographic.clone(scratchCartographic));\n          quadBorderIndices.push(pointOffset);\n        } else {\n          indicesMapping[i] = quadBorderIndices[index];\n          continue;\n        }\n      }\n      indicesMapping[i] = pointOffset;\n\n      if (Math.abs(longitude - geographicWest) < halfStepX) {\n        westBorder.push({\n          index: pointOffset,\n          cartographic: Cartographic.clone(scratchCartographic),\n        });\n      } else if (Math.abs(longitude - geographicEast) < halfStepX) {\n        eastBorder.push({\n          index: pointOffset,\n          cartographic: Cartographic.clone(scratchCartographic),\n        });\n      } else if (Math.abs(latitude - geographicSouth) < halfStepY) {\n        southBorder.push({\n          index: pointOffset,\n          cartographic: Cartographic.clone(scratchCartographic),\n        });\n      } else if (Math.abs(latitude - geographicNorth) < halfStepY) {\n        northBorder.push({\n          index: pointOffset,\n          cartographic: Cartographic.clone(scratchCartographic),\n        });\n      }\n\n      minHeight = Math.min(height, minHeight);\n      maxHeight = Math.max(height, maxHeight);\n      heights[pointOffset] = height;\n\n      const pos = ellipsoid.cartographicToCartesian(scratchCartographic);\n      positions[pointOffset] = pos;\n\n      if (includeWebMercatorT) {\n        webMercatorTs[pointOffset] =\n          (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) -\n            southMercatorY) *\n          oneOverMercatorHeight;\n      }\n\n      if (includeGeodeticSurfaceNormals) {\n        const normal = ellipsoid.geodeticSurfaceNormal(pos);\n        geodeticSurfaceNormals[pointOffset] = normal;\n      }\n\n      Matrix4.multiplyByPoint(toENU, pos, scratchCartesian);\n\n      Cartesian3.minimumByComponent(scratchCartesian, minimum, minimum);\n      Cartesian3.maximumByComponent(scratchCartesian, maximum, maximum);\n\n      let u = (longitude - geographicWest) / (geographicEast - geographicWest);\n      u = CesiumMath.clamp(u, 0.0, 1.0);\n      let v =\n        (latitude - geographicSouth) / (geographicNorth - geographicSouth);\n      v = CesiumMath.clamp(v, 0.0, 1.0);\n\n      uvs[pointOffset] = new Cartesian2(u, v);\n      ++pointOffset;\n    }\n\n    const facesElementCount = numFaces * 3;\n    for (let j = 0; j < facesElementCount; ++j, ++indicesOffset) {\n      indices[indicesOffset] = indicesMapping[dv.getUint16(offset, true)];\n      offset += sizeOfUint16;\n    }\n\n    if (quadSize !== offset - startQuad) {\n      throw new RuntimeError(\"Invalid terrain tile.\");\n    }\n  }\n\n  positions.length = pointOffset;\n  uvs.length = pointOffset;\n  heights.length = pointOffset;\n  if (includeWebMercatorT) {\n    webMercatorTs.length = pointOffset;\n  }\n  if (includeGeodeticSurfaceNormals) {\n    geodeticSurfaceNormals.length = pointOffset;\n  }\n\n  const vertexCountWithoutSkirts = pointOffset;\n  const indexCountWithoutSkirts = indicesOffset;\n\n  // Add skirt points\n  const skirtOptions = {\n    hMin: minHeight,\n    lastBorderPoint: undefined,\n    skirtHeight: skirtHeight,\n    toENU: toENU,\n    ellipsoid: ellipsoid,\n    minimum: minimum,\n    maximum: maximum,\n  };\n\n  // Sort counter clockwise from NW corner\n  // Corner points are in the east/west arrays\n  westBorder.sort(function (a, b) {\n    return b.cartographic.latitude - a.cartographic.latitude;\n  });\n  southBorder.sort(function (a, b) {\n    return a.cartographic.longitude - b.cartographic.longitude;\n  });\n  eastBorder.sort(function (a, b) {\n    return a.cartographic.latitude - b.cartographic.latitude;\n  });\n  northBorder.sort(function (a, b) {\n    return b.cartographic.longitude - a.cartographic.longitude;\n  });\n\n  const percentage = 0.00001;\n  addSkirt(\n    positions,\n    heights,\n    uvs,\n    webMercatorTs,\n    geodeticSurfaceNormals,\n    indices,\n    skirtOptions,\n    westBorder,\n    -percentage * rectangleWidth,\n    true,\n    -percentage * rectangleHeight\n  );\n  addSkirt(\n    positions,\n    heights,\n    uvs,\n    webMercatorTs,\n    geodeticSurfaceNormals,\n    indices,\n    skirtOptions,\n    southBorder,\n    -percentage * rectangleHeight,\n    false\n  );\n  addSkirt(\n    positions,\n    heights,\n    uvs,\n    webMercatorTs,\n    geodeticSurfaceNormals,\n    indices,\n    skirtOptions,\n    eastBorder,\n    percentage * rectangleWidth,\n    true,\n    percentage * rectangleHeight\n  );\n  addSkirt(\n    positions,\n    heights,\n    uvs,\n    webMercatorTs,\n    geodeticSurfaceNormals,\n    indices,\n    skirtOptions,\n    northBorder,\n    percentage * rectangleHeight,\n    false\n  );\n\n  // Since the corner between the north and west sides is in the west array, generate the last\n  //  two triangles between the last north vertex and the first west vertex\n  if (westBorder.length > 0 && northBorder.length > 0) {\n    const firstBorderIndex = westBorder[0].index;\n    const firstSkirtIndex = vertexCountWithoutSkirts;\n    const lastBorderIndex = northBorder[northBorder.length - 1].index;\n    const lastSkirtIndex = positions.length - 1;\n\n    indices.push(\n      lastBorderIndex,\n      lastSkirtIndex,\n      firstSkirtIndex,\n      firstSkirtIndex,\n      firstBorderIndex,\n      lastBorderIndex\n    );\n  }\n\n  size = positions.length; // Get new size with skirt vertices\n\n  const boundingSphere3D = BoundingSphere.fromPoints(positions);\n  let orientedBoundingBox;\n  if (defined(rectangle)) {\n    orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n      rectangle,\n      minHeight,\n      maxHeight,\n      ellipsoid\n    );\n  }\n\n  const occluder = new EllipsoidalOccluder(ellipsoid);\n  const occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n    relativeToCenter,\n    positions,\n    minHeight\n  );\n\n  const aaBox = new AxisAlignedBoundingBox(minimum, maximum, relativeToCenter);\n  const encoding = new TerrainEncoding(\n    relativeToCenter,\n    aaBox,\n    skirtOptions.hMin,\n    maxHeight,\n    fromENU,\n    false,\n    includeWebMercatorT,\n    includeGeodeticSurfaceNormals,\n    exaggeration,\n    exaggerationRelativeHeight\n  );\n  const vertices = new Float32Array(size * encoding.stride);\n\n  let bufferIndex = 0;\n  for (let k = 0; k < size; ++k) {\n    bufferIndex = encoding.encode(\n      vertices,\n      bufferIndex,\n      positions[k],\n      uvs[k],\n      heights[k],\n      undefined,\n      webMercatorTs[k],\n      geodeticSurfaceNormals[k]\n    );\n  }\n\n  const westIndicesSouthToNorth = westBorder\n    .map(function (vertex) {\n      return vertex.index;\n    })\n    .reverse();\n  const southIndicesEastToWest = southBorder\n    .map(function (vertex) {\n      return vertex.index;\n    })\n    .reverse();\n  const eastIndicesNorthToSouth = eastBorder\n    .map(function (vertex) {\n      return vertex.index;\n    })\n    .reverse();\n  const northIndicesWestToEast = northBorder\n    .map(function (vertex) {\n      return vertex.index;\n    })\n    .reverse();\n\n  southIndicesEastToWest.unshift(\n    eastIndicesNorthToSouth[eastIndicesNorthToSouth.length - 1]\n  );\n  southIndicesEastToWest.push(westIndicesSouthToNorth[0]);\n\n  northIndicesWestToEast.unshift(\n    westIndicesSouthToNorth[westIndicesSouthToNorth.length - 1]\n  );\n  northIndicesWestToEast.push(eastIndicesNorthToSouth[0]);\n\n  return {\n    vertices: vertices,\n    indices: new Uint16Array(indices),\n    maximumHeight: maxHeight,\n    minimumHeight: minHeight,\n    encoding: encoding,\n    boundingSphere3D: boundingSphere3D,\n    orientedBoundingBox: orientedBoundingBox,\n    occludeePointInScaledSpace: occludeePointInScaledSpace,\n    vertexCountWithoutSkirts: vertexCountWithoutSkirts,\n    indexCountWithoutSkirts: indexCountWithoutSkirts,\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\n    southIndicesEastToWest: southIndicesEastToWest,\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n    northIndicesWestToEast: northIndicesWestToEast,\n  };\n}\n\nfunction addSkirt(\n  positions,\n  heights,\n  uvs,\n  webMercatorTs,\n  geodeticSurfaceNormals,\n  indices,\n  skirtOptions,\n  borderPoints,\n  fudgeFactor,\n  eastOrWest,\n  cornerFudge\n) {\n  const count = borderPoints.length;\n  for (let j = 0; j < count; ++j) {\n    const borderPoint = borderPoints[j];\n    const borderCartographic = borderPoint.cartographic;\n    const borderIndex = borderPoint.index;\n    const currentIndex = positions.length;\n\n    const longitude = borderCartographic.longitude;\n    let latitude = borderCartographic.latitude;\n    latitude = CesiumMath.clamp(\n      latitude,\n      -CesiumMath.PI_OVER_TWO,\n      CesiumMath.PI_OVER_TWO\n    ); // Don't go over the poles\n    const height = borderCartographic.height - skirtOptions.skirtHeight;\n    skirtOptions.hMin = Math.min(skirtOptions.hMin, height);\n\n    Cartographic.fromRadians(longitude, latitude, height, scratchCartographic);\n\n    // Adjust sides to angle out\n    if (eastOrWest) {\n      scratchCartographic.longitude += fudgeFactor;\n    }\n\n    // Adjust top or bottom to angle out\n    // Since corners are in the east/west arrays angle the first and last points as well\n    if (!eastOrWest) {\n      scratchCartographic.latitude += fudgeFactor;\n    } else if (j === count - 1) {\n      scratchCartographic.latitude += cornerFudge;\n    } else if (j === 0) {\n      scratchCartographic.latitude -= cornerFudge;\n    }\n\n    const pos = skirtOptions.ellipsoid.cartographicToCartesian(\n      scratchCartographic\n    );\n    positions.push(pos);\n    heights.push(height);\n    uvs.push(Cartesian2.clone(uvs[borderIndex])); // Copy UVs from border point\n    if (webMercatorTs.length > 0) {\n      webMercatorTs.push(webMercatorTs[borderIndex]);\n    }\n    if (geodeticSurfaceNormals.length > 0) {\n      geodeticSurfaceNormals.push(geodeticSurfaceNormals[borderIndex]);\n    }\n\n    Matrix4.multiplyByPoint(skirtOptions.toENU, pos, scratchCartesian);\n\n    const minimum = skirtOptions.minimum;\n    const maximum = skirtOptions.maximum;\n    Cartesian3.minimumByComponent(scratchCartesian, minimum, minimum);\n    Cartesian3.maximumByComponent(scratchCartesian, maximum, maximum);\n\n    const lastBorderPoint = skirtOptions.lastBorderPoint;\n    if (defined(lastBorderPoint)) {\n      const lastBorderIndex = lastBorderPoint.index;\n      indices.push(\n        lastBorderIndex,\n        currentIndex - 1,\n        currentIndex,\n        currentIndex,\n        borderIndex,\n        lastBorderIndex\n      );\n    }\n\n    skirtOptions.lastBorderPoint = borderPoint;\n  }\n}\nexport default createTaskProcessorWorker(\n  createVerticesFromGoogleEarthEnterpriseBuffer\n);\n"],"names":["sizeOfUint16","Uint16Array","BYTES_PER_ELEMENT","sizeOfInt32","Int32Array","sizeOfUint32","Uint32Array","sizeOfFloat","Float32Array","sizeOfDouble","Float64Array","indexOfEpsilon","arr","elem","elemType","defaultValue","CesiumMath","count","length","i","equalsEpsilon","EPSILON12","scratchCartographic","Cartographic","scratchCartesian","Cartesian3","minimumScratch","maximumScratch","matrix4Scratch","Matrix4","addSkirt","positions","heights","uvs","webMercatorTs","geodeticSurfaceNormals","indices","skirtOptions","borderPoints","fudgeFactor","eastOrWest","cornerFudge","j","borderPoint","borderCartographic","cartographic","borderIndex","index","currentIndex","longitude","latitude","clamp","PI_OVER_TWO","height","skirtHeight","hMin","Math","min","fromRadians","pos","ellipsoid","cartographicToCartesian","push","Cartesian2","clone","multiplyByPoint","toENU","minimum","maximum","minimumByComponent","maximumByComponent","lastBorderPoint","defined","lastBorderIndex","createTaskProcessorWorker","parameters","transferableObjects","Ellipsoid","rectangle","Rectangle","statistics","buffer","relativeToCenter","nativeRectangle","exaggeration","exaggerationRelativeHeight","includeWebMercatorT","negativeAltitudeExponentBias","negativeElevationThreshold","geographicWest","geographicSouth","geographicEast","geographicNorth","rectangleWidth","rectangleHeight","west","south","east","north","width","toRadians","quadBorderLatitudes","quadBorderLongitudes","fromENU","Transforms","eastNorthUpToFixedFrame","inverseTransformation","southMercatorY","oneOverMercatorHeight","WebMercatorProjection","geodeticLatitudeToMercatorAngle","includeGeodeticSurfaceNormals","dv","DataView","minHeight","Number","POSITIVE_INFINITY","maxHeight","NEGATIVE_INFINITY","x","y","z","quadSize","quad","offset","size","indicesSize","o","getUint32","getFloat64","c","getInt32","quadBorderPoints","quadBorderIndices","Array","westBorder","southBorder","eastBorder","northBorder","pointOffset","indicesOffset","startQuad","originX","originY","stepX","halfStepX","stepY","halfStepY","numPoints","numFaces","indicesMapping","getUint8","getFloat32","pow","abs","max","normal","geodeticSurfaceNormal","u","v","facesElementCount","getUint16","RuntimeError","vertexCountWithoutSkirts","indexCountWithoutSkirts","undefined","sort","a","b","percentage","firstBorderIndex","firstSkirtIndex","lastSkirtIndex","boundingSphere3D","BoundingSphere","fromPoints","orientedBoundingBox","OrientedBoundingBox","fromRectangle","occludeePointInScaledSpace","EllipsoidalOccluder","computeHorizonCullingPointPossiblyUnderEllipsoid","aaBox","AxisAlignedBoundingBox","encoding","TerrainEncoding","vertices","stride","bufferIndex","k","encode","westIndicesSouthToNorth","map","vertex","reverse","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","unshift","maximumHeight","minimumHeight","processBuffer","numberOfAttributes"],"mappings":"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"}