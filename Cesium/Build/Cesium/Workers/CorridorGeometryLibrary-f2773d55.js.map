{"version":3,"file":"CorridorGeometryLibrary-f2773d55.js","sources":["../../../../Source/Core/CorridorGeometryLibrary.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport CornerType from \"./CornerType.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\nimport Quaternion from \"./Quaternion.js\";\n\n/**\n * @private\n */\nconst CorridorGeometryLibrary = {};\n\nconst scratch1 = new Cartesian3();\nconst scratch2 = new Cartesian3();\nconst scratch3 = new Cartesian3();\nconst scratch4 = new Cartesian3();\n\nconst scaleArray2 = [new Cartesian3(), new Cartesian3()];\n\nconst cartesian1 = new Cartesian3();\nconst cartesian2 = new Cartesian3();\nconst cartesian3 = new Cartesian3();\nconst cartesian4 = new Cartesian3();\nconst cartesian5 = new Cartesian3();\nconst cartesian6 = new Cartesian3();\nconst cartesian7 = new Cartesian3();\nconst cartesian8 = new Cartesian3();\nconst cartesian9 = new Cartesian3();\nconst cartesian10 = new Cartesian3();\n\nconst quaterion = new Quaternion();\nconst rotMatrix = new Matrix3();\nfunction computeRoundCorner(\n  cornerPoint,\n  startPoint,\n  endPoint,\n  cornerType,\n  leftIsOutside\n) {\n  const angle = Cartesian3.angleBetween(\n    Cartesian3.subtract(startPoint, cornerPoint, scratch1),\n    Cartesian3.subtract(endPoint, cornerPoint, scratch2)\n  );\n  const granularity =\n    cornerType === CornerType.BEVELED\n      ? 1\n      : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\n\n  const size = granularity * 3;\n  const array = new Array(size);\n\n  array[size - 3] = endPoint.x;\n  array[size - 2] = endPoint.y;\n  array[size - 1] = endPoint.z;\n\n  let m;\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(\n        Cartesian3.negate(cornerPoint, scratch1),\n        angle / granularity,\n        quaterion\n      ),\n      rotMatrix\n    );\n  } else {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion),\n      rotMatrix\n    );\n  }\n\n  let index = 0;\n  startPoint = Cartesian3.clone(startPoint, scratch1);\n  for (let i = 0; i < granularity; i++) {\n    startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n    array[index++] = startPoint.x;\n    array[index++] = startPoint.y;\n    array[index++] = startPoint.z;\n  }\n\n  return array;\n}\n\nfunction addEndCaps(calculatedPositions) {\n  let cornerPoint = cartesian1;\n  let startPoint = cartesian2;\n  let endPoint = cartesian3;\n\n  let leftEdge = calculatedPositions[1];\n  startPoint = Cartesian3.fromArray(\n    calculatedPositions[1],\n    leftEdge.length - 3,\n    startPoint\n  );\n  endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  const firstEndCap = computeRoundCorner(\n    cornerPoint,\n    startPoint,\n    endPoint,\n    CornerType.ROUNDED,\n    false\n  );\n\n  const length = calculatedPositions.length - 1;\n  const rightEdge = calculatedPositions[length - 1];\n  leftEdge = calculatedPositions[length];\n  startPoint = Cartesian3.fromArray(\n    rightEdge,\n    rightEdge.length - 3,\n    startPoint\n  );\n  endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  const lastEndCap = computeRoundCorner(\n    cornerPoint,\n    startPoint,\n    endPoint,\n    CornerType.ROUNDED,\n    false\n  );\n\n  return [firstEndCap, lastEndCap];\n}\n\nfunction computeMiteredCorner(\n  position,\n  leftCornerDirection,\n  lastPoint,\n  leftIsOutside\n) {\n  let cornerPoint = scratch1;\n  if (leftIsOutside) {\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  } else {\n    leftCornerDirection = Cartesian3.negate(\n      leftCornerDirection,\n      leftCornerDirection\n    );\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  }\n  return [\n    cornerPoint.x,\n    cornerPoint.y,\n    cornerPoint.z,\n    lastPoint.x,\n    lastPoint.y,\n    lastPoint.z,\n  ];\n}\n\nfunction addShiftedPositions(positions, left, scalar, calculatedPositions) {\n  const rightPositions = new Array(positions.length);\n  const leftPositions = new Array(positions.length);\n  const scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\n  const scaledRight = Cartesian3.negate(scaledLeft, scratch2);\n  let rightIndex = 0;\n  let leftIndex = positions.length - 1;\n\n  for (let i = 0; i < positions.length; i += 3) {\n    const pos = Cartesian3.fromArray(positions, i, scratch3);\n    const rightPos = Cartesian3.add(pos, scaledRight, scratch4);\n    rightPositions[rightIndex++] = rightPos.x;\n    rightPositions[rightIndex++] = rightPos.y;\n    rightPositions[rightIndex++] = rightPos.z;\n\n    const leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\n    leftPositions[leftIndex--] = leftPos.z;\n    leftPositions[leftIndex--] = leftPos.y;\n    leftPositions[leftIndex--] = leftPos.x;\n  }\n  calculatedPositions.push(rightPositions, leftPositions);\n\n  return calculatedPositions;\n}\n\n/**\n * @private\n */\nCorridorGeometryLibrary.addAttribute = function (\n  attribute,\n  value,\n  front,\n  back\n) {\n  const x = value.x;\n  const y = value.y;\n  const z = value.z;\n  if (defined(front)) {\n    attribute[front] = x;\n    attribute[front + 1] = y;\n    attribute[front + 2] = z;\n  }\n  if (defined(back)) {\n    attribute[back] = z;\n    attribute[back - 1] = y;\n    attribute[back - 2] = x;\n  }\n};\n\nconst scratchForwardProjection = new Cartesian3();\nconst scratchBackwardProjection = new Cartesian3();\n\n/**\n * @private\n */\nCorridorGeometryLibrary.computePositions = function (params) {\n  const granularity = params.granularity;\n  const positions = params.positions;\n  const ellipsoid = params.ellipsoid;\n  const width = params.width / 2;\n  const cornerType = params.cornerType;\n  const saveAttributes = params.saveAttributes;\n  let normal = cartesian1;\n  let forward = cartesian2;\n  let backward = cartesian3;\n  let left = cartesian4;\n  let cornerDirection = cartesian5;\n  let startPoint = cartesian6;\n  let previousPos = cartesian7;\n  let rightPos = cartesian8;\n  let leftPos = cartesian9;\n  let center = cartesian10;\n  let calculatedPositions = [];\n  const calculatedLefts = saveAttributes ? [] : undefined;\n  const calculatedNormals = saveAttributes ? [] : undefined;\n  let position = positions[0]; //add first point\n  let nextPosition = positions[1];\n\n  forward = Cartesian3.normalize(\n    Cartesian3.subtract(nextPosition, position, forward),\n    forward\n  );\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n  previousPos = Cartesian3.clone(position, previousPos);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n\n  let subdividedPositions;\n  const corners = [];\n  let i;\n  const length = positions.length;\n  for (i = 1; i < length - 1; i++) {\n    // add middle points and corners\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n    nextPosition = positions[i + 1];\n    forward = Cartesian3.normalize(\n      Cartesian3.subtract(nextPosition, position, forward),\n      forward\n    );\n    cornerDirection = Cartesian3.normalize(\n      Cartesian3.add(forward, backward, cornerDirection),\n      cornerDirection\n    );\n\n    const forwardProjection = Cartesian3.multiplyByScalar(\n      normal,\n      Cartesian3.dot(forward, normal),\n      scratchForwardProjection\n    );\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n\n    const backwardProjection = Cartesian3.multiplyByScalar(\n      normal,\n      Cartesian3.dot(backward, normal),\n      scratchBackwardProjection\n    );\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n\n    const doCorner = !CesiumMath.equalsEpsilon(\n      Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)),\n      1.0,\n      CesiumMath.EPSILON7\n    );\n\n    if (doCorner) {\n      cornerDirection = Cartesian3.cross(\n        cornerDirection,\n        normal,\n        cornerDirection\n      );\n      cornerDirection = Cartesian3.cross(\n        normal,\n        cornerDirection,\n        cornerDirection\n      );\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      const scalar =\n        width /\n        Math.max(\n          0.25,\n          Cartesian3.magnitude(\n            Cartesian3.cross(cornerDirection, backward, scratch1)\n          )\n        );\n      const leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(\n        forward,\n        backward,\n        position,\n        ellipsoid\n      );\n      cornerDirection = Cartesian3.multiplyByScalar(\n        cornerDirection,\n        scalar,\n        cornerDirection\n      );\n      if (leftIsOutside) {\n        rightPos = Cartesian3.add(position, cornerDirection, rightPos);\n        center = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width, center),\n          center\n        );\n        leftPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\n          leftPos\n        );\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        calculatedPositions = addShiftedPositions(\n          subdividedPositions,\n          left,\n          width,\n          calculatedPositions\n        );\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        startPoint = Cartesian3.clone(leftPos, startPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.cross(normal, forward, left),\n          left\n        );\n        leftPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\n          leftPos\n        );\n        previousPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width, previousPos),\n          previousPos\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          corners.push({\n            leftPositions: computeRoundCorner(\n              rightPos,\n              startPoint,\n              leftPos,\n              cornerType,\n              leftIsOutside\n            ),\n          });\n        } else {\n          corners.push({\n            leftPositions: computeMiteredCorner(\n              position,\n              Cartesian3.negate(cornerDirection, cornerDirection),\n              leftPos,\n              leftIsOutside\n            ),\n          });\n        }\n      } else {\n        leftPos = Cartesian3.add(position, cornerDirection, leftPos);\n        center = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width, center),\n            center\n          ),\n          center\n        );\n        rightPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\n            rightPos\n          ),\n          rightPos\n        );\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        calculatedPositions = addShiftedPositions(\n          subdividedPositions,\n          left,\n          width,\n          calculatedPositions\n        );\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        startPoint = Cartesian3.clone(rightPos, startPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.cross(normal, forward, left),\n          left\n        );\n        rightPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\n            rightPos\n          ),\n          rightPos\n        );\n        previousPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width, previousPos),\n            previousPos\n          ),\n          previousPos\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          corners.push({\n            rightPositions: computeRoundCorner(\n              leftPos,\n              startPoint,\n              rightPos,\n              cornerType,\n              leftIsOutside\n            ),\n          });\n        } else {\n          corners.push({\n            rightPositions: computeMiteredCorner(\n              position,\n              cornerDirection,\n              rightPos,\n              leftIsOutside\n            ),\n          });\n        }\n      }\n      backward = Cartesian3.negate(forward, backward);\n    }\n    position = nextPosition;\n  }\n\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n  scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scaleArray2,\n    granularity: granularity,\n    ellipsoid: ellipsoid,\n  });\n  calculatedPositions = addShiftedPositions(\n    subdividedPositions,\n    left,\n    width,\n    calculatedPositions\n  );\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n\n  let endPositions;\n  if (cornerType === CornerType.ROUNDED) {\n    endPositions = addEndCaps(calculatedPositions);\n  }\n\n  return {\n    positions: calculatedPositions,\n    corners: corners,\n    lefts: calculatedLefts,\n    normals: calculatedNormals,\n    endPositions: endPositions,\n  };\n};\nexport default CorridorGeometryLibrary;\n"],"names":["CorridorGeometryLibrary","scratch1","Cartesian3","scratch2","scratch3","scratch4","scaleArray2","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","cartesian7","cartesian8","cartesian9","cartesian10","quaterion","Quaternion","rotMatrix","Matrix3","computeRoundCorner","cornerPoint","startPoint","endPoint","cornerType","leftIsOutside","angle","angleBetween","subtract","granularity","CornerType","BEVELED","Math","ceil","CesiumMath","toRadians","size","array","Array","m","x","y","z","fromQuaternion","fromAxisAngle","negate","index","clone","i","multiplyByVector","computeMiteredCorner","position","leftCornerDirection","lastPoint","add","addShiftedPositions","positions","left","scalar","calculatedPositions","rightPositions","length","leftPositions","scaledLeft","multiplyByScalar","scaledRight","rightIndex","leftIndex","pos","fromArray","rightPos","leftPos","push","addAttribute","attribute","value","front","back","defined","scratchForwardProjection","scratchBackwardProjection","computePositions","params","ellipsoid","width","saveAttributes","normal","forward","backward","cornerDirection","previousPos","center","calculatedLefts","undefined","calculatedNormals","subdividedPositions","nextPosition","normalize","geodeticSurfaceNormal","cross","corners","forwardProjection","dot","backwardProjection","equalsEpsilon","abs","EPSILON7","max","magnitude","PolylineVolumeGeometryLibrary","angleIsGreaterThanPi","PolylinePipeline","generateArc","ROUNDED","endPositions","leftEdge","midpoint","firstEndCap","rightEdge","addEndCaps","lefts","normals"],"mappings":"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"}