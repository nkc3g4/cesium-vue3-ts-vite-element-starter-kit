{"version":3,"file":"CylinderGeometry-2bf20aa7.js","sources":["../../../../Source/Core/CylinderGeometry.js"],"sourcesContent":["import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst radiusScratch = new Cartesian2();\nconst normalScratch = new Cartesian3();\nconst bitangentScratch = new Cartesian3();\nconst tangentScratch = new Cartesian3();\nconst positionScratch = new Cartesian3();\n\n/**\n * A description of a cylinder.\n *\n * @alias CylinderGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.length The length of the cylinder.\n * @param {Number} options.topRadius The radius of the top of the cylinder.\n * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n *\n * @see CylinderGeometry.createGeometry\n *\n * @example\n * // create cylinder geometry\n * const cylinder = new Cesium.CylinderGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * const geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\n */\nfunction CylinderGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const length = options.length;\n  const topRadius = options.topRadius;\n  const bottomRadius = options.bottomRadius;\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  const slices = defaultValue(options.slices, 128);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(length)) {\n    throw new DeveloperError(\"options.length must be defined.\");\n  }\n  if (!defined(topRadius)) {\n    throw new DeveloperError(\"options.topRadius must be defined.\");\n  }\n  if (!defined(bottomRadius)) {\n    throw new DeveloperError(\"options.bottomRadius must be defined.\");\n  }\n  if (slices < 3) {\n    throw new DeveloperError(\n      \"options.slices must be greater than or equal to 3.\"\n    );\n  }\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._length = length;\n  this._topRadius = topRadius;\n  this._bottomRadius = bottomRadius;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._slices = slices;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCylinderGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCylinderGeometry.packedLength = VertexFormat.packedLength + 5;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CylinderGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCylinderGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._length;\n  array[startingIndex++] = value._topRadius;\n  array[startingIndex++] = value._bottomRadius;\n  array[startingIndex++] = value._slices;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  vertexFormat: scratchVertexFormat,\n  length: undefined,\n  topRadius: undefined,\n  bottomRadius: undefined,\n  slices: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CylinderGeometry} [result] The object into which to store the result.\n * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\n */\nCylinderGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const length = array[startingIndex++];\n  const topRadius = array[startingIndex++];\n  const bottomRadius = array[startingIndex++];\n  const slices = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.length = length;\n    scratchOptions.topRadius = topRadius;\n    scratchOptions.bottomRadius = bottomRadius;\n    scratchOptions.slices = slices;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CylinderGeometry(scratchOptions);\n  }\n\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._length = length;\n  result._topRadius = topRadius;\n  result._bottomRadius = bottomRadius;\n  result._slices = slices;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\n *\n * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCylinderGeometry.createGeometry = function (cylinderGeometry) {\n  let length = cylinderGeometry._length;\n  const topRadius = cylinderGeometry._topRadius;\n  const bottomRadius = cylinderGeometry._bottomRadius;\n  const vertexFormat = cylinderGeometry._vertexFormat;\n  const slices = cylinderGeometry._slices;\n\n  if (\n    length <= 0 ||\n    topRadius < 0 ||\n    bottomRadius < 0 ||\n    (topRadius === 0 && bottomRadius === 0)\n  ) {\n    return;\n  }\n\n  const twoSlices = slices + slices;\n  const threeSlices = slices + twoSlices;\n  const numVertices = twoSlices + twoSlices;\n\n  const positions = CylinderGeometryLibrary.computePositions(\n    length,\n    topRadius,\n    bottomRadius,\n    slices,\n    true\n  );\n\n  const st = vertexFormat.st ? new Float32Array(numVertices * 2) : undefined;\n  const normals = vertexFormat.normal\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n  const tangents = vertexFormat.tangent\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n\n  let i;\n  const computeNormal =\n    vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent;\n\n  if (computeNormal) {\n    const computeTangent = vertexFormat.tangent || vertexFormat.bitangent;\n\n    let normalIndex = 0;\n    let tangentIndex = 0;\n    let bitangentIndex = 0;\n\n    const theta = Math.atan2(bottomRadius - topRadius, length);\n    const normal = normalScratch;\n    normal.z = Math.sin(theta);\n    const normalScale = Math.cos(theta);\n    let tangent = tangentScratch;\n    let bitangent = bitangentScratch;\n\n    for (i = 0; i < slices; i++) {\n      const angle = (i / slices) * CesiumMath.TWO_PI;\n      const x = normalScale * Math.cos(angle);\n      const y = normalScale * Math.sin(angle);\n      if (computeNormal) {\n        normal.x = x;\n        normal.y = y;\n\n        if (computeTangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent),\n            tangent\n          );\n        }\n\n        if (vertexFormat.normal) {\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n        }\n\n        if (vertexFormat.tangent) {\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n        }\n\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent\n          );\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n        }\n      }\n    }\n\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = -1;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = -1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 1;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = 1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n  }\n\n  const numIndices = 12 * slices - 12;\n  const indices = IndexDatatype.createTypedArray(numVertices, numIndices);\n  let index = 0;\n  let j = 0;\n  for (i = 0; i < slices - 1; i++) {\n    indices[index++] = j;\n    indices[index++] = j + 2;\n    indices[index++] = j + 3;\n\n    indices[index++] = j;\n    indices[index++] = j + 3;\n    indices[index++] = j + 1;\n\n    j += 2;\n  }\n\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 0;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 1;\n\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = twoSlices + i + 1;\n    indices[index++] = twoSlices + i;\n    indices[index++] = twoSlices;\n  }\n\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = threeSlices;\n    indices[index++] = threeSlices + i;\n    indices[index++] = threeSlices + i + 1;\n  }\n\n  let textureCoordIndex = 0;\n  if (vertexFormat.st) {\n    const rad = Math.max(topRadius, bottomRadius);\n    for (i = 0; i < numVertices; i++) {\n      const position = Cartesian3.fromArray(positions, i * 3, positionScratch);\n      st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\n      st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  radiusScratch.x = length * 0.5;\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n  const boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    Cartesian2.magnitude(radiusScratch)\n  );\n\n  if (defined(cylinderGeometry._offsetAttribute)) {\n    length = positions.length;\n    const applyOffset = new Uint8Array(length / 3);\n    const offsetValue =\n      cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: cylinderGeometry._offsetAttribute,\n  });\n};\n\nlet unitCylinderGeometry;\n\n/**\n * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\nCylinderGeometry.getUnitCylinder = function () {\n  if (!defined(unitCylinderGeometry)) {\n    unitCylinderGeometry = CylinderGeometry.createGeometry(\n      new CylinderGeometry({\n        topRadius: 1.0,\n        bottomRadius: 1.0,\n        length: 1.0,\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      })\n    );\n  }\n  return unitCylinderGeometry;\n};\nexport default CylinderGeometry;\n"],"names":["radiusScratch","Cartesian2","normalScratch","Cartesian3","bitangentScratch","tangentScratch","positionScratch","CylinderGeometry","options","length","defaultValue","EMPTY_OBJECT","topRadius","bottomRadius","vertexFormat","VertexFormat","DEFAULT","slices","defined","DeveloperError","offsetAttribute","GeometryOffsetAttribute","TOP","this","_length","_topRadius","_bottomRadius","_vertexFormat","clone","_slices","_offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchVertexFormat","scratchOptions","undefined","unitCylinderGeometry","unpack","result","createGeometry","cylinderGeometry","twoSlices","threeSlices","numVertices","positions","CylinderGeometryLibrary","computePositions","st","Float32Array","normals","normal","tangents","tangent","bitangents","bitangent","i","computeNormal","computeTangent","normalIndex","tangentIndex","bitangentIndex","theta","Math","atan2","z","sin","normalScale","cos","angle","CesiumMath","TWO_PI","x","y","normalize","cross","UNIT_Z","numIndices","indices","IndexDatatype","createTypedArray","index","j","textureCoordIndex","rad","max","position","fromArray","attributes","GeometryAttributes","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","FLOAT","boundingSphere","BoundingSphere","ZERO","magnitude","applyOffset","Uint8Array","offsetValue","NONE","arrayFill","UNSIGNED_BYTE","Geometry","primitiveType","PrimitiveType","TRIANGLES","getUnitCylinder","POSITION_ONLY"],"mappings":"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"}