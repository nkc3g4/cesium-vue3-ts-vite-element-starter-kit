{"version":3,"file":"OrientedBoundingBox-1e433348.js","sources":["../../../../Source/Core/OrientedBoundingBox.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Creates an instance of an OrientedBoundingBox.\n * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\n * @alias OrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0\n *                                          cube centered at the origin.\n *\n *\n * @example\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\n * const center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\n * const halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\n *\n * const obb = new Cesium.OrientedBoundingBox(center, halfAxes);\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction OrientedBoundingBox(center, halfAxes) {\n  /**\n   * The center of the box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\n  /**\n   * The transformation matrix, to rotate the box to the right position.\n   * @type {Matrix3}\n   * @default {@link Matrix3.ZERO}\n   */\n  this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nOrientedBoundingBox.packedLength =\n  Cartesian3.packedLength + Matrix3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrientedBoundingBox} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value.center, array, startingIndex);\n  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  Cartesian3.unpack(array, startingIndex, result.center);\n  Matrix3.unpack(\n    array,\n    startingIndex + Cartesian3.packedLength,\n    result.halfAxes\n  );\n  return result;\n};\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst scratchCartesian5 = new Cartesian3();\nconst scratchCartesian6 = new Cartesian3();\nconst scratchCovarianceResult = new Matrix3();\nconst scratchEigenResult = {\n  unitary: new Matrix3(),\n  diagonal: new Matrix3(),\n};\n\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n *\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an object oriented bounding box enclosing two points.\n * const box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nOrientedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.halfAxes = Matrix3.ZERO;\n    result.center = Cartesian3.ZERO;\n    return result;\n  }\n\n  let i;\n  const length = positions.length;\n\n  const meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\n  for (i = 1; i < length; i++) {\n    Cartesian3.add(meanPoint, positions[i], meanPoint);\n  }\n  const invLength = 1.0 / length;\n  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\n\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n  let p;\n\n  for (i = 0; i < length; i++) {\n    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  const eigenDecomposition = Matrix3.computeEigenDecomposition(\n    covarianceMatrix,\n    scratchEigenResult\n  );\n  const rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\n\n  let v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\n  let v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\n  let v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\n\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n\n  for (i = 0; i < length; i++) {\n    p = positions[i];\n    u1 = Math.max(Cartesian3.dot(v1, p), u1);\n    u2 = Math.max(Cartesian3.dot(v2, p), u2);\n    u3 = Math.max(Cartesian3.dot(v3, p), u3);\n\n    l1 = Math.min(Cartesian3.dot(v1, p), l1);\n    l2 = Math.min(Cartesian3.dot(v2, p), l2);\n    l3 = Math.min(Cartesian3.dot(v3, p), l3);\n  }\n\n  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\n  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\n  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\n\n  const center = Cartesian3.add(v1, v2, result.center);\n  Cartesian3.add(center, v3, center);\n\n  const scale = scratchCartesian3;\n  scale.x = u1 - l1;\n  scale.y = u2 - l2;\n  scale.z = u3 - l3;\n  Cartesian3.multiplyByScalar(scale, 0.5, scale);\n  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\n\n  return result;\n};\n\nconst scratchOffset = new Cartesian3();\nconst scratchScale = new Cartesian3();\nfunction fromPlaneExtents(\n  planeOrigin,\n  planeXAxis,\n  planeYAxis,\n  planeZAxis,\n  minimumX,\n  maximumX,\n  minimumY,\n  maximumY,\n  minimumZ,\n  maximumZ,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(minimumX) ||\n    !defined(maximumX) ||\n    !defined(minimumY) ||\n    !defined(maximumY) ||\n    !defined(minimumZ) ||\n    !defined(maximumZ)\n  ) {\n    throw new DeveloperError(\n      \"all extents (minimum/maximum X/Y/Z) are required.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  const halfAxes = result.halfAxes;\n  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\n\n  let centerOffset = scratchOffset;\n  centerOffset.x = (minimumX + maximumX) / 2.0;\n  centerOffset.y = (minimumY + maximumY) / 2.0;\n  centerOffset.z = (minimumZ + maximumZ) / 2.0;\n\n  const scale = scratchScale;\n  scale.x = (maximumX - minimumX) / 2.0;\n  scale.y = (maximumY - minimumY) / 2.0;\n  scale.z = (maximumZ - minimumZ) / 2.0;\n\n  const center = result.center;\n  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\n  Cartesian3.add(planeOrigin, centerOffset, center);\n  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\n\n  return result;\n}\n\nconst scratchRectangleCenterCartographic = new Cartographic();\nconst scratchRectangleCenter = new Cartesian3();\nconst scratchPerimeterCartographicNC = new Cartographic();\nconst scratchPerimeterCartographicNW = new Cartographic();\nconst scratchPerimeterCartographicCW = new Cartographic();\nconst scratchPerimeterCartographicSW = new Cartographic();\nconst scratchPerimeterCartographicSC = new Cartographic();\nconst scratchPerimeterCartesianNC = new Cartesian3();\nconst scratchPerimeterCartesianNW = new Cartesian3();\nconst scratchPerimeterCartesianCW = new Cartesian3();\nconst scratchPerimeterCartesianSW = new Cartesian3();\nconst scratchPerimeterCartesianSC = new Cartesian3();\nconst scratchPerimeterProjectedNC = new Cartesian2();\nconst scratchPerimeterProjectedNW = new Cartesian2();\nconst scratchPerimeterProjectedCW = new Cartesian2();\nconst scratchPerimeterProjectedSW = new Cartesian2();\nconst scratchPerimeterProjectedSC = new Cartesian2();\n\nconst scratchPlaneOrigin = new Cartesian3();\nconst scratchPlaneNormal = new Cartesian3();\nconst scratchPlaneXAxis = new Cartesian3();\nconst scratchHorizonCartesian = new Cartesian3();\nconst scratchHorizonProjected = new Cartesian2();\nconst scratchMaxY = new Cartesian3();\nconst scratchMinY = new Cartesian3();\nconst scratchZ = new Cartesian3();\nconst scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n\n/**\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\n * There are no guarantees about the orientation of the bounding box.\n *\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\n * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\n * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n *\n * @exception {DeveloperError} rectangle.width must be between 0 and pi.\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\n */\nOrientedBoundingBox.fromRectangle = function (\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\n    throw new DeveloperError(\"Rectangle width must be between 0 and 2*pi\");\n  }\n  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\n    throw new DeveloperError(\"Rectangle height must be between 0 and pi\");\n  }\n  if (\n    defined(ellipsoid) &&\n    !CesiumMath.equalsEpsilon(\n      ellipsoid.radii.x,\n      ellipsoid.radii.y,\n      CesiumMath.EPSILON15\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  minimumHeight = defaultValue(minimumHeight, 0.0);\n  maximumHeight = defaultValue(maximumHeight, 0.0);\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  let minX, maxX, minY, maxY, minZ, maxZ, plane;\n\n  if (rectangle.width <= CesiumMath.PI) {\n    // The bounding box will be aligned with the tangent plane at the center of the rectangle.\n    const tangentPointCartographic = Rectangle.center(\n      rectangle,\n      scratchRectangleCenterCartographic\n    );\n    const tangentPoint = ellipsoid.cartographicToCartesian(\n      tangentPointCartographic,\n      scratchRectangleCenter\n    );\n    const tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\n    plane = tangentPlane.plane;\n\n    // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\n    const lonCenter = tangentPointCartographic.longitude;\n    const latCenter =\n      rectangle.south < 0.0 && rectangle.north > 0.0\n        ? 0.0\n        : tangentPointCartographic.latitude;\n\n    // Compute XY extents using the rectangle at maximum height\n    const perimeterCartographicNC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNC\n    );\n    const perimeterCartographicNW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNW\n    );\n    const perimeterCartographicCW = Cartographic.fromRadians(\n      rectangle.west,\n      latCenter,\n      maximumHeight,\n      scratchPerimeterCartographicCW\n    );\n    const perimeterCartographicSW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSW\n    );\n    const perimeterCartographicSC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSC\n    );\n\n    const perimeterCartesianNC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNC,\n      scratchPerimeterCartesianNC\n    );\n    let perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW\n    );\n    const perimeterCartesianCW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicCW,\n      scratchPerimeterCartesianCW\n    );\n    let perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW\n    );\n    const perimeterCartesianSC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSC,\n      scratchPerimeterCartesianSC\n    );\n\n    const perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNC,\n      scratchPerimeterProjectedNC\n    );\n    const perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNW,\n      scratchPerimeterProjectedNW\n    );\n    const perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianCW,\n      scratchPerimeterProjectedCW\n    );\n    const perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSW,\n      scratchPerimeterProjectedSW\n    );\n    const perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSC,\n      scratchPerimeterProjectedSC\n    );\n\n    minX = Math.min(\n      perimeterProjectedNW.x,\n      perimeterProjectedCW.x,\n      perimeterProjectedSW.x\n    );\n    maxX = -minX; // symmetrical\n\n    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\n    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\n\n    // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\n    perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\n    perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW\n    );\n    perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW\n    );\n\n    minZ = Math.min(\n      Plane.getPointDistance(plane, perimeterCartesianNW),\n      Plane.getPointDistance(plane, perimeterCartesianSW)\n    );\n    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\n\n    return fromPlaneExtents(\n      tangentPlane.origin,\n      tangentPlane.xAxis,\n      tangentPlane.yAxis,\n      tangentPlane.zAxis,\n      minX,\n      maxX,\n      minY,\n      maxY,\n      minZ,\n      maxZ,\n      result\n    );\n  }\n\n  // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\n  const fullyAboveEquator = rectangle.south > 0.0;\n  const fullyBelowEquator = rectangle.north < 0.0;\n  const latitudeNearestToEquator = fullyAboveEquator\n    ? rectangle.south\n    : fullyBelowEquator\n    ? rectangle.north\n    : 0.0;\n  const centerLongitude = Rectangle.center(\n    rectangle,\n    scratchRectangleCenterCartographic\n  ).longitude;\n\n  // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\n  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\n  const planeOrigin = Cartesian3.fromRadians(\n    centerLongitude,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchPlaneOrigin\n  );\n  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\n  const isPole =\n    Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 &&\n    Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\n  const planeNormal = !isPole\n    ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal)\n    : Cartesian3.UNIT_X;\n  const planeYAxis = Cartesian3.UNIT_Z;\n  const planeXAxis = Cartesian3.cross(\n    planeNormal,\n    planeYAxis,\n    scratchPlaneXAxis\n  );\n  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\n\n  // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\n  const horizonCartesian = Cartesian3.fromRadians(\n    centerLongitude + CesiumMath.PI_OVER_TWO,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchHorizonCartesian\n  );\n  maxX = Cartesian3.dot(\n    Plane.projectPointOntoPlane(\n      plane,\n      horizonCartesian,\n      scratchHorizonProjected\n    ),\n    planeXAxis\n  );\n  minX = -maxX; // symmetrical\n\n  // Get the min and max Y, using the height that will give the largest extent\n  maxY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.north,\n    fullyBelowEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMaxY\n  ).z;\n  minY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.south,\n    fullyAboveEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMinY\n  ).z;\n\n  const farZ = Cartesian3.fromRadians(\n    rectangle.east,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchZ\n  );\n  minZ = Plane.getPointDistance(plane, farZ);\n  maxZ = 0.0; // plane origin starts at maxZ already\n\n  // min and max are local to the plane axes\n  return fromPlaneExtents(\n    planeOrigin,\n    planeXAxis,\n    planeYAxis,\n    planeNormal,\n    minX,\n    maxX,\n    minY,\n    maxY,\n    minZ,\n    maxZ,\n    result\n  );\n};\n\n/**\n * Computes an OrientedBoundingBox that bounds an affine transformation.\n *\n * @param {Matrix4} transformation The affine transformation.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n */\nOrientedBoundingBox.fromTransformation = function (transformation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"transformation\", transformation);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  result.center = Matrix4.getTranslation(transformation, result.center);\n  result.halfAxes = Matrix4.getMatrix3(transformation, result.halfAxes);\n  result.halfAxes = Matrix3.multiplyByScalar(\n    result.halfAxes,\n    0.5,\n    result.halfAxes\n  );\n  return result;\n};\n\n/**\n * Duplicates a OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nOrientedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new OrientedBoundingBox(box.center, box.halfAxes);\n  }\n\n  Cartesian3.clone(box.center, result.center);\n  Matrix3.clone(box.halfAxes, result.halfAxes);\n\n  return result;\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const center = box.center;\n  const normal = plane.normal;\n  const halfAxes = box.halfAxes;\n  const normalX = normal.x,\n    normalY = normal.y,\n    normalZ = normal.z;\n  // plane is used as if it is its normal; the first three components are assumed to be normalized\n  const radEffective =\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN0ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN0ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN0ROW2]\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN1ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN1ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN1ROW2]\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN2ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN2ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN2ROW2]\n    );\n  const distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane <= -radEffective) {\n    // The entire box is on the negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane >= radEffective) {\n    // The entire box is on the positive side of the plane normal\n    return Intersect.INSIDE;\n  }\n  return Intersect.INTERSECTING;\n};\n\nconst scratchCartesianU = new Cartesian3();\nconst scratchCartesianV = new Cartesian3();\nconst scratchCartesianW = new Cartesian3();\nconst scratchValidAxis2 = new Cartesian3();\nconst scratchValidAxis3 = new Cartesian3();\nconst scratchPPrime = new Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {OrientedBoundingBox} box The box.\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The distance squared from the oriented bounding box to the point. Returns 0 if the point is inside the box.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\n  // See Geometric Tools for Computer Graphics 10.4.2\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\n\n  const halfAxes = box.halfAxes;\n  let u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  let v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  let w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  const uHalf = Cartesian3.magnitude(u);\n  const vHalf = Cartesian3.magnitude(v);\n  const wHalf = Cartesian3.magnitude(w);\n\n  let uValid = true;\n  let vValid = true;\n  let wValid = true;\n\n  if (uHalf > 0) {\n    Cartesian3.divideByScalar(u, uHalf, u);\n  } else {\n    uValid = false;\n  }\n\n  if (vHalf > 0) {\n    Cartesian3.divideByScalar(v, vHalf, v);\n  } else {\n    vValid = false;\n  }\n\n  if (wHalf > 0) {\n    Cartesian3.divideByScalar(w, wHalf, w);\n  } else {\n    wValid = false;\n  }\n\n  const numberOfDegenerateAxes = !uValid + !vValid + !wValid;\n  let validAxis1;\n  let validAxis2;\n  let validAxis3;\n\n  if (numberOfDegenerateAxes === 1) {\n    let degenerateAxis = u;\n    validAxis1 = v;\n    validAxis2 = w;\n    if (!vValid) {\n      degenerateAxis = v;\n      validAxis1 = u;\n    } else if (!wValid) {\n      degenerateAxis = w;\n      validAxis2 = u;\n    }\n\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\n\n    if (degenerateAxis === u) {\n      u = validAxis3;\n    } else if (degenerateAxis === v) {\n      v = validAxis3;\n    } else if (degenerateAxis === w) {\n      w = validAxis3;\n    }\n  } else if (numberOfDegenerateAxes === 2) {\n    validAxis1 = u;\n    if (vValid) {\n      validAxis1 = v;\n    } else if (wValid) {\n      validAxis1 = w;\n    }\n\n    let crossVector = Cartesian3.UNIT_Y;\n    if (crossVector.equalsEpsilon(validAxis1, CesiumMath.EPSILON3)) {\n      crossVector = Cartesian3.UNIT_X;\n    }\n\n    validAxis2 = Cartesian3.cross(validAxis1, crossVector, scratchValidAxis2);\n    Cartesian3.normalize(validAxis2, validAxis2);\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\n    Cartesian3.normalize(validAxis3, validAxis3);\n\n    if (validAxis1 === u) {\n      v = validAxis2;\n      w = validAxis3;\n    } else if (validAxis1 === v) {\n      w = validAxis2;\n      u = validAxis3;\n    } else if (validAxis1 === w) {\n      u = validAxis2;\n      v = validAxis3;\n    }\n  } else if (numberOfDegenerateAxes === 3) {\n    u = Cartesian3.UNIT_X;\n    v = Cartesian3.UNIT_Y;\n    w = Cartesian3.UNIT_Z;\n  }\n\n  const pPrime = scratchPPrime;\n  pPrime.x = Cartesian3.dot(offset, u);\n  pPrime.y = Cartesian3.dot(offset, v);\n  pPrime.z = Cartesian3.dot(offset, w);\n\n  let distanceSquared = 0.0;\n  let d;\n\n  if (pPrime.x < -uHalf) {\n    d = pPrime.x + uHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.x > uHalf) {\n    d = pPrime.x - uHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.y < -vHalf) {\n    d = pPrime.y + vHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.y > vHalf) {\n    d = pPrime.y - vHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.z < -wHalf) {\n    d = pPrime.z + wHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.z > wHalf) {\n    d = pPrime.z - wHalf;\n    distanceSquared += d * d;\n  }\n\n  return distanceSquared;\n};\n\nconst scratchCorner = new Cartesian3();\nconst scratchToCenter = new Cartesian3();\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.computePlaneDistances = function (\n  box,\n  position,\n  direction,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  let minDist = Number.POSITIVE_INFINITY;\n  let maxDist = Number.NEGATIVE_INFINITY;\n\n  const center = box.center;\n  const halfAxes = box.halfAxes;\n\n  const u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  const v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  const w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  // project first corner\n  const corner = Cartesian3.add(u, v, scratchCorner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.add(corner, center, corner);\n\n  const toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\n  let mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project second corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project third corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fourth corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fifth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project sixth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project seventh corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project eighth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  result.start = minDist;\n  result.stop = maxDist;\n  return result;\n};\n\nconst scratchXAxis = new Cartesian3();\nconst scratchYAxis = new Cartesian3();\nconst scratchZAxis = new Cartesian3();\n\n/**\n * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).\n *\n * @param {OrientedBoundingBox} box The oriented bounding box.\n * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.\n * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.\n */\nOrientedBoundingBox.computeCorners = function (box, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"box\", box);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n    ];\n  }\n\n  const center = box.center;\n  const halfAxes = box.halfAxes;\n  const xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n  const yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n  const zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n  Cartesian3.clone(center, result[0]);\n  Cartesian3.subtract(result[0], xAxis, result[0]);\n  Cartesian3.subtract(result[0], yAxis, result[0]);\n  Cartesian3.subtract(result[0], zAxis, result[0]);\n\n  Cartesian3.clone(center, result[1]);\n  Cartesian3.subtract(result[1], xAxis, result[1]);\n  Cartesian3.subtract(result[1], yAxis, result[1]);\n  Cartesian3.add(result[1], zAxis, result[1]);\n\n  Cartesian3.clone(center, result[2]);\n  Cartesian3.subtract(result[2], xAxis, result[2]);\n  Cartesian3.add(result[2], yAxis, result[2]);\n  Cartesian3.subtract(result[2], zAxis, result[2]);\n\n  Cartesian3.clone(center, result[3]);\n  Cartesian3.subtract(result[3], xAxis, result[3]);\n  Cartesian3.add(result[3], yAxis, result[3]);\n  Cartesian3.add(result[3], zAxis, result[3]);\n\n  Cartesian3.clone(center, result[4]);\n  Cartesian3.add(result[4], xAxis, result[4]);\n  Cartesian3.subtract(result[4], yAxis, result[4]);\n  Cartesian3.subtract(result[4], zAxis, result[4]);\n\n  Cartesian3.clone(center, result[5]);\n  Cartesian3.add(result[5], xAxis, result[5]);\n  Cartesian3.subtract(result[5], yAxis, result[5]);\n  Cartesian3.add(result[5], zAxis, result[5]);\n\n  Cartesian3.clone(center, result[6]);\n  Cartesian3.add(result[6], xAxis, result[6]);\n  Cartesian3.add(result[6], yAxis, result[6]);\n  Cartesian3.subtract(result[6], zAxis, result[6]);\n\n  Cartesian3.clone(center, result[7]);\n  Cartesian3.add(result[7], xAxis, result[7]);\n  Cartesian3.add(result[7], yAxis, result[7]);\n  Cartesian3.add(result[7], zAxis, result[7]);\n\n  return result;\n};\n\nconst scratchRotationScale = new Matrix3();\n\n/**\n * Computes a transformation matrix from an oriented bounding box.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.\n */\nOrientedBoundingBox.computeTransformation = function (box, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"box\", box);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  const translation = box.center;\n  const rotationScale = Matrix3.multiplyByUniformScale(\n    box.halfAxes,\n    2.0,\n    scratchRotationScale\n  );\n  return Matrix4.fromRotationTranslation(rotationScale, translation, result);\n};\n\nconst scratchBoundingSphere = new BoundingSphere();\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.isOccluded = function (box, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(occluder)) {\n    throw new DeveloperError(\"occluder is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const sphere = BoundingSphere.fromOrientedBoundingBox(\n    box,\n    scratchBoundingSphere\n  );\n\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  return OrientedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\n  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.prototype.computePlaneDistances = function (\n  position,\n  direction,\n  result\n) {\n  return OrientedBoundingBox.computePlaneDistances(\n    this,\n    position,\n    direction,\n    result\n  );\n};\n\n/**\n * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).\n *\n * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.\n * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.\n */\nOrientedBoundingBox.prototype.computeCorners = function (result) {\n  return OrientedBoundingBox.computeCorners(this, result);\n};\n\n/**\n * Computes a transformation matrix from an oriented bounding box.\n *\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.\n */\nOrientedBoundingBox.prototype.computeTransformation = function (result) {\n  return OrientedBoundingBox.computeTransformation(this, result);\n};\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\n  return OrientedBoundingBox.isOccluded(this, occluder);\n};\n\n/**\n * Compares the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} left The first OrientedBoundingBox.\n * @param {OrientedBoundingBox} right The second OrientedBoundingBox.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      Matrix3.equals(left.halfAxes, right.halfAxes))\n  );\n};\n\n/**\n * Duplicates this OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.prototype.clone = function (result) {\n  return OrientedBoundingBox.clone(this, result);\n};\n\n/**\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.prototype.equals = function (right) {\n  return OrientedBoundingBox.equals(this, right);\n};\nexport default OrientedBoundingBox;\n"],"names":["OrientedBoundingBox","center","halfAxes","this","Cartesian3","clone","defaultValue","ZERO","Matrix3","packedLength","pack","value","array","startingIndex","Check","typeOf","object","defined","unpack","result","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCovarianceResult","scratchEigenResult","unitary","diagonal","fromPoints","positions","length","i","meanPoint","add","invLength","multiplyByScalar","p","exx","exy","exz","eyy","eyz","ezz","subtract","x","y","z","covarianceMatrix","eigenDecomposition","computeEigenDecomposition","rotation","v1","getColumn","v2","v3","u1","Number","MAX_VALUE","u2","u3","l1","l2","l3","Math","max","dot","min","scale","multiplyByScale","scratchOffset","scratchScale","fromPlaneExtents","planeOrigin","planeXAxis","planeYAxis","planeZAxis","minimumX","maximumX","minimumY","maximumY","minimumZ","maximumZ","DeveloperError","setColumn","centerOffset","multiplyByVector","scratchRectangleCenterCartographic","Cartographic","scratchRectangleCenter","scratchPerimeterCartographicNC","scratchPerimeterCartographicNW","scratchPerimeterCartographicCW","scratchPerimeterCartographicSW","scratchPerimeterCartographicSC","scratchPerimeterCartesianNC","scratchPerimeterCartesianNW","scratchPerimeterCartesianCW","scratchPerimeterCartesianSW","scratchPerimeterCartesianSC","scratchPerimeterProjectedNC","Cartesian2","scratchPerimeterProjectedNW","scratchPerimeterProjectedCW","scratchPerimeterProjectedSW","scratchPerimeterProjectedSC","scratchPlaneOrigin","scratchPlaneNormal","scratchPlaneXAxis","scratchHorizonCartesian","scratchHorizonProjected","scratchMaxY","scratchMinY","scratchZ","scratchPlane","Plane","UNIT_X","fromRectangle","rectangle","minimumHeight","maximumHeight","ellipsoid","width","CesiumMath","TWO_PI","height","PI","equalsEpsilon","radii","EPSILON15","minX","maxX","minY","maxY","minZ","maxZ","plane","Ellipsoid","WGS84","tangentPointCartographic","Rectangle","tangentPoint","cartographicToCartesian","tangentPlane","EllipsoidTangentPlane","lonCenter","longitude","latCenter","south","north","latitude","perimeterCartographicNC","fromRadians","perimeterCartographicNW","west","perimeterCartographicCW","perimeterCartographicSW","perimeterCartographicSC","perimeterCartesianNC","perimeterCartesianNW","perimeterCartesianCW","perimeterCartesianSW","perimeterCartesianSC","perimeterProjectedNC","projectPointToNearestOnPlane","perimeterProjectedNW","perimeterProjectedCW","perimeterProjectedSW","perimeterProjectedSC","getPointDistance","origin","xAxis","yAxis","zAxis","fullyAboveEquator","fullyBelowEquator","latitudeNearestToEquator","centerLongitude","planeNormal","abs","EPSILON10","normalize","UNIT_Z","cross","fromPointNormal","horizonCartesian","PI_OVER_TWO","projectPointOntoPlane","farZ","east","fromTransformation","transformation","Matrix4","getTranslation","getMatrix3","box","intersectPlane","normal","normalX","normalY","normalZ","radEffective","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","distanceToPlane","distance","Intersect","OUTSIDE","INSIDE","INTERSECTING","scratchCartesianU","scratchCartesianV","scratchCartesianW","scratchValidAxis2","scratchValidAxis3","scratchPPrime","distanceSquaredTo","cartesian","offset","u","v","w","uHalf","magnitude","vHalf","wHalf","uValid","vValid","wValid","divideByScalar","numberOfDegenerateAxes","validAxis1","validAxis2","validAxis3","degenerateAxis","crossVector","UNIT_Y","EPSILON3","pPrime","d","distanceSquared","scratchCorner","scratchToCenter","computePlaneDistances","position","direction","Interval","minDist","POSITIVE_INFINITY","maxDist","NEGATIVE_INFINITY","corner","toCenter","mag","start","stop","scratchXAxis","scratchYAxis","scratchZAxis","computeCorners","scratchRotationScale","computeTransformation","translation","rotationScale","multiplyByUniformScale","fromRotationTranslation","scratchBoundingSphere","BoundingSphere","isOccluded","occluder","sphere","fromOrientedBoundingBox","isBoundingSphereVisible","prototype","equals","left","right"],"mappings":"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"}