define(["./when-4bbc8319","./Matrix2-265d9610","./ArcType-fc72c06c","./GeometryOffsetAttribute-7e016332","./BoundingRectangle-8f2409a1","./Transforms-8b90e17c","./RuntimeError-5b082e8f","./ComponentDatatype-aad54330","./EllipsoidGeodesic-ed024f16","./EllipsoidTangentPlane-f1a69a20","./GeometryAttribute-4bcb785f","./GeometryInstance-d57564f8","./GeometryPipeline-e93f6439","./IndexDatatype-6739e544","./PolygonGeometryLibrary-e329b948","./PolygonPipeline-5fd67ae2","./VertexFormat-07539138","./combine-e9466e32","./WebGLConstants-508b9636","./AxisAlignedBoundingBox-2a0ca7ef","./IntersectionTests-596e31ec","./Plane-616c9c0a","./AttributeCompression-442278a0","./EncodedCartesian3-da8f96bc","./arrayRemoveDuplicates-65de6756","./EllipsoidRhumbLine-d09d563f","./GeometryAttributes-7827a6c2"],(function(e,t,o,r,i,n,a,s,l,c,u,p,y,d,g,m,h,f,b,_,P,C,T,w,x,A,I){"use strict";const E=new t.Cartographic,v=new t.Cartographic;function G(e,t,o,r){const i=r.cartesianToCartographic(e,E).height,n=r.cartesianToCartographic(t,v);n.height=i,r.cartographicToCartesian(n,t);const a=r.cartesianToCartographic(o,v);a.height=i-100,r.cartographicToCartesian(a,o)}const O=new i.BoundingRectangle,H=new t.Cartesian3,D=new t.Cartesian3,V=new t.Cartesian3,F=new t.Cartesian3,L=new t.Cartesian3,N=new t.Cartesian3;let R=new t.Cartesian3,M=new t.Cartesian3,S=new t.Cartesian3;const k=new t.Cartesian2,B=new t.Cartesian2,z=new t.Cartesian3,U=new n.Quaternion,W=new t.Matrix3,Y=new t.Matrix3;function j(o){const i=o.vertexFormat,a=o.geometry,l=o.shadowVolume,c=a.attributes.position.values;let p=c.length;const y=o.wall,d=o.top||y,g=o.bottom||y;if(i.st||i.normal||i.tangent||i.bitangent||l){const e=o.boundingRectangle,r=o.tangentPlane,m=o.ellipsoid,h=o.stRotation,f=o.perPositionHeight,b=k;b.x=e.x,b.y=e.y;const _=i.st?new Float32Array(p/3*2):void 0;let P;i.normal&&(P=f&&d&&!y?a.attributes.normal.values:new Float32Array(p));const C=i.tangent?new Float32Array(p):void 0,T=i.bitangent?new Float32Array(p):void 0,w=l?new Float32Array(p):void 0;let x=0,A=0,I=D,E=V,v=F,O=!0,j=W,Q=Y;if(0!==h){let e=n.Quaternion.fromAxisAngle(r._plane.normal,h,U);j=t.Matrix3.fromQuaternion(e,j),e=n.Quaternion.fromAxisAngle(r._plane.normal,-h,U),Q=t.Matrix3.fromQuaternion(e,Q)}else j=t.Matrix3.clone(t.Matrix3.IDENTITY,j),Q=t.Matrix3.clone(t.Matrix3.IDENTITY,Q);let q=0,K=0;d&&g&&(q=p/2,K=p/3,p/=2);for(let n=0;n<p;n+=3){const a=t.Cartesian3.fromArray(c,n,z);if(i.st){let o=t.Matrix3.multiplyByVector(j,a,H);o=m.scaleToGeodeticSurface(o,o);const i=r.projectPointOntoPlane(o,B);t.Cartesian2.subtract(i,b,i);const n=s.CesiumMath.clamp(i.x/e.width,0,1),l=s.CesiumMath.clamp(i.y/e.height,0,1);g&&(_[x+K]=n,_[x+1+K]=l),d&&(_[x]=n,_[x+1]=l),x+=2}if(i.normal||i.tangent||i.bitangent||l){const e=A+1,r=A+2;if(y){if(n+3<p){const e=t.Cartesian3.fromArray(c,n+3,L);if(O){const o=t.Cartesian3.fromArray(c,n+p,N);f&&G(a,e,o,m),t.Cartesian3.subtract(e,a,e),t.Cartesian3.subtract(o,a,o),I=t.Cartesian3.normalize(t.Cartesian3.cross(o,e,I),I),O=!1}t.Cartesian3.equalsEpsilon(e,a,s.CesiumMath.EPSILON10)&&(O=!0)}(i.tangent||i.bitangent)&&(v=m.geodeticSurfaceNormal(a,v),i.tangent&&(E=t.Cartesian3.normalize(t.Cartesian3.cross(v,I,E),E)))}else I=m.geodeticSurfaceNormal(a,I),(i.tangent||i.bitangent)&&(f&&(R=t.Cartesian3.fromArray(P,A,R),M=t.Cartesian3.cross(t.Cartesian3.UNIT_Z,R,M),M=t.Cartesian3.normalize(t.Matrix3.multiplyByVector(Q,M,M),M),i.bitangent&&(S=t.Cartesian3.normalize(t.Cartesian3.cross(R,M,S),S))),E=t.Cartesian3.cross(t.Cartesian3.UNIT_Z,I,E),E=t.Cartesian3.normalize(t.Matrix3.multiplyByVector(Q,E,E),E),i.bitangent&&(v=t.Cartesian3.normalize(t.Cartesian3.cross(I,E,v),v)));i.normal&&(o.wall?(P[A+q]=I.x,P[e+q]=I.y,P[r+q]=I.z):g&&(P[A+q]=-I.x,P[e+q]=-I.y,P[r+q]=-I.z),(d&&!f||y)&&(P[A]=I.x,P[e]=I.y,P[r]=I.z)),l&&(y&&(I=m.geodeticSurfaceNormal(a,I)),w[A+q]=-I.x,w[e+q]=-I.y,w[r+q]=-I.z),i.tangent&&(o.wall?(C[A+q]=E.x,C[e+q]=E.y,C[r+q]=E.z):g&&(C[A+q]=-E.x,C[e+q]=-E.y,C[r+q]=-E.z),d&&(f?(C[A]=M.x,C[e]=M.y,C[r]=M.z):(C[A]=E.x,C[e]=E.y,C[r]=E.z))),i.bitangent&&(g&&(T[A+q]=v.x,T[e+q]=v.y,T[r+q]=v.z),d&&(f?(T[A]=S.x,T[e]=S.y,T[r]=S.z):(T[A]=v.x,T[e]=v.y,T[r]=v.z))),A+=3}}i.st&&(a.attributes.st=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:_})),i.normal&&(a.attributes.normal=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:P})),i.tangent&&(a.attributes.tangent=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C})),i.bitangent&&(a.attributes.bitangent=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T})),l&&(a.attributes.extrudeDirection=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:w}))}if(o.extrude&&e.defined(o.offsetAttribute)){const e=c.length/3;let t=new Uint8Array(e);if(o.offsetAttribute===r.GeometryOffsetAttribute.TOP)d&&g||y?t=r.arrayFill(t,1,0,e/2):d&&(t=r.arrayFill(t,1));else{const e=o.offsetAttribute===r.GeometryOffsetAttribute.NONE?0:1;t=r.arrayFill(t,e)}a.attributes.applyOffset=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return a}const Q=new t.Cartographic,q=new t.Cartographic,K={westOverIDL:0,eastOverIDL:0};let Z=new l.EllipsoidGeodesic;function J(r,i,n,a,c){if(c=e.defaultValue(c,new t.Rectangle),!e.defined(r)||r.length<3)return c.west=0,c.north=0,c.south=0,c.east=0,c;if(n===o.ArcType.RHUMB)return t.Rectangle.fromCartesianArray(r,i,c);Z.ellipsoid.equals(i)||(Z=new l.EllipsoidGeodesic(void 0,void 0,i)),c.west=Number.POSITIVE_INFINITY,c.east=Number.NEGATIVE_INFINITY,c.south=Number.POSITIVE_INFINITY,c.north=Number.NEGATIVE_INFINITY,K.westOverIDL=Number.POSITIVE_INFINITY,K.eastOverIDL=Number.NEGATIVE_INFINITY;const u=1/s.CesiumMath.chordLength(a,i.maximumRadius),p=r.length;let y,d=i.cartesianToCartographic(r[0],q),g=Q;for(let e=1;e<p;e++)y=g,g=d,d=i.cartesianToCartographic(r[e],y),Z.setEndPoints(g,d),$(Z,u,c,K);return y=g,g=d,d=i.cartesianToCartographic(r[0],y),Z.setEndPoints(g,d),$(Z,u,c,K),c.east-c.west>K.eastOverIDL-K.westOverIDL&&(c.west=K.westOverIDL,c.east=K.eastOverIDL,c.east>s.CesiumMath.PI&&(c.east=c.east-s.CesiumMath.TWO_PI),c.west>s.CesiumMath.PI&&(c.west=c.west-s.CesiumMath.TWO_PI)),c}const X=new t.Cartographic;function $(e,t,o,r){const i=e.surfaceDistance,n=Math.ceil(i*t),a=n>0?i/(n-1):Number.POSITIVE_INFINITY;let l=0;for(let t=0;t<n;t++){const t=e.interpolateUsingSurfaceDistance(l,X);l+=a;const i=t.longitude,n=t.latitude;o.west=Math.min(o.west,i),o.east=Math.max(o.east,i),o.south=Math.min(o.south,n),o.north=Math.max(o.north,n);const c=i>=0?i:i+s.CesiumMath.TWO_PI;r.westOverIDL=Math.min(r.westOverIDL,c),r.eastOverIDL=Math.max(r.eastOverIDL,c)}}const ee=[];function te(e,t,o,r,i,n,a,s,l){const u={walls:[]};let y;if(n||a){const r=g.PolygonGeometryLibrary.createGeometryFromPositions(e,t,o,i,s,l),c=r.attributes.position.values,m=r.indices;let h,f;if(n&&a){const e=c.concat(c);h=e.length/3,f=d.IndexDatatype.createTypedArray(h,2*m.length),f.set(m);const t=m.length,o=h/2;for(y=0;y<t;y+=3){const e=f[y]+o,r=f[y+1]+o,i=f[y+2]+o;f[y+t]=i,f[y+1+t]=r,f[y+2+t]=e}if(r.attributes.position.values=e,i&&s.normal){const t=r.attributes.normal.values;r.attributes.normal.values=new Float32Array(e.length),r.attributes.normal.values.set(t)}r.indices=f}else if(a){for(h=c.length/3,f=d.IndexDatatype.createTypedArray(h,m.length),y=0;y<m.length;y+=3)f[y]=m[y+2],f[y+1]=m[y+1],f[y+2]=m[y];r.indices=f}u.topAndBottom=new p.GeometryInstance({geometry:r})}let h=r.outerRing,f=c.EllipsoidTangentPlane.fromPoints(h,e),b=f.projectPointsOntoPlane(h,ee),_=m.PolygonPipeline.computeWindingOrder2D(b);_===m.WindingOrder.CLOCKWISE&&(h=h.slice().reverse());let P=g.PolygonGeometryLibrary.computeWallGeometry(h,e,o,i,l);u.walls.push(new p.GeometryInstance({geometry:P}));const C=r.holes;for(y=0;y<C.length;y++){let t=C[y];f=c.EllipsoidTangentPlane.fromPoints(t,e),b=f.projectPointsOntoPlane(t,ee),_=m.PolygonPipeline.computeWindingOrder2D(b),_===m.WindingOrder.COUNTER_CLOCKWISE&&(t=t.slice().reverse()),P=g.PolygonGeometryLibrary.computeWallGeometry(t,e,o,i,l),u.walls.push(new p.GeometryInstance({geometry:P}))}return u}function oe(r){if(a.Check.typeOf.object("options",r),a.Check.typeOf.object("options.polygonHierarchy",r.polygonHierarchy),e.defined(r.perPositionHeight)&&r.perPositionHeight&&e.defined(r.height))throw new a.DeveloperError("Cannot use both options.perPositionHeight and options.height");if(e.defined(r.arcType)&&r.arcType!==o.ArcType.GEODESIC&&r.arcType!==o.ArcType.RHUMB)throw new a.DeveloperError("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");const i=r.polygonHierarchy,n=e.defaultValue(r.vertexFormat,h.VertexFormat.DEFAULT),l=e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84),c=e.defaultValue(r.granularity,s.CesiumMath.RADIANS_PER_DEGREE),u=e.defaultValue(r.stRotation,0),p=e.defaultValue(r.perPositionHeight,!1),y=p&&e.defined(r.extrudedHeight);let d=e.defaultValue(r.height,0),m=e.defaultValue(r.extrudedHeight,d);if(!y){const e=Math.max(d,m);m=Math.min(d,m),d=e}this._vertexFormat=h.VertexFormat.clone(n),this._ellipsoid=t.Ellipsoid.clone(l),this._granularity=c,this._stRotation=u,this._height=d,this._extrudedHeight=m,this._closeTop=e.defaultValue(r.closeTop,!0),this._closeBottom=e.defaultValue(r.closeBottom,!0),this._polygonHierarchy=i,this._perPositionHeight=p,this._perPositionHeightExtrude=y,this._shadowVolume=e.defaultValue(r.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=r.offsetAttribute,this._arcType=e.defaultValue(r.arcType,o.ArcType.GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this.packedLength=g.PolygonGeometryLibrary.computeHierarchyPackedLength(i)+t.Ellipsoid.packedLength+h.VertexFormat.packedLength+12}oe.fromPositions=function(t){t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT),a.Check.defined("options.positions",t.positions);return new oe({polygonHierarchy:{positions:t.positions},height:t.height,extrudedHeight:t.extrudedHeight,vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,closeTop:t.closeTop,closeBottom:t.closeBottom,offsetAttribute:t.offsetAttribute,arcType:t.arcType})},oe.pack=function(o,r,i){return a.Check.typeOf.object("value",o),a.Check.defined("array",r),i=e.defaultValue(i,0),i=g.PolygonGeometryLibrary.packPolygonHierarchy(o._polygonHierarchy,r,i),t.Ellipsoid.pack(o._ellipsoid,r,i),i+=t.Ellipsoid.packedLength,h.VertexFormat.pack(o._vertexFormat,r,i),i+=h.VertexFormat.packedLength,r[i++]=o._height,r[i++]=o._extrudedHeight,r[i++]=o._granularity,r[i++]=o._stRotation,r[i++]=o._perPositionHeightExtrude?1:0,r[i++]=o._perPositionHeight?1:0,r[i++]=o._closeTop?1:0,r[i++]=o._closeBottom?1:0,r[i++]=o._shadowVolume?1:0,r[i++]=e.defaultValue(o._offsetAttribute,-1),r[i++]=o._arcType,r[i]=o.packedLength,r};const re=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),ie=new h.VertexFormat,ne={polygonHierarchy:{}};return oe.unpack=function(o,r,i){a.Check.defined("array",o),r=e.defaultValue(r,0);const n=g.PolygonGeometryLibrary.unpackPolygonHierarchy(o,r);r=n.startingIndex,delete n.startingIndex;const s=t.Ellipsoid.unpack(o,r,re);r+=t.Ellipsoid.packedLength;const l=h.VertexFormat.unpack(o,r,ie);r+=h.VertexFormat.packedLength;const c=o[r++],u=o[r++],p=o[r++],y=o[r++],d=1===o[r++],m=1===o[r++],f=1===o[r++],b=1===o[r++],_=1===o[r++],P=o[r++],C=o[r++],T=o[r];return e.defined(i)||(i=new oe(ne)),i._polygonHierarchy=n,i._ellipsoid=t.Ellipsoid.clone(s,i._ellipsoid),i._vertexFormat=h.VertexFormat.clone(l,i._vertexFormat),i._height=c,i._extrudedHeight=u,i._granularity=p,i._stRotation=y,i._perPositionHeightExtrude=d,i._perPositionHeight=m,i._closeTop=f,i._closeBottom=b,i._shadowVolume=_,i._offsetAttribute=-1===P?void 0:P,i._arcType=C,i.packedLength=T,i},oe.computeRectangle=function(r,i){a.Check.typeOf.object("options",r),a.Check.typeOf.object("options.polygonHierarchy",r.polygonHierarchy);const n=e.defaultValue(r.granularity,s.CesiumMath.RADIANS_PER_DEGREE),l=e.defaultValue(r.arcType,o.ArcType.GEODESIC);if(l!==o.ArcType.GEODESIC&&l!==o.ArcType.RHUMB)throw new a.DeveloperError("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");const c=r.polygonHierarchy,u=e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84);return J(c.positions,u,l,n,i)},oe.createGeometry=function(t){const o=t._vertexFormat,i=t._ellipsoid,a=t._granularity,l=t._stRotation,h=t._polygonHierarchy,f=t._perPositionHeight,b=t._closeTop,_=t._closeBottom,P=t._arcType;let C=h.positions;if(C.length<3)return;const T=c.EllipsoidTangentPlane.fromPoints(C,i),w=g.PolygonGeometryLibrary.polygonsFromHierarchy(h,T.projectPointsOntoPlane.bind(T),!f,i),x=w.hierarchy,A=w.polygons;if(0===x.length)return;C=x[0].outerRing;const I=g.PolygonGeometryLibrary.computeBoundingRectangle(T.plane.normal,T.projectPointOntoPlane.bind(T),C,l,O),E=[],v=t._height,G=t._extrudedHeight,H={perPositionHeight:f,vertexFormat:o,geometry:void 0,tangentPlane:T,boundingRectangle:I,ellipsoid:i,stRotation:l,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:P};let D;if(t._perPositionHeightExtrude||!s.CesiumMath.equalsEpsilon(v,G,0,s.CesiumMath.EPSILON2))for(H.extrude=!0,H.top=b,H.bottom=_,H.shadowVolume=t._shadowVolume,H.offsetAttribute=t._offsetAttribute,D=0;D<A.length;D++){const e=te(i,A[D],a,x[D],f,b,_,o,P);let t;b&&_?(t=e.topAndBottom,H.geometry=g.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(t.geometry,v,G,i,f)):b?(t=e.topAndBottom,t.geometry.attributes.position.values=m.PolygonPipeline.scaleToGeodeticHeight(t.geometry.attributes.position.values,v,i,!f),H.geometry=t.geometry):_&&(t=e.topAndBottom,t.geometry.attributes.position.values=m.PolygonPipeline.scaleToGeodeticHeight(t.geometry.attributes.position.values,G,i,!0),H.geometry=t.geometry),(b||_)&&(H.wall=!1,t.geometry=j(H),E.push(t));const r=e.walls;H.wall=!0;for(let e=0;e<r.length;e++){const t=r[e];H.geometry=g.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(t.geometry,v,G,i,f),t.geometry=j(H),E.push(t)}}else for(D=0;D<A.length;D++){const n=new p.GeometryInstance({geometry:g.PolygonGeometryLibrary.createGeometryFromPositions(i,A[D],a,f,o,P)});if(n.geometry.attributes.position.values=m.PolygonPipeline.scaleToGeodeticHeight(n.geometry.attributes.position.values,v,i,!f),H.geometry=n.geometry,n.geometry=j(H),e.defined(t._offsetAttribute)){const e=n.geometry.attributes.position.values.length,o=new Uint8Array(e/3),i=t._offsetAttribute===r.GeometryOffsetAttribute.NONE?0:1;r.arrayFill(o,i),n.geometry.attributes.applyOffset=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}E.push(n)}const V=y.GeometryPipeline.combineInstances(E)[0];V.attributes.position.values=new Float64Array(V.attributes.position.values),V.indices=d.IndexDatatype.createTypedArray(V.attributes.position.values.length/3,V.indices);const F=V.attributes,L=n.BoundingSphere.fromVertices(F.position.values);return o.position||delete F.position,new u.Geometry({attributes:F,indices:V.indices,primitiveType:V.primitiveType,boundingSphere:L,offsetAttribute:t._offsetAttribute})},oe.createShadowVolume=function(e,t,o){const r=e._granularity,i=e._ellipsoid,n=t(r,i),a=o(r,i);return new oe({polygonHierarchy:e._polygonHierarchy,ellipsoid:i,stRotation:e._stRotation,granularity:r,perPositionHeight:!1,extrudedHeight:n,height:a,vertexFormat:h.VertexFormat.POSITION_ONLY,shadowVolume:!0,arcType:e._arcType})},Object.defineProperties(oe.prototype,{rectangle:{get:function(){if(!e.defined(this._rectangle)){const e=this._polygonHierarchy.positions;this._rectangle=J(e,this._ellipsoid,this._arcType,this._granularity)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return e.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(e){const t=-e._stRotation;if(0===t)return[0,0,0,1,1,0];const o=e._ellipsoid,r=e._polygonHierarchy.positions,i=e.rectangle;return u.Geometry._textureCoordinateRotationPoints(r,t,o,i)}(this)),this._textureCoordinateRotationPoints}}}),function(o,r){return e.defined(r)&&(o=oe.unpack(o,r)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),oe.createGeometry(o)}}));
//# sourceMappingURL=createPolygonGeometry.js.map
