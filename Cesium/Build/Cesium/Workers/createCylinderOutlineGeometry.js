define(["./GeometryOffsetAttribute-7e016332","./Transforms-8b90e17c","./Matrix2-265d9610","./RuntimeError-5b082e8f","./ComponentDatatype-aad54330","./CylinderGeometryLibrary-bedde1c3","./when-4bbc8319","./GeometryAttribute-4bcb785f","./GeometryAttributes-7827a6c2","./IndexDatatype-6739e544","./combine-e9466e32","./WebGLConstants-508b9636"],(function(t,e,i,o,r,n,s,a,u,f,c,d){"use strict";const b=new i.Cartesian2;function m(e){const i=(e=s.defaultValue(e,s.defaultValue.EMPTY_OBJECT)).length,r=e.topRadius,n=e.bottomRadius,a=s.defaultValue(e.slices,128),u=Math.max(s.defaultValue(e.numberOfVerticalLines,16),0);if(o.Check.typeOf.number("options.positions",i),o.Check.typeOf.number("options.topRadius",r),o.Check.typeOf.number("options.bottomRadius",n),o.Check.typeOf.number.greaterThanOrEquals("options.slices",a,3),s.defined(e.offsetAttribute)&&e.offsetAttribute===t.GeometryOffsetAttribute.TOP)throw new o.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=i,this._topRadius=r,this._bottomRadius=n,this._slices=a,this._numberOfVerticalLines=u,this._offsetAttribute=e.offsetAttribute,this._workerName="createCylinderOutlineGeometry"}m.packedLength=6,m.pack=function(t,e,i){return o.Check.typeOf.object("value",t),o.Check.defined("array",e),i=s.defaultValue(i,0),e[i++]=t._length,e[i++]=t._topRadius,e[i++]=t._bottomRadius,e[i++]=t._slices,e[i++]=t._numberOfVerticalLines,e[i]=s.defaultValue(t._offsetAttribute,-1),e};const l={length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};return m.unpack=function(t,e,i){o.Check.defined("array",t),e=s.defaultValue(e,0);const r=t[e++],n=t[e++],a=t[e++],u=t[e++],f=t[e++],c=t[e];return s.defined(i)?(i._length=r,i._topRadius=n,i._bottomRadius=a,i._slices=u,i._numberOfVerticalLines=f,i._offsetAttribute=-1===c?void 0:c,i):(l.length=r,l.topRadius=n,l.bottomRadius=a,l.slices=u,l.numberOfVerticalLines=f,l.offsetAttribute=-1===c?void 0:c,new m(l))},m.createGeometry=function(o){let c=o._length;const d=o._topRadius,m=o._bottomRadius,l=o._slices,p=o._numberOfVerticalLines;if(c<=0||d<0||m<0||0===d&&0===m)return;const y=2*l,h=n.CylinderGeometryLibrary.computePositions(c,d,m,l,!1);let _,A=2*l;if(p>0){const t=Math.min(p,l);_=Math.round(l/t),A+=t}const O=f.IndexDatatype.createTypedArray(y,2*A);let C,R=0;for(C=0;C<l-1;C++)O[R++]=C,O[R++]=C+1,O[R++]=C+l,O[R++]=C+1+l;if(O[R++]=l-1,O[R++]=0,O[R++]=l+l-1,O[R++]=l,p>0)for(C=0;C<l;C+=_)O[R++]=C,O[R++]=C+l;const G=new u.GeometryAttributes;G.position=new a.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:h}),b.x=.5*c,b.y=Math.max(m,d);const g=new e.BoundingSphere(i.Cartesian3.ZERO,i.Cartesian2.magnitude(b));if(s.defined(o._offsetAttribute)){c=h.length;const e=new Uint8Array(c/3),i=o._offsetAttribute===t.GeometryOffsetAttribute.NONE?0:1;t.arrayFill(e,i),G.applyOffset=new a.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}return new a.Geometry({attributes:G,indices:O,primitiveType:a.PrimitiveType.LINES,boundingSphere:g,offsetAttribute:o._offsetAttribute})},function(t,e){return s.defined(e)&&(t=m.unpack(t,e)),m.createGeometry(t)}}));
//# sourceMappingURL=createCylinderOutlineGeometry.js.map
