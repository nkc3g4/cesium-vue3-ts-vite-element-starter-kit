define(["exports","./GeometryOffsetAttribute-7e016332","./Transforms-8b90e17c","./Matrix2-265d9610","./ComponentDatatype-aad54330","./when-4bbc8319","./RuntimeError-5b082e8f","./GeometryAttribute-4bcb785f","./GeometryAttributes-7827a6c2","./IndexDatatype-6739e544"],(function(t,e,i,r,n,o,a,s,u,m){"use strict";const f=new r.Cartesian3(1,1,1),l=Math.cos,d=Math.sin;function c(t){t=o.defaultValue(t,o.defaultValue.EMPTY_OBJECT);const i=o.defaultValue(t.radii,f),s=o.defaultValue(t.innerRadii,i),u=o.defaultValue(t.minimumClock,0),m=o.defaultValue(t.maximumClock,n.CesiumMath.TWO_PI),l=o.defaultValue(t.minimumCone,0),d=o.defaultValue(t.maximumCone,n.CesiumMath.PI),c=Math.round(o.defaultValue(t.stackPartitions,10)),p=Math.round(o.defaultValue(t.slicePartitions,8)),C=Math.round(o.defaultValue(t.subdivisions,128));if(c<1)throw new a.DeveloperError("options.stackPartitions cannot be less than 1");if(p<0)throw new a.DeveloperError("options.slicePartitions cannot be less than 0");if(C<0)throw new a.DeveloperError("options.subdivisions must be greater than or equal to zero.");if(o.defined(t.offsetAttribute)&&t.offsetAttribute===e.GeometryOffsetAttribute.TOP)throw new a.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._radii=r.Cartesian3.clone(i),this._innerRadii=r.Cartesian3.clone(s),this._minimumClock=u,this._maximumClock=m,this._minimumCone=l,this._maximumCone=d,this._stackPartitions=c,this._slicePartitions=p,this._subdivisions=C,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}c.packedLength=2*r.Cartesian3.packedLength+8,c.pack=function(t,e,i){if(!o.defined(t))throw new a.DeveloperError("value is required");if(!o.defined(e))throw new a.DeveloperError("array is required");return i=o.defaultValue(i,0),r.Cartesian3.pack(t._radii,e,i),i+=r.Cartesian3.packedLength,r.Cartesian3.pack(t._innerRadii,e,i),i+=r.Cartesian3.packedLength,e[i++]=t._minimumClock,e[i++]=t._maximumClock,e[i++]=t._minimumCone,e[i++]=t._maximumCone,e[i++]=t._stackPartitions,e[i++]=t._slicePartitions,e[i++]=t._subdivisions,e[i]=o.defaultValue(t._offsetAttribute,-1),e};const p=new r.Cartesian3,C=new r.Cartesian3,h={radii:p,innerRadii:C,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};c.unpack=function(t,e,i){if(!o.defined(t))throw new a.DeveloperError("array is required");e=o.defaultValue(e,0);const n=r.Cartesian3.unpack(t,e,p);e+=r.Cartesian3.packedLength;const s=r.Cartesian3.unpack(t,e,C);e+=r.Cartesian3.packedLength;const u=t[e++],m=t[e++],f=t[e++],l=t[e++],d=t[e++],_=t[e++],b=t[e++],y=t[e];return o.defined(i)?(i._radii=r.Cartesian3.clone(n,i._radii),i._innerRadii=r.Cartesian3.clone(s,i._innerRadii),i._minimumClock=u,i._maximumClock=m,i._minimumCone=f,i._maximumCone=l,i._stackPartitions=d,i._slicePartitions=_,i._subdivisions=b,i._offsetAttribute=-1===y?void 0:y,i):(h.minimumClock=u,h.maximumClock=m,h.minimumCone=f,h.maximumCone=l,h.stackPartitions=d,h.slicePartitions=_,h.subdivisions=b,h.offsetAttribute=-1===y?void 0:y,new c(h))},c.createGeometry=function(t){const a=t._radii;if(a.x<=0||a.y<=0||a.z<=0)return;const f=t._innerRadii;if(f.x<=0||f.y<=0||f.z<=0)return;const c=t._minimumClock,p=t._maximumClock,C=t._minimumCone,h=t._maximumCone,_=t._subdivisions,b=r.Ellipsoid.fromCartesian3(a);let y=t._slicePartitions+1,k=t._stackPartitions+1;y=Math.round(y*Math.abs(p-c)/n.CesiumMath.TWO_PI),k=Math.round(k*Math.abs(h-C)/n.CesiumMath.PI),y<2&&(y=2),k<2&&(k=2);let A=0,v=1;const w=f.x!==a.x||f.y!==a.y||f.z!==a.z;let P=!1,x=!1;w&&(v=2,C>0&&(P=!0,A+=y),h<Math.PI&&(x=!0,A+=y));const E=_*v*(k+y),D=new Float64Array(3*E),M=2*(E+A-(y+k)*v),g=m.IndexDatatype.createTypedArray(E,M);let G,O,V,T,z=0;const I=new Array(k),L=new Array(k);for(G=0;G<k;G++)T=C+G*(h-C)/(k-1),I[G]=d(T),L[G]=l(T);const R=new Array(_),N=new Array(_);for(G=0;G<_;G++)V=c+G*(p-c)/(_-1),R[G]=d(V),N[G]=l(V);for(G=0;G<k;G++)for(O=0;O<_;O++)D[z++]=a.x*I[G]*N[O],D[z++]=a.y*I[G]*R[O],D[z++]=a.z*L[G];if(w)for(G=0;G<k;G++)for(O=0;O<_;O++)D[z++]=f.x*I[G]*N[O],D[z++]=f.y*I[G]*R[O],D[z++]=f.z*L[G];for(I.length=_,L.length=_,G=0;G<_;G++)T=C+G*(h-C)/(_-1),I[G]=d(T),L[G]=l(T);for(R.length=y,N.length=y,G=0;G<y;G++)V=c+G*(p-c)/(y-1),R[G]=d(V),N[G]=l(V);for(G=0;G<_;G++)for(O=0;O<y;O++)D[z++]=a.x*I[G]*N[O],D[z++]=a.y*I[G]*R[O],D[z++]=a.z*L[G];if(w)for(G=0;G<_;G++)for(O=0;O<y;O++)D[z++]=f.x*I[G]*N[O],D[z++]=f.y*I[G]*R[O],D[z++]=f.z*L[G];for(z=0,G=0;G<k*v;G++){const t=G*_;for(O=0;O<_-1;O++)g[z++]=t+O,g[z++]=t+O+1}let q=k*_*v;for(G=0;G<y;G++)for(O=0;O<_-1;O++)g[z++]=q+G+O*y,g[z++]=q+G+(O+1)*y;if(w)for(q=k*_*v+y*_,G=0;G<y;G++)for(O=0;O<_-1;O++)g[z++]=q+G+O*y,g[z++]=q+G+(O+1)*y;if(w){let t=k*_*v,e=t+_*y;if(P)for(G=0;G<y;G++)g[z++]=t+G,g[z++]=e+G;if(x)for(t+=_*y-y,e+=_*y-y,G=0;G<y;G++)g[z++]=t+G,g[z++]=e+G}const B=new u.GeometryAttributes({position:new s.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:D})});if(o.defined(t._offsetAttribute)){const i=D.length,r=new Uint8Array(i/3),o=t._offsetAttribute===e.GeometryOffsetAttribute.NONE?0:1;e.arrayFill(r,o),B.applyOffset=new s.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}return new s.Geometry({attributes:B,indices:g,primitiveType:s.PrimitiveType.LINES,boundingSphere:i.BoundingSphere.fromEllipsoid(b),offsetAttribute:t._offsetAttribute})},t.EllipsoidOutlineGeometry=c}));
//# sourceMappingURL=EllipsoidOutlineGeometry-b79bb09f.js.map
