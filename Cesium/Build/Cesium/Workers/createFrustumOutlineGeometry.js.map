{"version":3,"file":"createFrustumOutlineGeometry.js","sources":["../../../../Source/Core/FrustumOutlineGeometry.js","../../../../Source/WorkersES6/createFrustumOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport FrustumGeometry from \"./FrustumGeometry.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\n\nconst PERSPECTIVE = 0;\nconst ORTHOGRAPHIC = 1;\n\n/**\n * A description of the outline of a frustum with the given the origin and orientation.\n *\n * @alias FrustumOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\n * @param {Cartesian3} options.origin The origin of the frustum.\n * @param {Quaternion} options.orientation The orientation of the frustum.\n */\nfunction FrustumOutlineGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.frustum\", options.frustum);\n  Check.typeOf.object(\"options.origin\", options.origin);\n  Check.typeOf.object(\"options.orientation\", options.orientation);\n  //>>includeEnd('debug');\n\n  const frustum = options.frustum;\n  const orientation = options.orientation;\n  const origin = options.origin;\n\n  // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\n  // creating multiple FrustumOutlineGeometrys. This way the near plane of one frustum doesn't overlap\n  // the far plane of another.\n  const drawNearPlane = defaultValue(options._drawNearPlane, true);\n\n  let frustumType;\n  let frustumPackedLength;\n  if (frustum instanceof PerspectiveFrustum) {\n    frustumType = PERSPECTIVE;\n    frustumPackedLength = PerspectiveFrustum.packedLength;\n  } else if (frustum instanceof OrthographicFrustum) {\n    frustumType = ORTHOGRAPHIC;\n    frustumPackedLength = OrthographicFrustum.packedLength;\n  }\n\n  this._frustumType = frustumType;\n  this._frustum = frustum.clone();\n  this._origin = Cartesian3.clone(origin);\n  this._orientation = Quaternion.clone(orientation);\n  this._drawNearPlane = drawNearPlane;\n  this._workerName = \"createFrustumOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    2 + frustumPackedLength + Cartesian3.packedLength + Quaternion.packedLength;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {FrustumOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nFrustumOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const frustumType = value._frustumType;\n  const frustum = value._frustum;\n\n  array[startingIndex++] = frustumType;\n\n  if (frustumType === PERSPECTIVE) {\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    OrthographicFrustum.pack(frustum, array, startingIndex);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  Cartesian3.pack(value._origin, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Quaternion.pack(value._orientation, array, startingIndex);\n  startingIndex += Quaternion.packedLength;\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\n\n  return array;\n};\n\nconst scratchPackPerspective = new PerspectiveFrustum();\nconst scratchPackOrthographic = new OrthographicFrustum();\nconst scratchPackQuaternion = new Quaternion();\nconst scratchPackorigin = new Cartesian3();\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {FrustumOutlineGeometry} [result] The object into which to store the result.\n */\nFrustumOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const frustumType = array[startingIndex++];\n\n  let frustum;\n  if (frustumType === PERSPECTIVE) {\n    frustum = PerspectiveFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackPerspective\n    );\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    frustum = OrthographicFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackOrthographic\n    );\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  const origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\n  startingIndex += Cartesian3.packedLength;\n  const orientation = Quaternion.unpack(\n    array,\n    startingIndex,\n    scratchPackQuaternion\n  );\n  startingIndex += Quaternion.packedLength;\n  const drawNearPlane = array[startingIndex] === 1.0;\n\n  if (!defined(result)) {\n    return new FrustumOutlineGeometry({\n      frustum: frustum,\n      origin: origin,\n      orientation: orientation,\n      _drawNearPlane: drawNearPlane,\n    });\n  }\n\n  const frustumResult =\n    frustumType === result._frustumType ? result._frustum : undefined;\n  result._frustum = frustum.clone(frustumResult);\n\n  result._frustumType = frustumType;\n  result._origin = Cartesian3.clone(origin, result._origin);\n  result._orientation = Quaternion.clone(orientation, result._orientation);\n  result._drawNearPlane = drawNearPlane;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a frustum outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {FrustumOutlineGeometry} frustumGeometry A description of the frustum.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nFrustumOutlineGeometry.createGeometry = function (frustumGeometry) {\n  const frustumType = frustumGeometry._frustumType;\n  const frustum = frustumGeometry._frustum;\n  const origin = frustumGeometry._origin;\n  const orientation = frustumGeometry._orientation;\n  const drawNearPlane = frustumGeometry._drawNearPlane;\n\n  const positions = new Float64Array(3 * 4 * 2);\n  FrustumGeometry._computeNearFarPlanes(\n    origin,\n    orientation,\n    frustumType,\n    frustum,\n    positions\n  );\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  let offset;\n  let index;\n\n  const numberOfPlanes = drawNearPlane ? 2 : 1;\n  const indices = new Uint16Array(8 * (numberOfPlanes + 1));\n\n  // Build the near/far planes\n  let i = drawNearPlane ? 0 : 1;\n  for (; i < 2; ++i) {\n    offset = drawNearPlane ? i * 8 : 0;\n    index = i * 4;\n\n    indices[offset] = index;\n    indices[offset + 1] = index + 1;\n    indices[offset + 2] = index + 1;\n    indices[offset + 3] = index + 2;\n    indices[offset + 4] = index + 2;\n    indices[offset + 5] = index + 3;\n    indices[offset + 6] = index + 3;\n    indices[offset + 7] = index;\n  }\n\n  // Build the sides of the frustums\n  for (i = 0; i < 2; ++i) {\n    offset = (numberOfPlanes + i) * 8;\n    index = i * 4;\n\n    indices[offset] = index;\n    indices[offset + 1] = index + 4;\n    indices[offset + 2] = index + 1;\n    indices[offset + 3] = index + 5;\n    indices[offset + 4] = index + 2;\n    indices[offset + 5] = index + 6;\n    indices[offset + 6] = index + 3;\n    indices[offset + 7] = index + 7;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromVertices(positions),\n  });\n};\nexport default FrustumOutlineGeometry;\n","import defined from \"../Core/defined.js\";\nimport FrustumOutlineGeometry from \"../Core/FrustumOutlineGeometry.js\";\n\nfunction createFrustumOutlineGeometry(frustumGeometry, offset) {\n  if (defined(offset)) {\n    frustumGeometry = FrustumOutlineGeometry.unpack(frustumGeometry, offset);\n  }\n  return FrustumOutlineGeometry.createGeometry(frustumGeometry);\n}\nexport default createFrustumOutlineGeometry;\n"],"names":["FrustumOutlineGeometry","options","Check","typeOf","object","frustum","origin","orientation","drawNearPlane","defaultValue","_drawNearPlane","frustumType","frustumPackedLength","PerspectiveFrustum","packedLength","OrthographicFrustum","this","_frustumType","_frustum","clone","_origin","Cartesian3","_orientation","Quaternion","_workerName","pack","value","array","startingIndex","defined","scratchPackPerspective","scratchPackOrthographic","scratchPackQuaternion","scratchPackorigin","unpack","result","frustumResult","undefined","createGeometry","frustumGeometry","positions","Float64Array","FrustumGeometry","_computeNearFarPlanes","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","offset","index","numberOfPlanes","indices","Uint16Array","i","Geometry","primitiveType","PrimitiveType","LINES","boundingSphere","BoundingSphere","fromVertices"],"mappings":"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"}